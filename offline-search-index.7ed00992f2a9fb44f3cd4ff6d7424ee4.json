[{"body":"","categories":"","description":"","excerpt":"","ref":"/getting-started/","tags":"","title":"Getting Started"},{"body":"The Zymkey App Utils library provides an API which allows user space applications to incorporate Zymkey’s cryptographic features, including:\nGeneration of random numbers Locking and unlocking of data objects ECDSA signature generation and verification In addition, the Zymkey App Utils library provides interfaces for administrative functions, such as:\nControl of the LED Setting the i2c address (i2c units only) Setting the tap detection sensitivity A Note About Files Some of the interfaces can take a filename as an argument. The following rules must be observed when using these interfaces:\nAbsolute path names must be provided. For destination filenames, the permissions of the path (or existing file) must be set: Write permissions for all. Write permissions for common group: in this case, user zymbit must be added to the group that has permissions for the destination directory path and/or existing file. Destination path must be fully owned by user and/or group zymbit. Similar rules exist for source filenames: Read permissions for all. Read permissions for common group: in this case, user zymbit must be added to the group that has permissions for the source directory path and/or existing file. Source path must be fully owned by user and/or group zymbit. Crypto Features Random Number Generation This feature is useful when the default host random number generator is suspected of having cryptographic weakness. It can also be used to supplement existing random number generation sources. Zymkey bases its random number generation on an internal TRNG (True Random Number Generator) and performs well under Fourmilab’s ent.\nData Locker Zymkey includes a feature, called Data Locking. This feature is essentially an AES encryption of the data block followed by an ECDSA signature trailer.\nData Locker Keys In addition to a unique ECDSA private/public key pair, each Zymkey has two unique AES keys that are programmed at the factory.\nECDSA Operations Each Zymkey comes out of the factory with three (Zymkey 4i/HSM4) or 12 (HSM6) unique ECDSA private/public key pairs. These private keys are randomly programmed within hardware at the time of manufacture and never exported. In fact, Zymbit doesn’t even know what the value of the private keys are.\nThere are three ECDSA operations available:\nGenerate signature: The Zymkey is capable of generating an ECDSA signature. Verification signature: The Zymkey is capable of verifying an ECDSA signature. Export the ECDSA public key: This saves the public key to a file in PEM format. This operation is useful for generating a Certificate Signing Request (CSR). Other Features LED The Zymkey has an LED which can be turned on, off or flashed at an interval.\ni2c Address For Zymkeys with an i2c interface, the base address can be changed to work around addressing conflicts. The default address is 0x30, but can be changed in the ranges 0x30 - 0x37 and 0x60 - 0x67.\nTap Sensitivity The Zymkey has an accelerometer which can perform tap detection. The sensitivity of the tap detection is configurable.\nProgramming Language Support Currently, C, C++ and Python are supported.\nBinding Before a Zymkey can be effectively used on a host computer, it must be “bound” to it. Binding is a process where a “fingerprint” is made which is composed of the host computer and its SD card serial numbers as well as the Zymkey serial number. If the host computer or SD card is changed from the time of binding, the Zymkey will refuse to accept commands.\nTo learn more about binding your zymkey, go to the Zymbit Community “Getting Started” page for your Zymkey model (e.g. Getting Started with ZYMKEY).\nHSM4 Soft Bind Lock Unlike Zymkey, HSM4 does not have a physical lock tab that is cut to lock the host binding. Instead, it has a software API for locking the binding to the host. See the soft bind lock API description for more information.\nHSM6 Soft Bind Lock See “HSM4: Soft Bind Lock” above.\nECDH ECDH with some Key Derivation Functions (KDFs) is available. The available KDFs include:\nnone: The raw pre-master secret is returned. rfc5869: This KDF can be invoked with SHA256 or SHA512 as the hashing function. pbkdf2: Like rfc5869, SHA256 or SHA512 can be specified. Koblitz Curve Support In addition to NIST P-256 which is available on Zymkey and HSM4, the Koblitz 256 bit curve is available as well.\nMore Key Slots HSM6 now has 12 factory pre-configured NIST P-256 key slots and 512 key pairs for generated key pair and digital wallet allocation for NIST P-256 or Koblitz 256. All of these key slots can be used for ECDSA as well as ECDH operations. It is also possible to remove the keys in the 512 key pair store and also prohibit public key export.\nForeign Public Keyring 128 public key slots are available to form a public key store for storing foreign party public keys. Like the 512 key pair store, public keys can be removed and prohibited from export.\nDigital Wallet HSM6 provides APIs which allow the creation of 1 or more digital wallets per BIP 32/39/44. The number of master seeds and child nodes is only limited by the number of key pairs provided for in the 512 byte key pair store. The BIP 39 feature provides the mnemonic sentence using the 2048 word English dictionary.\nBattery and Temperature Monitoring The HSM6 has APIs for reading the battery voltage as well as monitoring policies for taking action if certain thresholds are exceeded.\nBattery Monitoring The Battery Monitoring feature provides for 1 of 2 actions if the battery voltage below specified threshold (settable from 2.5V or lower via API).\nself-destruct:\nIf the battery voltage goes lower than the threshold, destroy all key material. Good for use cases where a low battery voltage is interpreted as an attempt to attack the low power tamper detect operation. sleep-until-battery-recovery:\nDo not permit full functionality until the battery has gone above the threshold. Good for use cases where battery replacement is desirable. Temperature Monitoring The Temperature Monitoring feature provides protection from attacks that are based on manipulation of temperature (e.g. memory freeze attacks). If invoked, the system may be configured to destroy keys if temperature thresholds are exceeded.\n","categories":"","description":"","excerpt":"The Zymkey App Utils library provides an API which allows user space …","ref":"/api/api_docs_intro/","tags":"","title":"Intro to Zymkey Application Utilities"},{"body":"Scope This section explains the perimeter detect feature on Zymkey4 and how to use it in your software application with a simple two wire loop physical configuration.\nFor alternative physical configurations and best practices: Learn more \u003e\nPerimeter Detect provides two additional layers of physical security that can be used to detect when the perimeter of your device is breached. This is an important feature when devices are deployed in the field, unattended or in high risk environments.\nZymkey4 includes two independent Perimeter Loops that can be configured to meet different applications.\nWhen a Perimeter Loop is breached, Zymkey4 can be configured (at time of binding) to respond with different “Actions”, depending upon your security policy.\nConnecting Perimeter Loop Circuits Zymkey4 uses a standard microUSB connector to interface to perimeter circuits 1 and 2. This is convenient for rapid prototyping and small scale production situations.\n(For high volume applications, different connector types are available. Contact Zymbit for more details.)\nUsing a Standard USB EXTENSION Cable for Perimeter Loop You can use a micro-usb EXTENSION cable, which carries all necessary signals, to connect to the perimeter detect. Here is one example of an extension cable that will work. (Remove the female connector to expose the flying leads as shown below, then connect your perimeter circuits - P1, P2 - to these)\nIMPORTANT: do NOT use standard micro-usb charging cable it will not work, because it does not have a wire on pin 4.\nElectrical Circuit Each perimeter loop should be connected with a 30 AWG wire or thicker and nominal length of 2 feet. For longer lengths contact Zymbit. The wire should be electrically insulated for all applications. A shielded cable may be necessary for electrically noisy or industrial applications.\nCustom flex PCBs and rigid PCBs may also be used to complete a perimeter loop circuit.\nPerimeter Breach Response Actions Prior to permanently binding your Zymkey to a specific host device, it can be configured through the API to respond to a perimeter breach event in one of three ways. After permanent binding is completed, the selected configuration is locked and immutable.\nResponse Choices A) Do nothing (disable) B) Notify host when perimeter breach occurs C) Destroy all key material (this essentially destroys any encrypted data or file system)\nRefer to API documentation for more details.\nTest Perimeter Detect Developer Mode only\nTo quickly test your perimeter detect setup, here are two samples of code using the Python and C API’s. Both programs will wait for one second to detect any perimeter breaches.\nPlease specify the channel (0 or 1) you are testing in either set_perimeter_event_actions or zkSetPerimeterEventAction. Currently the channel is set to 0. In the API, perimeter circuit 2 (as shown in the above images) is defined as channel 1 and perimeter circuit 1 is defined as channel 0.\nFor Python: import zymkey zymkey.client.set_perimeter_event_actions(0, action_notify=True, action_self_destruct=False) try: zymkey.client.wait_for_perimeter_event(timeout_ms=1000) perim_status_str = \"\" idx = 0 plst = zymkey.client.get_perimeter_detect_info() for p in plst: if p: perim_status_str += \"Channel %d breach timestamp = %d\\n\" % (idx, p) idx += 1 print(\"Perimeter breach detected!\\n\" + perim_status_str) except zymkey.exceptions.ZymkeyTimeoutError: print(\"No perimeter breach detected.\") zymkey.client.clear_perimeter_detect_info() For C: #include \u003cstdio.h\u003e #include \"zk_app_utils.h\" void check_code(int code, char* location) { if (code \u003c 0) { printf(\"FAILURE: %s - %d\\n\", location, code); } else if (code \u003e= 0) { printf(\"SUCCESS: %s - %d\\n\", location, code); } } int main() { zkCTX zk_ctx; int status = zkOpen(\u0026zk_ctx); check_code(status, \"zkOpen\"); status = zkSetPerimeterEventAction(zk_ctx, 0, ZK_PERIMETER_EVENT_ACTION_NOTIFY); check_code(status, \"zkSetPerimeterEventAction\"); int p_code = zkWaitForPerimeterEvent(zk_ctx, 1000); check_code(p_code, \"zkWaitForPerimeterEvent\"); uint32_t* timestamps_sec; int num_timestamps; status = zkGetPerimeterDetectInfo(zk_ctx, \u0026timestamps_sec, \u0026num_timestamps); check_code(status, \"zkGetPerimeterDetectInfo\"); //There was a perimeter event/breach. if (p_code == 0) { printf(\"Perimeter breach detected!\\n\"); for(int i=0; i\u003cnum_timestamps; i++) { printf(\"Channel %d breach timestamp = %d\\n\", i, timestamps_sec[i]); } printf(\"\\n\"); } status = zkClearPerimeterDetectEvents(zk_ctx); check_code(status, \"zkClearPerimeterDetectEvents\"); status = zkClose(zk_ctx); check_code(status, \"zkClose\"); return 0; } To compile\ngcc -I /usr/include/zymkey/ -l zk_app_utils \u003cYour Program\u003e If the perimeter is not breached, zkWaitForPerimeterEvent will return a failure code indicating a timeout occurred and no breach was detected.\nSUCCESS: zkOpen - 0 SUCCESS: zkSetPerimeterEventAction - 0 FAILURE: zkWaitForPerimeterEvent - -110 SUCCESS: zkGetPerimeterDetectInfo - 0 SUCCESS: zkClearPerimeterDetectEvents - 0 SUCCESS: zkClose - 0 Perimeter Detect Circuit Examples For best practices and examples of how to physically configure perimeter circuits: Learn more\u003e\nTroubleshooting Troubleshooting Community\n","categories":"","description":"","excerpt":"Scope This section explains the perimeter detect feature on Zymkey4 …","ref":"/tutorials/perimeter-detect/zymkey4/","tags":"","title":"Perimeter Detect: ZYMKEY4"},{"body":"The HSM4 is a ‘snap in’ security module designed for easy integration within a secure manufacturing environment. All connections are through a single, 30 pin connector that is hidden underneath the module. It is designed specifically to work with Raspberry Pi embedded applications. A PiZero HAT (Hardware Attached on Top) adapter is available for easy integration to the standard GPIO pins of the Pi.\nNotice Raspberry PI OS Bookworm updated the kernel to version 6.6.y in March 2024. The kernel no longer overrides an upstream kernel decision to force the base number of the main GPIO controller to be global GPIO 0. If the WAKE_PIN number is not set, the ZYMKEY will not bind. You will see 5 flashes per second continuously.For RPI4, RPI5, and CM4 platforms, you will need to set the WAKE_PIN in the following manner:\nDetermine the numbering for GPIO4 by examining /sys/kernel/debug/gpio for the number associated with GPIO4, then set an environment variable in the Zymbit environment variable file:\nsudo su wake_pin=`grep GPIO4 /sys/kernel/debug/gpio | sed -r 's/[^0-9]*([0-9]*).*/\\1/'` echo \"wake_pin=$wake_pin\" # sanity check value is set echo \"ZK_GPIO_WAKE_PIN=$wake_pin\" \u003e /var/lib/zymbit/zkenv.conf systemctl restart zkifc As of 6.6.20, the numbering is: RPI4=516 RPI5=575 CM4=516\nIn this Getting Started guide we describe how to install your HSM to a Raspberry Pi running Raspbian or Ubuntu. The installation process is the same for both of these Linux distributions.\nHSM4 Hardware Diagram of HSM placement on PiZero HAT\nSummary of Setup Steps Installing the Hardware Install the HSM on the PiZero HAT. Install the battery on the HAT. Connect the HAT to the host single-board computer. Establish an I2C connection Enable the I2C bus on the host device in order to be able to communicate with the HSM. Install the client software These utilities provided by Zymbit are necessary to interact with the hardware module. Test the installation Your HSM is now temporarily bound to your SBC and ready for use in developer mode. Installing the hardware HSM to PiZero HAT Fit your HSM onto the PiZero HAT (Hardware Attached on Top). The connector plugs into the pins on the board.\nBattery Installation Warning Battery installation is not required for the HSM to function, but it is highly recommended if your device is vulnerable to physical access! To maintain the real-time clock (RTC) and tamper detection features in the event of power loss, your PiZero HAT can be fitted with a 3V CR2032 coincell. This battery should last 3-5 years. We recommend using a high quality one like this.\nPrimary Battery Holder (Recommended) IMPORTANT: Note the correct polarity with +ve facing upwards !!\nOptional Battery Connector (Alternative) Caution: Ensure you select the right connector type– Molex 51021-0200-B (1.25mm Pitch). You can purchase the battery here.\nBattery should look like this: Mating component specifications: Plug wired CR2032 battery into optional battery connector, located below. Install Pi HAT with HSM (and battery) Danger Installing your hardware correctly is important to avoid destroying your SBC or PiHAT. Be sure to follow the instructions below carefully. In particular:\nPay close attention to the images below to ensure the SBC’s GPIO pins are properly aligned with the HAT’s header. Ensure that your Raspberry Pi is powered down before proceeding. Ensure that the coincell battery (if installed) is installed with the positive side (marked with +) facing upward. Before installing Power off your Raspberry Pi to ensure that neither the SBC or the PiHAT are damaged.\nAttach hardware Follow the below pictures to position the PiHAT onto your SBC. The HSM and battery should be facing the Raspberry Pi and concealed from view.\nBe sure all the GPIO pins are aligned and have a respective slot. If misaligned, this could cause damage to the HSM, PiHAT, and/or your host device. Once aligned properly, press firmly down onto the header. Your PiHAT should fit relatively snug.\nResources Using an Alternative GPIO Pin The default configuration uses GPIO4. This can be reconfigured to use another GPIO of your choice. Read article Power on and confirm operation Power up the Pi and you will see a blue LED blinking rapidly and consistently (5 blinks per second). This indicates the HSM is operational but not configured.\nIf the blue LED blinks erratically, or not at all, then there is an installation error and you should check your connections.\nResources Power Quality Considerations Power quality matters to the reliable and secure operation of your system and Zymkey. Read article Establish an I2C connection For Raspian-based operating systems, you must configure the state of the I2C.\nLog in to your Raspberry Pi and run sudo raspi-config. Navigate to Interfacing Options -\u003e I2C -\u003e Would you like the ARM I2C interface to be enabled? Select yes, and confirm this choice. Your I2C bus is now configured and ready to talk to the HSM. The default I2C address for the HSM is 0x30.\nResources HSM4 FAQ \u0026 Troubleshooting How do I set an alternative I2C address? The default I2C address for HSM is 0x30. If this conflicts with another device in your system, you can reconfigure the HSM4 to use another address of your choice. Read article Your I2C bus is now on and ready to talk to the HSM.\nNotice The default mode for the cpu scaling governor is ondemand. There have been some issues with the interaction between the HSM and the I2C bus, when the governor is set to ondemand. We highly recommend to switching the governor to performance to get the most out of the HSM.\nResources CPU Scaling Governor How to set cpu governor to performance. Read article Install the client software Login to your host device and follow these steps to install the HSM’s client software.\nNotice As of March 2023, Raspberry PI OS 32-bit images install the 64-bit kernel along with the 32-bit root filesystem. This does not allow our installation script to work. In order to properly install on an 32-bit system, edit /boot/config.txt and add the following line to the bottom of the file, then reboot.\narm_64bit=0\nThe HSM will require a number of packages to be installed from the Raspbian and Zymbit apt repositories. The following setup script will be install a number of files and software packages on your system, including:\nZymbit .service files located in the /etc/systemd/system directory pip Ensure that curl is installed on your host:\nsudo apt install curl Download and install the necessary Zymbit services onto your device.\ncurl -G https://s3.amazonaws.com/zk-sw-repo/install_zk_sw.sh | sudo bash Test the installation When the software installation has completed, the script will automatically reboot your device. After the reboot has completed, the Pi will perform an operation that will temporarily bind the HSM to your SBC. Once the HSM is bound to the SBC, the HSM’s blue LED should blink slowly–once every 3 seconds–to indicate that the binding is complete.\nResources Binding, Device ID, and Authentication In production mode, HSM generates a unique Device ID by measuring certain attributes of the specific host and the HSM itself to permanently associate the two. Read article The quickest way to get started is to see the HSM’s various features at work by running these test scripts that were installed with the client software:\npython3 /usr/local/share/zymkey/examples/zk_app_utils_test.py python3 /usr/local/share/zymkey/examples/zk_crypto_test.py The example scripts are missing in focal and bullseye distributions. You can get the example scripts from here:\nDownload example files\nNow you’re ready to start developing with HSM and Raspberry Pi. When it’s time to deploy your project, read our guide on enabling Production Mode:\nResources Enabling Production Mode - HSM4 To permanently bind the HSM to a host board, generates a unique Device ID by measuring certain attributes of the host and the HSM itself to associate the two devices. Read article ","categories":"","description":"","excerpt":"The HSM4 is a ‘snap in’ security module designed for easy integration …","ref":"/getting-started/hsm4/quickstart/","tags":"","title":"Quickstart - HSM4"},{"body":"The HSM6 is a ‘snap in’ security module designed for easy integration within a secure manufacturing environment. All connections are through a single, 30 pin connector that is hidden underneath the module. It is designed specifically to work with Raspberry Pi embedded applications. A PiZero HAT (Hardware Attached on Top) adapter is available for easy integration to the standard GPIO pins of the Pi.\nNotice Raspberry PI OS Bookworm updated the kernel to version 6.6.y in March 2024. The kernel no longer overrides an upstream kernel decision to force the base number of the main GPIO controller to be global GPIO 0. If the WAKE_PIN number is not set, the ZYMKEY will not bind. You will see 5 flashes per second continuously.For RPI4, RPI5, and CM4 platforms, you will need to set the WAKE_PIN in the following manner:\nDetermine the numbering for GPIO4 by examining /sys/kernel/debug/gpio for the number associated with GPIO4, then set an environment variable in the Zymbit environment variable file:\nsudo su wake_pin=`grep GPIO4 /sys/kernel/debug/gpio | sed -r 's/[^0-9]*([0-9]*).*/\\1/'` echo \"wake_pin=$wake_pin\" # sanity check value is set echo \"ZK_GPIO_WAKE_PIN=$wake_pin\" \u003e /var/lib/zymbit/zkenv.conf systemctl restart zkifc As of 6.6.20, the numbering is: RPI4=516 RPI5=575 CM4=516\nIn this Getting Started guide we describe how to install your HSM to a Raspberry Pi running Raspbian or Ubuntu. The installation process is the same for both of these Linux distributions.\nHSM6 Hardware Diagram of HSM placement on PiZero HAT\nSummary of Setup Steps Installing the Hardware Install the HSM on the PiZero HAT. Install the battery on the HAT. Connect the HAT to the host single-board computer. Establish an I2C connection Enable the I2C bus on the host device in order to be able to communicate with the HSM. Install the client software These utilities provided by Zymbit are necessary to interact with the hardware module. Test the installation Your HSM is now temporarily bound to your SBC and ready for use in developer mode. Installing the hardware HSM to PiZero HAT Fit your HSM onto the PiZero HAT (Hardware Attached on Top). The connector plugs into the pins on the board.\nBattery Installation Warning Battery installation is not required for the HSM to function, but it is highly recommended if your device is vulnerable to physical access! To maintain the real-time clock (RTC) and tamper detection features in the event of power loss, your PiZero HAT can be fitted with a 3V CR2032 coincell. This battery should last 3-5 years. We recommend using a high quality one like this.\nPrimary Battery Holder (Recommended) IMPORTANT: Note the correct polarity with +ve facing upwards !!\nOptional Battery Connector (Alternative) Caution: Ensure you select the right connector type– Molex 51021-0200-B (1.25mm Pitch). You can purchase the battery here.\nBattery should look like this: Mating component specifications: Plug wired CR2032 battery into optional battery connector, located below. Install Pi HAT with HSM (and battery) Danger Installing your hardware correctly is important to avoid destroying your SBC or PiHAT. Be sure to follow the instructions below carefully. In particular:\nPay close attention to the images below to ensure the SBC’s GPIO pins are properly aligned with the HAT’s header. Ensure that your Raspberry Pi is powered down before proceeding. Ensure that the coincell battery (if installed) is installed with the positive side (marked with +) facing upward. Before installing Power off your Raspberry Pi to ensure that neither the SBC or the PiHAT are damaged.\nAttach hardware Follow the below pictures to position the PiHAT onto your SBC. The HSM and battery should be facing the Raspberry Pi and concealed from view.\nBe sure all the GPIO pins are aligned and have a respective slot. If misaligned, this could cause damage to the HSM, PiHAT, and/or your host device. Once aligned properly, press firmly down onto the header. Your PiHAT should fit relatively snug.\nResources Using an Alternative GPIO Pin The default configuration uses GPIO4. This can be reconfigured to use another GPIO of your choice. Read article Power on and confirm operation Power up the Pi and you will see a blue LED blinking rapidly and consistently (5 blinks per second). This indicates the HSM is operational but not configured.\nIf the blue LED blinks erratically, or not at all, then there is an installation error and you should check your connections.\nResources Power Quality Considerations Power quality matters to the reliable and secure operation of your system and Zymkey. Read article Establish an I2C connection For Raspian-based operating systems, you must configure the state of the I2C.\nLog in to your Raspberry Pi and run sudo raspi-config. Navigate to Interfacing Options -\u003e I2C -\u003e Would you like the ARM I2C interface to be enabled? Select yes, and confirm this choice. Your I2C bus is now configured and ready to talk to the HSM. The default I2C address for the HSM is 0x30.\nResources HSM6 FAQ \u0026 Troubleshooting How do I set an alternative I2C address? The default I2C address for HSM is 0x30. If this conflicts with another device in your system, you can reconfigure the HSM6 to use another address of your choice. Read article Your I2C bus is now on and ready to talk to the HSM.\nNotice The default mode for the cpu scaling governor is ondemand. There have been some issues with the interaction between the HSM and the I2C bus, when the governor is set to ondemand. We highly recommend to switching the governor to performance to get the most out of the HSM.\nResources CPU Scaling Governor How to set cpu governor to performance. Read article Install the client software Login to your host device and follow these steps to install the HSM’s client software.\nNotice As of March 2023, Raspberry PI OS 32-bit images install the 64-bit kernel along with the 32-bit root filesystem. This does not allow our installation script to work. In order to properly install on an 32-bit system, edit /boot/config.txt and add the following line to the bottom of the file, then reboot.\narm_64bit=0\nThe HSM will require a number of packages to be installed from the Raspbian and Zymbit apt repositories. The following setup script will be install a number of files and software packages on your system, including:\nZymbit .service files located in the /etc/systemd/system directory pip Ensure that curl is installed on your host:\nsudo apt install curl\nDownload and install the necessary Zymbit services onto your device.\ncurl -G https://s3.amazonaws.com/zk-sw-repo/install_zk_sw.sh | sudo bash\nTest the installation When the software installation has completed, the script will automatically reboot your device. After the reboot has completed, the Pi will perform an operation that will temporarily bind the HSM to your SBC. Once the HSM is bound to the SBC, the HSM’s blue LED should blink slowly–once every 3 seconds–to indicate that the binding is complete.\nResources Binding, Device ID, and Authentication In production mode, HSM generates a unique Device ID by measuring certain attributes of the specific host and the HSM itself to permanently associate the two. Read article The quickest way to get started is to see the HSM’s various features at work by running these test scripts that were installed with the client software:\npython3 /usr/local/share/zymkey/examples/zk_app_utils_test.py\npython3 /usr/local/share/zymkey/examples/zk_crypto_test.py\nThe example scripts are missing in focal and bullseye distributions. You can get the example scripts from here:\nDownload example files\nNow you’re ready to start developing with HSM and Raspberry Pi. When it’s time to deploy your project, read our guide on enabling Production Mode:\nResources Enabling Production Mode - HSM6 To permanently bind the HSM to a host board, generates a unique Device ID by measuring certain attributes of the host and the HSM itself to associate the two devices. Read article ","categories":"","description":"","excerpt":"The HSM6 is a ‘snap in’ security module designed for easy integration …","ref":"/getting-started/hsm6/quickstart/","tags":"","title":"Quickstart - HSM6"},{"body":"Scope This describes the perimeter detect feature on HSM4.\nPerimeter Detect provides two additional layers of physical security that can be used to detect when the perimeter of your device is breached. This is an important feature when devices are deployed in the field, unattended or in high risk environments.\nHSM4 includes two independent Perimeter Loops that can be configured to meet different applications.\nWhen a Perimeter Loop is breached, HSM4 can be configured (at time of binding) to respond with different “Actions”, depending upon your security policy.\nConnecting Perimeter Loop Circuits HSM4 HAT provides four pin header and FPC connectors to interface to perimeter circuits 1 and 2. This is convenient for rapid prototyping and small scale production situations.\n(For high volume applications, different connector types are available. Contact Zymbit for more details.)\nIf you are incorporating the HSM4 directly into you motherboard, see Engineering Note 20221011 HSM4/HSM6 - Using Perimeter Detect\nElectrical Circuit Each perimeter loop should be connected with a 30 AWG wire or thicker and nominal length of 2 feet. For longer lengths contact Zymbit. The wire should be electrically insulated for all applications. A shielded cable may be necessary for electrically noisy or industrial applications.\nCustom flex PCBs and rigid PCBs may also be used to complete a perimeter loop circuit.\nPerimeter Breach Response Actions Prior to permanently binding your HSM4 to a specific host device, it can be configured through the API to respond to a perimeter breach event in one of three ways. After permanent binding is completed, the selected configuration is locked and immutable.\nResponse Choices A) Do nothing (disable) B) Notify host when perimeter breach occurs C) Destroy all key material (this essentially destroys any encrypted data or file system)\nTest Perimeter Detect Developer Mode only\nTo quickly test your perimeter detect setup, here are two samples of code using the Python and C API’s. Both programs will wait for ten seconds to detect any perimeter breaches. So before running this script, connect the circuits using either the FPC or Pin headers and during the ten second pause in the script, breach the perimeter by unplugging the circuit wires from the Hat. The wait function should immediately exit and the script will finish.\nPlease specify the channel (0 or 1) you are testing in either set_perimeter_event_actions or zkSetPerimeterEventAction. Currently the channel is set to 0. In the API, perimeter circuit 2 (as shown in the above images) is defined as channel 1 and perimeter circuit 1 is defined as channel 0.\nFor Python import zymkey zymkey.client.clear_perimeter_detect_info() zymkey.client.set_perimeter_event_actions(0, action_notify=True, action_self_destruct=False) zymkey.client.wait_for_perimeter_event(timeout_ms=10000) perim_status_str = \"\" idx = 0 plst = zymkey.client.get_perimeter_detect_info() for p in plst: if p: perim_status_str += \"Channel %d breach timestamp = %d\\n\" % (idx, p) idx += 1 print(\"Perimeter breach detected!\\n\" + perim_status_str) For C #include \u003cstdio.h\u003e #include \"zk_app_utils.h\" void check_code(int code, char* location) { if (code \u003c 0) { printf(\"FAILURE: %s - %d\\n\", location, code); } else if (code \u003e= 0) { printf(\"SUCCESS: %s - %d\\n\", location, code); } } int main() { zkCTX zk_ctx; int status = zkOpen(\u0026zk_ctx); check_code(status, \"zkOpen\"); status = zkClearPerimeterDetectEvents(zk_ctx); check_code(status, \"zkClearPerimeterDetectEvents\"); status = zkSetPerimeterEventAction(zk_ctx, 0, ZK_PERIMETER_EVENT_ACTION_NOTIFY); check_code(status, \"zkSetPerimeterEventAction\"); int p_code = zkWaitForPerimeterEvent(zk_ctx, 10000); check_code(p_code, \"zkWaitForPerimeterEvent\"); uint32_t* timestamps_sec; int num_timestamps; status = zkGetPerimeterDetectInfo(zk_ctx, \u0026timestamps_sec, \u0026num_timestamps); check_code(status, \"zkGetPerimeterDetectInfo\"); //There was a perimeter event/breach. if (p_code == 0) { printf(\"Perimeter breach detected!\\n\"); for(int i=0; i\u003cnum_timestamps; i++) { printf(\"Channel %d breach timestamp = %d\\n\", i, timestamps_sec[i]); } printf(\"\\n\"); } status = zkClose(zk_ctx); check_code(status, \"zkClose\"); return 0; } To compile\ngcc -I /usr/include/zymkey/ -l zk_app_utils \u003cYour Program\u003e If the perimeter is not breached, zkWaitForPerimeterEvent will return a failure code indicating a timeout occurred and no breach was detected.\nSUCCESS: zkOpen - 0 SUCCESS: zkSetPerimeterEventAction - 0 FAILURE: zkWaitForPerimeterEvent - -110 SUCCESS: zkGetPerimeterDetectInfo - 0 SUCCESS: zkClearPerimeterDetectEvents - 0 SUCCESS: zkClose - 0 Perimeter Detect Circuit Examples For best practices and examples of how to physically configure perimeter circuits: Learn more\u003e\nTroubleshooting Troubleshooting Community\n","categories":"","description":"","excerpt":"Scope This describes the perimeter detect feature on HSM4.\nPerimeter …","ref":"/tutorials/perimeter-detect/hsm4/","tags":"","title":"Perimeter Detect: HSM4"},{"body":"Scope This describes the perimeter detect feature on HSM6.\nPerimeter Detect provides two additional layers of physical security that can be used to detect when the perimeter of your device is breached. This is an important feature when devices are deployed in the field, unattended or in high risk environments.\nHSM6 includes two independent Perimeter Loops that can be configured to meet different applications.\nWhen a Perimeter Loop is breached, HSM6 can be configured (at time of binding) to respond with different “Actions”, depending upon your security policy.\nConnecting Perimeter Loop Circuits HSM6 HAT provides four pin header and FPC connectors to interface to perimeter circuits 1 and 2. This is convenient for rapid prototyping and small scale production situations.\n(For high volume applications, different connector types are available. Contact Zymbit for more details.)\nIf you are incorporating the HSM6 directly into you motherboard, see Engineering Note 20221011 HSM4/HSM6 - Using Perimeter Detect\nElectrical Circuit Each perimeter loop should be connected with a 30 AWG wire or thicker and nominal length of 2 feet. For longer lengths contact Zymbit. The wire should be electrically insulated for all applications. A shielded cable may be necessary for electrically noisy or industrial applications.\nCustom flex PCBs and rigid PCBs may also be used to complete a perimeter loop circuit.\nPerimeter Breach Response Actions Prior to permanently binding your HSM6 to a specific host device, it can be configured through the API to respond to a perimeter breach event in one of three ways. After permanent binding is completed, the selected configuration is locked and immutable.\nResponse Choices A) Do nothing (disable) B) Notify host when perimeter breach occurs C) Destroy all key material (this essentially destroys any encrypted data or file system)\nTest Perimeter Detect Developer Mode only\nTo quickly test your perimeter detect setup, here are two samples of code using the Python and C API’s. Both programs will wait for ten seconds to detect any perimeter breaches. So before running this script, connect the circuits using either the FPC or Pin headers and during the ten second pause in the script, breach the perimeter by unplugging the circuit wires from the Hat. The wait function should immediately exit and the script will finish.\nPlease specify the channel (0 or 1) you are testing in either set_perimeter_event_actions or zkSetPerimeterEventAction. Currently the channel is set to 0. In the API, perimeter circuit 2 (as shown in the above images) is defined as channel 1 and perimeter circuit 1 is defined as channel 0.\nFor Python import zymkey zymkey.client.clear_perimeter_detect_info() zymkey.client.set_perimeter_event_actions(0, action_notify=True, action_self_destruct=False) zymkey.client.wait_for_perimeter_event(timeout_ms=10000) perim_status_str = \"\" idx = 0 plst = zymkey.client.get_perimeter_detect_info() for p in plst: if p: perim_status_str += \"Channel %d breach timestamp = %d\\n\" % (idx, p) idx += 1 print(\"Perimeter breach detected!\\n\" + perim_status_str) For C #include \u003cstdio.h\u003e #include \"zk_app_utils.h\" void check_code(int code, char* location) { if (code \u003c 0) { printf(\"FAILURE: %s - %d\\n\", location, code); } else if (code \u003e= 0) { printf(\"SUCCESS: %s - %d\\n\", location, code); } } int main() { zkCTX zk_ctx; int status = zkOpen(\u0026zk_ctx); check_code(status, \"zkOpen\"); status = zkClearPerimeterDetectEvents(zk_ctx); check_code(status, \"zkClearPerimeterDetectEvents\"); status = zkSetPerimeterEventAction(zk_ctx, 0, ZK_PERIMETER_EVENT_ACTION_NOTIFY); check_code(status, \"zkSetPerimeterEventAction\"); int p_code = zkWaitForPerimeterEvent(zk_ctx, 10000); check_code(p_code, \"zkWaitForPerimeterEvent\"); uint32_t* timestamps_sec; int num_timestamps; status = zkGetPerimeterDetectInfo(zk_ctx, \u0026timestamps_sec, \u0026num_timestamps); check_code(status, \"zkGetPerimeterDetectInfo\"); //There was a perimeter event/breach. if (p_code == 0) { printf(\"Perimeter breach detected!\\n\"); for(int i=0; i\u003cnum_timestamps; i++) { printf(\"Channel %d breach timestamp = %d\\n\", i, timestamps_sec[i]); } printf(\"\\n\"); } status = zkClose(zk_ctx); check_code(status, \"zkClose\"); return 0; } To compile\ngcc -I /usr/include/zymkey/ -l zk_app_utils \u003cYour Program\u003e If the perimeter is not breached, zkWaitForPerimeterEvent will return a failure code indicating a timeout occurred and no breach was detected.\nSUCCESS: zkOpen - 0 SUCCESS: zkSetPerimeterEventAction - 0 FAILURE: zkWaitForPerimeterEvent - -110 SUCCESS: zkGetPerimeterDetectInfo - 0 SUCCESS: zkClearPerimeterDetectEvents - 0 SUCCESS: zkClose - 0 Perimeter Detect Circuit Examples For best practices and examples of how to physically configure perimeter circuits: Learn more\u003e\nAdditional Self Destruct Policies HSM6 has two additional self destruct policies, independent of Perimeter Detect– temperature and voltage level monitoring. For more information, visit Python documentation or C documentation.\nTroubleshooting Troubleshooting Community\n","categories":"","description":"","excerpt":"Scope This describes the perimeter detect feature on HSM6.\nPerimeter …","ref":"/tutorials/perimeter-detect/hsm6/","tags":"","title":"Perimeter Detect: HSM6"},{"body":"Scope This describes the perimeter detect feature on SCM.\nPerimeter Detect provides two additional layers of physical security that can be used to detect when the perimeter of your device is breached. This is an important feature when devices are deployed in the field, unattended or in high risk environments.\nThe SCM includes two independent Perimeter Loops that can be configured to meet different applications.\nWhen a Perimeter Loop is breached, SCM can be configured (at time of binding) to respond with different “Actions”, depending upon your security policy.\nConnecting Perimeter Loop Circuits When used in conjunction with the Zymbit SCM I/O motherboard, the first perimeter loop connects to the four switches on the bottom of the motherboard; the second perimeter loop is accessible off the two pins labeled Perimeter on the bottom of the motherboard.\nAlternatively, the SCM has a four pin connector to interface to perimeter circuits 1 and 2. Zymbit can provide an optional Perimeter Detect Cable as shown above for demo purposes. Removing and re-attaching the yellow and blue wires can be used to simulate perimeter events.\nElectrical Circuit Each perimeter loop should be connected with a 30 AWG wire or thicker and nominal length of 2 feet. For longer lengths contact Zymbit. The wire should be electrically insulated for all applications. A shielded cable may be necessary for electrically noisy or industrial applications.\nCustom flex PCBs and rigid PCBs may also be used to complete a perimeter loop circuit.\nPerimeter Breach Response Actions For released product, prior to permanently binding your SCM to a specific host device, it can be configured through the API to respond to a perimeter breach event in one of three ways. After permanent binding is completed, the selected configuration is locked and immutable.\nResponse Choices A) Do nothing (disable) B) Notify host when perimeter breach occurs (default as shipped) C) Destroy all key material (this essentially destroys any encrypted data or file system.\nTest Perimeter Detect Developer Mode only\nTo quickly test your perimeter detect setup, here is sample code using the Python API. The program will wait for ten seconds to detect any perimeter breaches. Before running this script, connect the circuits with the provided yellow and blue wires and during the ten second pause in the script, breach the perimeter by unplugging the circuit wires. The wait function should immediately detect the event.\nIn the API, perimeter circuit 2 (as shown in the above images) is defined as channel 1 and perimeter circuit 1 is defined as channel 0. Channel 0 and channel 1 have been set to action_notify=True.\nExample for monitoring Perimeter Events:\nFor Python #!/usr/bin/python3 import zymkey from datetime import datetime import time # Get any existing events, including while powered down with battery in place print(\"Checking for existing events.\") plst = zymkey.client.get_perimeter_detect_info() print(\"Perimeter 1 Timestamp: \" + str(datetime.fromtimestamp(plst[0])) + \" [\" + str(plst[0]) + \"]\") print(\"Perimeter 2 Timestamp: \" + str(datetime.fromtimestamp(plst[1])) + \" [\" + str(plst[1]) + \"]\") # Clear the events print(\"Clearing perimeter detect info...\") zymkey.client.clear_perimeter_detect_info() time.sleep(2) # Loop waiting for events while up and running #while True: while input('Enter or (q)uit: ') != 'q': try: print(\"Waiting 10 secs for an event\") zymkey.client.wait_for_perimeter_event(timeout_ms=10000) plst = zymkey.client.get_perimeter_detect_info() print(\"Perimeter event detected!\") print(\"Perimeter 1 Timestamp: \" + str(datetime.fromtimestamp(plst[0])) + \" [\" + str(plst[0]) + \"]\") print(\"Perimeter 2 Timestamp: \" + str(datetime.fromtimestamp(plst[1])) + \" [\" + str(plst[1]) + \"]\") print(\"Clearing perimeter detect info...\") zymkey.client.clear_perimeter_detect_info() time.sleep(2) except zymkey.exceptions.ZymkeyTimeoutError: print(\"No perimeter event detected. (Timed out)\") Perimeter Detect Circuit Examples For best practices and examples of how to physically configure perimeter circuits: Learn more\u003e\nAdditional Self Destruct Policies SCM has additional self destruct policies independent of Perimeter Detect: Supervised Boot, Low/High Temperature and Low Voltage level monitoring. For more information, visit Python documentation or C documentation.\nTroubleshooting Troubleshooting Community\n","categories":"","description":"","excerpt":"Scope This describes the perimeter detect feature on SCM.\nPerimeter …","ref":"/tutorials/perimeter-detect/scm/","tags":"","title":"Perimeter Detect: SCM"},{"body":"Scope This describes the perimeter detect feature on the Secure Edge Node (SEN)\nPerimeter Detect provides two additional layers of physical security that can be used to detect when the perimeter of your device is breached. This is an important feature when devices are deployed in the field, unattended or in high risk environments. When a Perimeter Loop is breached, the Secure Edge Node can be configured to respond with different “Actions”, depending upon your security policy.\nConnecting Perimeter Loop Circuits Secure Compute Motherboard Perimeter Loop Circuits The Secure Edge Node includes two independent Perimeter Loops that can be configured to meet different applications. The first perimeter loop connects to the four switches on the bottom of the motherboard. The four switches are in a closed position when the Secure Edge Node enclosure is screwed tightly. Opening the Node will open the switches, opening the first perimeter loop.\nThere is also a four pin connector labeled “Perimeter” on the underside of the IO board. The first perimeter loop can be controlled by the two center pins of the header; the second perimeter loop can be controlled by the outside two pins of the header.\nAccess to the Perimeter Loop Circuits. Use a Torx-T10 screwdriver to loosen the six screws holding the Node enclosure together. Flip over and remove the bottom to access the Perimeter Loop circuits.\nElectrical Circuit Each perimeter loop should be connected with a 30 AWG wire or thicker and nominal length of up to 2 feet. For longer lengths contact Zymbit. The wire should be electrically insulated for all applications. A shielded cable may be necessary for electrically noisy or industrial applications.\nCustom flex PCBs and rigid PCBs may also be used to complete a perimeter loop circuit.\nPerimeter Breach Response Actions Prior to permanently binding your Secure Edge Node to a specific host device, it can be configured through the API to respond to a perimeter breach event in one of three ways. After permanent binding is completed, the selected configuration is locked and immutable.\nResponse Choices Do nothing (disable) Notify host when perimeter breach occurs (default as shipped) Destroy all key material (prevents access to encrypted data or root file system) Test Perimeter Detect Developer Mode only\nTo quickly test your perimeter detect setup, here is sample code using the Python API. The program will wait for ten seconds to detect any perimeter breaches. Before running this script, connect the circuits with the provided yellow and blue wires and during the ten second pause in the script, breach the perimeter by unplugging the circuit wires. The wait function should immediately detect the event.\nIn the API, perimeter circuit 2 (as shown in the above images) is defined as channel 1 and perimeter circuit 1 is defined as channel 0. As shipped, Channel 0 and Channel 1 have been set to action_notify=True.\nExample for monitoring Perimeter Events:\nFor Python #!/usr/bin/python3 import zymkey from datetime import datetime import time # Get any existing events, including while powered down with battery in place print(\"Checking for existing events.\") plst = zymkey.client.get_perimeter_detect_info() print(\"Perimeter 1 Timestamp: \" + str(datetime.fromtimestamp(plst[0])) + \" [\" + str(plst[0]) + \"]\") print(\"Perimeter 2 Timestamp: \" + str(datetime.fromtimestamp(plst[1])) + \" [\" + str(plst[1]) + \"]\") # Clear the events print(\"Clearing perimeter detect info...\") zymkey.client.clear_perimeter_detect_info() time.sleep(2) # Loop waiting for events while up and running #while True: while input('Enter or (q)uit: ') != 'q': try: print(\"Waiting 10 secs for an event\") zymkey.client.wait_for_perimeter_event(timeout_ms=10000) plst = zymkey.client.get_perimeter_detect_info() print(\"Perimeter event detected!\") print(\"Perimeter 1 Timestamp: \" + str(datetime.fromtimestamp(plst[0])) + \" [\" + str(plst[0]) + \"]\") print(\"Perimeter 2 Timestamp: \" + str(datetime.fromtimestamp(plst[1])) + \" [\" + str(plst[1]) + \"]\") print(\"Clearing perimeter detect info...\") zymkey.client.clear_perimeter_detect_info() time.sleep(2) except zymkey.exceptions.ZymkeyTimeoutError: print(\"No perimeter event detected. (Timed out)\") Perimeter Detect Circuit Examples For best practices and examples of how to physically configure perimeter circuits: Learn more\u003e\nAdditional Self Destruct Policies SCM has additional self destruct policies independent of Perimeter Detect: Supervised Boot, Low/High Temperature and Low Voltage level monitoring. For more information, visit Python documentation or C documentation.\nTroubleshooting Troubleshooting Community\n","categories":"","description":"","excerpt":"Scope This describes the perimeter detect feature on the Secure Edge …","ref":"/tutorials/perimeter-detect/sen/","tags":"","title":"Perimeter Detect: Secure Edge Node"},{"body":"ZYMKEY4 is the fourth generation of the Zymbit security module designed specifically to work with Raspberry Pi. It connects to the GPIO header of the SBC and uses the I2C bus and GPIO4 as a WAKE_PIN to communicate with the SBC CPU via an encrypted channel.\nIn this Getting Started guide we describe how to install your ZYMKEY4 to a Raspberry Pi running Raspberry PI OS or Ubuntu. The installation process is the same for both of these Linux distributions.\nThe ZYMKEY4 occupies 10 pins on the GPIO header. It can also be used with other GPIO devices attached, or other I2C devices attached. The correct address range and use of IO pins will be described in this guide as well.\nZYMKEY4 Hardware The top and bottom of the ZYMKEY4 hardware showing the location of the GPIO header and other connectors.\nZYMKEY4 Pinout The pinout of the header of the ZYMKEY4. ZYMKEY4 requires exclusive access to GPIO4, which can be remapped to another GPIO pin. It also share the I2C bus with the default address of 0x30.\nSummary of Setup Steps Installing the hardware Install the battery on the ZYMKEY4, and connect it to the host single-board computer (SBC). Establish an I2C connection Enable the I2C bus on the host device in order to be able to communicate with the ZYMKEY4. Install the client software These utilities provided by Zymbit are necessary to interact with the hardware module. Test the installation Your ZYMKEY4 is now temporarily bound to your SBC and ready for use in developer mode. Installing the hardware Battery Installation Warning Battery installation is not required for the ZYMKEY4 to function, but it is highly recommended if your device is vulnerable to physical access! To maintain the real-time clock (RTC) and tamper detection features in the event of power loss, install a high quality 3V CR1025 coincell battery (not included) in the ZYMKEY4’s battery slot with +ve facing upward. Recommend CR1025 from Panasonic or Renata\nHardware Installation Danger Installing your hardware correctly is important to avoid destroying your SBC or ZYMKEY4. Be sure to follow the instructions below carefully. In particular:\nPay close attention to the images below to ensure the SBC’s GPIO pins are properly aligned with the ZYMKEY4’s header. Ensure that your Raspberry Pi is powered down before proceeding. Ensure that the coincell battery (if installed) is installed with the positive side (marked with +) facing upward. Before installing Power off your Raspberry Pi to ensure that neither the SBC or the ZYMKEY4 are damaged.\nAttach hardware Hold the ZYMKEY4 with the LED and battery holder facing upward. Then, carefully align the ZYMKEY4’s connector with the first 10 GPIO pins of the Raspberry Pi.\nPress down firmly on the ZYMKEY4 to connect it to the GPIO pins of the Raspberry Pi. The ZYMKEY4 should fit relatively snug and maintain a tight interference fit around the pins.\nThe ZYMKEY4 occupies 10 pins on the GPIO header. If the header of the ZYMKEY4 isn’t properly aligned with the GPIO header of the Raspberry Pi, both devices could be damaged.\nResources Using an Alternative GPIO Pin The default configuration uses GPIO4. This can be reconfigured to use another GPIO of your choice. Read article Power on and confirm operation After you have connected the hardware and are sure that the pins are properly aligned, power up your Raspberry Pi. You should see a blue LED blinking rapidly and consistently (5 blinks per second). This confirms that your ZYMKEY4 is operation but unconfigured.\nIf the blue LED blinks erractically, or not at all, then there is an installation error and you should check the connections.\nResources Power Quality Considerations Power quality matters to the reliable and secure operation of your system and ZYMKEY4. Read article Establish an I2C connection For Raspian-based operating systems, you must configure the state of the I2C.\nLog in to your Raspberry Pi and run sudo raspi-config. Navigate to Interfacing Options -\u003e I2C -\u003e Would you like the ARM I2C interface to be enabled? Select yes, and confirm this choice. Your I2C bus is now configured and ready to talk to the ZYMKEY4. The default I2C address for the ZYMKEY4 is 0x30. NOTE: The ZYMKEY4 will not show up in the display of tools such as i2cdetect. This is by design.\nResources ZYMKEY4 FAQ \u0026 Troubleshooting How do I set an alternative I2C address? The default I2C address for ZYMKEY4 is 0x30. If this conflicts with another device in your system, you can reconfigure the ZYMKEY4 to use another address of your choice. Read article Notice The default mode for the cpu scaling governor is ondemand. There have been some issues with the interaction between the zymkey and the I2C bus, when the governor is set to ondemand. We highly recommend to switching the governor to performance to get the most out of the zymkey.\nResources CPU Scaling Governor How to set cpu governor to performance. Read article Install the client software Login to your host device and follow these steps to install the ZYMKEY4’s client software.\nNotice As of March 2023, Raspberry PI OS 32-bit images install the 64-bit kernel along with the 32-bit root filesystem. This does not allow our installation script to work. In order to properly install on an 32-bit system, edit /boot/config.txt and add the following line to the bottom of the file, then reboot.\narm_64bit=0\nYou can check whether your root filesystem is 32-bit or 64-bit with dpkg --print-architecture. It will return arm64 for 64-bit filesystems or armhf for 32-bit filesystems.\nThe ZYMKEY4 will require a number of packages to be installed from the Raspbian and Zymbit apt repositories. The following setup script will be install a number of files and software packages on your system, including:\nZymbit .service files located in the /etc/systemd/system directory pip Ensure that curl is installed on your host:\nsudo apt install curl Download and install the necessary Zymbit services onto your device.\ncurl -G https://s3.amazonaws.com/zk-sw-repo/install_zk_sw.sh | sudo bash Test the installation When the software installation has completed, reboot your device. After the reboot has completed, the Raspberry Pi will perform an operation that will temporarily bind the ZYMKEY4 to your SBC. Once the ZYMKEY4 is bound to the SBC, the ZYMKEY4’s blue LED should blink slowly–once every 3 seconds–to indicate that the binding is complete.\nResources Binding, Device ID, and Authentication In production mode, ZYMKEY4 generates a unique Device ID by measuring certain attributes of the specific host and the ZYMKEY4 itself to permanently associate the two. Read article The quickest way to get started is to see the ZYMKEY4’s various features at work by running some example test scripts.\nYou can get the example scripts from here:\nDownload example files\nRun the scripts:\npython3 /usr/local/share/zymkey/examples/zk_app_utils_test.py python3 /usr/local/share/zymkey/examples/zk_crypto_test.py Now you’re ready to start developing with ZYMKEY4 and Raspberry Pi. When it’s time to deploy your project, read our guide on enabling Production Mode:\nResources Enabling Production Mode - ZYMKEY4 To permanently bind the ZYMKEY4 to a host board, generates a unique Device ID by measuring certain attributes of the host and the ZYMKEY4 itself to associate the two devices. Read article ","categories":"","description":"","excerpt":"ZYMKEY4 is the fourth generation of the Zymbit security module …","ref":"/getting-started/zymkey4/quickstart/","tags":"","title":"Quickstart - ZYMKEY4"},{"body":"EU Secure Compute Module - Declaration of Conformity\nFCC Secure Compute Module - Declaration of Conformity\nEU Secure Compute Motherboard - Declaration of Conformity\nFCC Secure Compute Motherboard - Declaration of Conformity\nLetter of Volatility SCM, SEN, Dev Kit I/O\n","categories":"","description":"","excerpt":"EU Secure Compute Module - Declaration of Conformity\nFCC Secure …","ref":"/reference/conformity/scm/","tags":"","title":"Secure Compute Family Conformity Documents"},{"body":"3D Step Model Zymkey 3D model\n2D Drawing GPIO Pinout ","categories":"","description":"","excerpt":"3D Step Model Zymkey 3D model\n2D Drawing GPIO Pinout ","ref":"/reference/cad/zymkey4/","tags":"","title":"Zymkey4"},{"body":"EU Declaration of Conformity\nFCC Declaration of Conformity\nRoHS/Reach Declaration of Conformity\nCalifornia Prop 65 Declaration of Conformity\nLetter of Volatility Zymkey4i, HSM4, HSM6\n","categories":"","description":"","excerpt":"EU Declaration of Conformity\nFCC Declaration of Conformity\nRoHS/Reach …","ref":"/reference/conformity/zymkey4/","tags":"","title":"Zymkey4 Conformity Documents"},{"body":"Altium Zymbit HSM Library-Altium (728 KB)\nKiCAD (Version 6 only) Zymbit HSM4 Library-KiCAD 6 (221 KB)\n3D Step Model HSM4 Can Assembly REV D 1.1.4 STEP (1.1 MB)\nCAD Graphic Summary ","categories":"","description":"","excerpt":"Altium Zymbit HSM Library-Altium (728 KB)\nKiCAD (Version 6 only) …","ref":"/reference/cad/hsm4/","tags":"","title":"HSM4"},{"body":"EU Declaration of Conformity\nFCC Declaration of Conformity\nRoHS/Reach Declaration of Conformity\nCalifornia Prop 65 Declaration of Conformity\nLetter of Volatility Zymkey4i, HSM4, HSM6\n","categories":"","description":"","excerpt":"EU Declaration of Conformity\nFCC Declaration of Conformity\nRoHS/Reach …","ref":"/reference/conformity/hsm4/","tags":"","title":"HSM4 Conformity Documents"},{"body":" Bootware is a secure integrated tool for managing multiple Linux OS installations for edge / embedded Linux machines. Bootware 1.2 supports various Raspberry Pi computers and requires a Zymbit HSM or SCM to run. Bootware takes advantage of security features of various Zymbit products and protects credentials via the HSM.\nIf you want to jump right in, Click here to Get Started! What is Bootware? Bootware is full-featured native OS switcher/manager with first rate support for encrypted root and data partitions. Bootware is not a hypervisor.\nBootware supports both manual and automatic rollback between A and B installations. If rollback fails, Bootware is able to enter recovery to reload one of the installations from either a local image or a remote secure endpoint.\nBootware works with 64-bit versions of Raspberry Pi OS and Ubuntu on Raspberry Pi 4 and 5 and the various compute module variants.\nBootware is not an OS, therefore custom OS builds are generally supported. For larger orders, Zymbit is able to offer device programming and image validation services of custom user OS builds.\nBootware is not an IoT cloud stack, and interoperates well with most popular stacks. Bootware manages the relationship between bare metal and OS installations as simply, securely, and robustly as possible.\nBootware correctly handles potentially conflicting sets of kernels and boot artifacts, allowing for major kernel upgrades to occur without undue distress.\nBootware fully isolates bootable root partitions with separate sets of LUKS credentials, which are securely injected into user s OS initramfs images. Bootware supports a shared data partition, for which the credentials are distributed to new installations. Each new installation gets a clean new set of keys and one root partition cannot access the other.\nNew installations are deployed from within Bootware’s secure enclave, zboot, which boots straight via secure boot. zboot is able to download, validate, and deploy updates without relying on a potentially compromised OS installation to install the next new clean image.\nBootware has a robust workflow for update signing, which may use either hardware or software key options. Update signing occurs on a dedicated publishing node.\nBootware uses full image forklift updates for major OS installations. Partial overlay updates are also supported, and may be installed directly from user mode.\nBootware runs of top of Zymbit’s security services package, which is required to use Zymbit security hardware.\nBootware has additional integrations with Zymbit Secure Edge Nodes, which may be purchased to development and production use, or may be used as reference designs for custom hardware. For highly secure products, such as Secure Compute Modules, Bootware is almost essential in order to apply updates without the ability to use Pi burner tools, which are intentionally disabled.\nBootware installation locations: Bootware secure uboot and the secure enclave, zboot, along with encrypted configurations files are installed in into /boot.\nBootware uses Zymbit LUKS initramfs unlock code already present in standard Zymbit driver package, but will inject credentials before encrypting the initramfs together with the kernel and boot artifacts into an immutable boot image for secure uboot.\nBootware installs zbcli and Bootware scripts into user OS. User must ensure that these packages are present in user images to be deployed using Bootware. User mode tools manage Bootware settings and check for updates on USB drives or on remote endpoints. zbcli also allows user to trigger manual rollback and update installations. Once a suitable update is located, Bootware reboots into zboot to install.\nBootware boot sequence: For Zymbit Secure Compute Modules only, supervisor-based pre-boot environment validates and repairs /boot partition. Zymkey and HSM products do not have this feature.\nPi ROM code boots and loads standard Pi artifacts.\nZymbit uboot loads\nIf user boot is to proceed normally:\nUboot loads, decrypts, and validates boot package for the active boot partition. The package includes everything required to boot that installation inclusive of kernel, initramfs, args, device tree objects, etc.\nBoot counter is incremented and control is passed to the kernel.\nOnce in initramfs, zbunlock is invoked to connect to the HSM and to decrypt LUKS credentials that have been previously injected into initramfs. /root is mounted.\nOnce boot is complete, boot counter is reset. If the boot fails, and the system reboots for whichever reason, the process repeats with boot counter incrementing.\nIf the boot counter has exceeded the threshold, rollback occurs:\nUboot loads zboot to switch to the backup partition\nSystem reboots\nUboot attempts to boot the backup boot partition in the same way it boots the active partition.\nOnce boot is complete, boot counter is reset. If the boot fails, and the system reboots for whichever reason, the process repeats with boot counter incrementing.\nIf the boot counter for the backup partition also exceeds the threshold without a successful boot, the system enters recovery mode:\nUboot loads zboot.\nZboot attempts to locate an image to install either on a local USB drive or on a known remote endpoint.\nIf the image is found, it is installed, and then the system is rebooted into it. All images are checked for correct signatures before applying them to the system.\nIf the image is not found, zboot enters console interactive mode and asks for endpoint information. Any image to be installed must have a proper signature.\nBootware is designed with the singular goal to ensure that properly validated and installed image is booted successfully on user’s machine.\nAdditional Resources Register for Bootware Technical Updates More information on Bootware on zymbit.com Bootware Community Links to Bootware 1.2 Documentation Sections ","categories":"","description":"","excerpt":" Bootware is a secure integrated tool for managing multiple Linux OS …","ref":"/bootware/","tags":"","title":"Welcome to Bootware"},{"body":"Altium Zymbit HSM Library-Altium (728 KB)\nKiCAD (Version 6 only) Zymbit HSM6 Library-KiCAD 6 (221 KB)\n3D Step Model HSM6 Can Assembly REV D 1.1.4.STEP (1.3 MB)\nCAD Graphic Summary ","categories":"","description":"","excerpt":"Altium Zymbit HSM Library-Altium (728 KB)\nKiCAD (Version 6 only) …","ref":"/reference/cad/hsm6/","tags":"","title":"HSM6"},{"body":"EU Declaration of Conformity\nFCC Declaration of Conformity\nRoHS/Reach Declaration of Conformity\nCalifornia Prop 65 Declaration of Conformity\nLetter of Volatility Zymkey4i, HSM4, HSM6\n","categories":"","description":"","excerpt":"EU Declaration of Conformity\nFCC Declaration of Conformity\nRoHS/Reach …","ref":"/reference/conformity/hsm6/","tags":"","title":"HSM6 Conformity Documents"},{"body":"Bootware 1.1: General Platform Release Notice Bootware 1.2 is now available. Bootware 1.2 adds support for all Zymbit devices and now includes the Pi5 platform. The user interface has been re-written from a series of scripts into one, coherent executable. Bootware™ is a set of software tools and micro services for the Zymbit Security Modules. Bootware 1.1 adds support for the ZYMKEY across additional platforms. The following matrix of platforms and Operating Systems support Bootware™:\nPlatform Zymbit Module OS Support CM4 SCM Bookworm 64-bit, Bullseye 64-bit, Ubuntu 22.04 (jammy) CM4 ZYMKEY4 Bookworm 64-bit, Bullseye 64-bit, Ubuntu 22.04 (jammy) Pi4 ZYMKEY4 Bookworm 64-bit, Bullseye 64-bit, Ubuntu 22.04 (jammy) Other significant enhancements in Bootware 1.1: Issue #142 - OS updates that change boot.scr can prevent future boot. Affects Ubuntu. Although the Pi version of Ubuntu does not use U-Boot, Ubuntu’s dpkg kernel update re-writes the file /boot/firmware/boot.scr. boot.scr was used by Bootware 1.0, and a re-write of the file could leave the system unable to boot. Bootware 1.1 no longer relies on the file.\nEnhancement - Bootware 1.1 now includes a common data partition of 512MB. The common data partition is encrypted and the LUKS key (shared by A and B) is locked by the Zymbit HSM.\nTo get started with Bootware, you should have your plaform OS installed and the Zymbit SCM up and running. For our example images, the default hostname is zymbit-dev and the default login is zymbit with a password of zymbit. We recommend you change those during your development process.\nFor any Bootware image, the Pi RAM must exceed the size of the zi image. We recommend the Pi have at least 4MB RAM.\nIt is also recommended to have an HDMI console attached when using Bootware. The process of repartitioning and populating partitions can take substantial time, upwards of 45 minutes and the console serves as a point of reference of activity.\nMore information on Bootware from zymbit.com Bootware 1.1 User’s Guide and Information ","categories":"","description":"","excerpt":"Bootware 1.1: General Platform Release Notice Bootware 1.2 is now …","ref":"/bootware/archive/bootware-one-zero-general/","tags":"","title":"Bootware 1.1 General"},{"body":" Overview The Zymbit Secure Compute Module (SCM) is an all-in-one Linux compute module - secured and ready to deploy into your IoT and edge applications : a Zymbit Security Module + Hardware Wallet + Raspberry Pi CM4 integrated into a secure encapsulated module.\nSCM Physical Architecture Configure and Setup your SCM Power On, Bootup, and SSH in Connect up the ethernet and 12V power. The unit is designed to run headless. You do not need a monitor, keyboard, or mouse. As shipped, the hostname is zymbit-dev and a user named zymbit can be used for SSH login. The default password for SSH is zymbit. Please change your password once you login. Console login has been disabled. Notice All necessary Zymbit software has been pre-installed. No further installation is necessary. The pre-installed image is encrypted and cannot be replaced via rpiboot in the field. Please contact support@zymbit.com for assistance. Monitor the Blue LED on the Zymbit SCM module. The total boot time as configured should take approximately 90 seconds from power on. It will go through the following stages: one slow blink: initializing the SCM one -\u003e two -\u003e three -\u003e four blinks: Supervised Boot is verifying the signed file information rapid blinking: Supervised Boot successfully completed, booting underway blinking stops: USB bus enumeration found SCM; may stay off for seconds one blink every 3 seconds: zkifc has loaded and the system is ready to go Example of Successful Supervised Boot LED Sequence (Click image for video) Pre-loaded OS options Raspberry PI OS Lite (64-bit Bookworm) Raspberry PI OS Lite (Legacy 64-bit Bullseye) Ubuntu Server 22.04 LTS (64-bit jammy) Warning We highly recommend turning off unattended-upgrades prior to the encryption process. In some cases primarily with Ubuntu, during an update/upgrade after encryption, the update-initramfs process may fail and leave the system unable to boot.\nTo mitigate this issue, remove the service unattended-upgrades:\nsystemctl stop unattended-upgrades systemctl disable unattended-upgrades apt remove --purge unattended-upgrades -y Recent Changes Now allow initial SSH via password (use zymbit/zymbit). Please change once logged in.\nNo longer providing SSH key on USB stick; as noted above, you can use password.\nNo longer necessary to register product; no SSH key necessary so no need for key passphrase.\nsudo for user zymbit with password in standard PI OS manner allowed; no need to supply password every time.\nFW 01.02.02release - April 2024. Update bootcode.bin to 1/11/2023 version. You can verify with vcgencmd bootloader_version. Should say 1/11/2023. Necessary to support Ubuntu 22.04.\nFW 01.02.02release - Supports B1 revision of SCM\nFW 01.00.00 - Supports A1 revision of SCM\nFW 01.00.00 - Fixed: #117 Stored tamper event on shutdown has incorrect timestamp\nzkifc 1.2-36 - Fixed: #120 get_public_key() with a very large number crashes zkifc\nzkpkcs 11 1.0-3 - Fixed: #123 zk_pkcs11: Doesn’t work with 64-bit OS\nNotice Issue Number #159 - Major Affects SCM, Firmware version: 01.02.02release (not in earlier firmware releases)\nOn B1 versions of the SCM with firmware version 01.02.02release, generated key pairs created with gen_key_pair() are removed during reboot.\nYou can determine the version with:\npython3 -c \"import zymkey; print(zymkey.client.get_firmware_version())\"\nDetails and Workaround: gen_key_pair(key_type) creates key pairs for slots 16 and up, but a reboot removes the key slots. Keys generated using the BIP32 wallet with gen_wallet_master_seed()/gen_wallet_child_key() keys are not removed on reboot. The BIP32 wallet keys can be used as a workaround for B1 units.\nFor example,\nInstead of:\nkey_slot = gen_key_pair(\"secp256k1\")\nUse:\nseed = zymkey.client.gen_wallet_master_seed(\"secp256k1\", \"\", \"wallet_name\")\nkey_slot = zymkey.client.gen_wallet_child_key(seed, 0, False)\nFrom this point on you can use the key_slot in the same manner to get_public_key(key_slot) or remove_key(key_slot)\nNotes: The problem does not affect the use of slots 0 through 15. The problem does not affect public keys stored in the Foreign key store. BIP32 wallets are hierarchical key stores, meaning removing the wallet master seed will remove all the keys in that wallet; removing a parent will remove all child slots of the parent. See BIP32 for more information. BIP32 wallets can be recovered if you setup a recovery method using either BIP39 mnemonics, or SLIP39 Shamir’s Secret Sharing of mnemonics. Zymbit supports both methods. Your particular application of keys may lend itself to different key hierarchy strategies - you could put one key in each wallet and create many wallets or put many keys in one wallet. For details on wallets, you can see https://docs.zymbit.com/tutorials/digital-wallet/ If you are creating multiple wallets, each wallet must have a unique name. This only affects SCMs with firmware 01.02.02release. This does not affect the HSM6.\nSecure Compute Module SCM Functional Architecture Highlights 100% pin compatible with RPi CM4, all configurations. 100% code compatible with RPi Easy to Scale Pre-encrypted file system Notice The pre-installed image is encrypted and cannot be replaced via rpiboot in the field. Bootware 1.0 can be used to replace Bullseye or Ubuntu 22.04 based Operating System images. See Bootware for details. Pre-loaded Linux kernel (bullseye 64-bit or Ubuntu 22.04 64-bit) Optionally Pre-load with customer software Pre-defined file manifest \u0026 policies Custom MAC OUID blocks available Embedded hardware wallet with SLIP39-Shamir’s Secret Sharing Layers of Security Supervised boot Fully encapsulated Last gasp power defenses Tamper sense and response File system encryption Measured system identity \u0026 authentication Data encryption \u0026 signing Compute Options Broadcom BCM2711, Quad core Cortex-A72 (ARM v8) 64-bit SoC @ 1.5GHz LPDDR4 RAM: 1G to 8G, eMMC: 0G to 32G 2.4/5.0GHz Wi-Fi \u0026 Bluetooth Zymbit Platform Reference Zymbit Secure Edge Node Zymbit Developer Kit 2 Using SCM: API and Examples See API Documentation Working with Supervised Boot Securing the SCM further with the example Sanitization Script Working with the HD Wallet Setting up Tamper Detect Support Release Notes Contact Support ","categories":"","description":"","excerpt":" Overview The Zymbit Secure Compute Module (SCM) is an all-in-one …","ref":"/getting-started/scm/quickstart/","tags":"","title":"Quickstart - Secure Compute Module (SCM)"},{"body":" SCM Developer Kit 3 Warning The SCM Developer Kit 3 is currently still under development. The Dev Kit 3 contains the MOBO2 which is available as an engineeering sample and is not meant for deployment. The items included in the Dev Kit 3 are subject to change. The SCM Developer Kit 3 provides all the hardware and software components required to evaluate the Zymbit Secure Compute Module with the MOBO2 motherboard engineering samples. This motherboard is used in the SEN Pro (Secure Edge Node Pro) product. The Dev Kit includes:\nZymbit Secure Compute Module (Zymbit Security Module and CM4) Zymbit Secure Compute I/O Motherboard2 (MOBO2) Perimeter Detect wires for Channels 1, 2 40-Pin GPIO Header PIN connector 12V Power Supply Zymbit External Battery (optional) Zymbit Dev Kit 3 Motherboard (MOBO2) - Top The top and bottom of the Zymbit SCM Developer Kit3 Motherboard\nZymbit Dev Kit 3 Motherboard (MOBO2) - Bottom Dev Kit 3 - Motherboard2 (MOBO2) Rev X1 Connectors GPIO Pinout Reference SCM Motherboard MOBO2 Rev X1 GPIO Pinout Note: the standard GPIO pinout is accessed on the bottom side of the D35 board.\nConfigure and Setup your SCM Developer Kit 3 Power On Connect the included 12V Power Supply up to the front panel 12V barrel connector. Connect an ethernet cable to the gigabit ethernet port. The unit is designed to run headless. You do not need a monitor, keyboard, or mouse. The only access is via SSH. Monitor the Blue LED on the Zymbit SCM module. The total boot time as configured should take approximately 90 seconds from power on. It will go through the following stages:\none slow blink: initializing the SCM one -\u003e two -\u003e three -\u003e four blinks: Supervised Boot is verifying the signed file information rapid blinking: Supervised Boot successfully completed, booting underway blinking stops: USB bus enumeration found SCM; may stay off for seconds one blink every 3 seconds: zkifc has loaded and the system is ready to go Login via SSH Once the boot sequence completes and the Blue LED is blinking once every three seconds, login remotely via SSH. As shipped, the hostname is zymbit-dev and a user named zymbit can be used for SSH login. The default password for SSH is zymbit. Please change your password once you login. Console login has been disabled.\nSee Quickstart for SCM for more information on how to proceed.\nAdditional information - Using SCM: API and Examples See API Documentation Working with Supervised Boot Securing the SCM further with the example Sanitization Script Working with the HD Wallet Setting up Tamper Detect Support Release Notes Contact Support ","categories":"","description":"","excerpt":" SCM Developer Kit 3 Warning The SCM Developer Kit 3 is currently …","ref":"/getting-started/scm-dev-kit3/quickstart/","tags":"","title":"Quickstart - SCM Developer Kit 3"},{"body":" SCM Developer Kit 2 The SCM Developer Kit2 provides all the hardware and software components required to evaluate the Zymbit Secure Compute Module.\nZymbit Secure Compute Module (Zymbit Security Module and CM4) Zymbit Secure Compute I/O Motherboard Zymbit Perimeter Detect Cable for Channel 2 Zymbit External Battery (optional) 12V Power Supply Contents of Dev Kit Configure and Setup your SCM Developer Kit2 Power On Connect the included 12V Power Supply up to the front panel 12V barrel connector. Connect an ethernet cable to the gigabit ethernet port. The unit is designed to run headless. You do not need a monitor, keyboard, or mouse. The only access is via SSH. Monitor the Blue LED on the Zymbit SCM module. The total boot time as configured should take approximately 90 seconds from power on. It will go through the following stages:\none slow blink: initializing the SCM one -\u003e two -\u003e three -\u003e four blinks: Supervised Boot is verifying the signed file information rapid blinking: Supervised Boot successfully completed, booting underway blinking stops: USB bus enumeration found SCM; may stay off for seconds one blink every 3 seconds: zkifc has loaded and the system is ready to go Login via SSH Once the boot sequence completes and the Blue LED is blinking once every three seconds, login remotely via SSH. As shipped, the hostname is zymbit-dev and a user named zymbit can be used for SSH login. The default password for SSH is zymbit. Please change your password once you login. Console login has been disabled.\nSee Quickstart for SCM for more information on how to proceed.\nAdditional information - Using SCM: API and Examples See API Documentation Working with Supervised Boot Securing the SCM further with the example Sanitization Script Working with the HD Wallet Setting up Tamper Detect Support Release Notes Contact Support ","categories":"","description":"","excerpt":" SCM Developer Kit 2 The SCM Developer Kit2 provides all the hardware …","ref":"/getting-started/scm-dev-kit2/quickstart/","tags":"","title":"Quickstart - SCM Developer Kit 2"},{"body":" Overview Secure Edge Node - Zymbit offers a standard baseline enclosure that accommodates Zymbit’s secure motherboard, Secure Compute Module and a choice of accessories.\nConfigure and Setup your Secure Edge Node Power On Connect 12V Power Supply (available for purchase from Zymbit) up to the front panel 12V barrel connector. Optionally, supply power via PoE to the ethernet connector, or via the SATA edge connector. Connect an ethernet cable to the front panel gigabit ethernet port. The unit is designed to run headless. You do not need a monitor, keyboard, or mouse. The only access is via SSH. Summary of Features Feature Description Enclosure Standard Type D35 Enclosure. Fits into standard 3.5″ drive bay caddy Dimensions 1.04 x 3.95 x 5.80 inches, 26 x 100 x 148mm Power 12V Barrel Style (standard) PoE PD (optional) SATA (optional) LEDs CM4 PWR (red), CM4 Activity (green), SCM Status (blue) Front I/O 1x 1GbE LAN 1x HDMI 1x USB-A 2.0 Onboard Headers 1x AUX USB 2.0 2x CSI Camera 1x DSI Display 1x M.2 B-Key 1x 40-pin GPIO header 1x Micro SIM port. For use with compatible M.2 modules. Push-push type connector 1x Battery connector Molex 51021-0200-B (1.25mm Pitch) 1x Zymbit Security Module for HSM4/HSM6 1x 5V Fan Tamper Circuits 4x Switches complete Channel 1 tamper circuit Header pins for Channel 1 and Channel 2 tamper circuits Pre-installed OS Raspberry PI Bullseye Lite 64-bit (optional 32-bit) Operational Environment Temperature: 0-60 degrees C Boot Sequence While powering up, monitor the Blue LED on end panel of the SEN. The total boot time as configured should take approximately 1-2 minutes from power on. It will go through the following stages:\none slow blink: initializing the SCM one -\u003e two -\u003e three -\u003e four blinks: Supervised Boot is verifying the signed file information rapid blinking: Supervised Boot successfully completed, booting underway blinking stops: USB bus enumeration found SCM; may stay off for seconds one blink every 3 seconds: zkifc has loaded and the system is ready to go Example of Successful Supervised Boot LED Sequence (Click image for video) Login via SSH Once the boot sequence completes and the Blue LED is blinking once every three seconds, login remotely via SSH. As shipped, the hostname is zymbit-dev and a user named zymbit can be used for SSH login. The default password for SSH is zymbit. Please change your password once you login. Console login has been disabled.\nRun example code The quickest way to get started is to see the Secure Edge Node’s various features at work is by running these test scripts. You can get the example scripts from here:\nDownload example files\npython3 /usr/local/share/zymkey/examples/zk_app_utils_test.py python3 /usr/local/share/zymkey/examples/zk_crypto_test.py Now you’re ready to start developing with the Zymbit Secure Compute Module.\nSecure Compute Module Inside the Secure Edge Node is the Secure Compute Module: a Zymbit Security Module + Hardware Wallet + Raspberry Pi CM4 integrated into a secure, encapsulated module. Details of the SCM itself including any other Zymbit specific cofigurations can be found here:\nMotherboard Reference SCM Developer Kit2\nUsing Secure Edge Node/SCM: API and Examples See API Documentation Working with Supervised Boot Securing the SCM further with the example Sanitization Script Working with the HD Wallet Setting up Tamper Detect Support Release Notes Contact Support ","categories":"","description":"","excerpt":" Overview Secure Edge Node - Zymbit offers a standard baseline …","ref":"/getting-started/sen/quickstart/","tags":"","title":"Quickstart - Secure Edge Node"},{"body":"Welcome to Zymbit’s Documentation Site! Here, you will find all the resources you need to learn about and to use all Zymbit products.\nRecent Activity September 2024 Bootware® 1.2 Release:\nAdds support for Pi 5B Adds all new rust-based user interface Adds support for HSM4 and HSM6 u-boot updated to linux 6.6 kernel Bug fixes. See Bootware for details. Latest Platform and OS Support June 2024 Bootware 1.1 General Platform Support - Along with the SCM-based products, Bootware 1.1 includes cross-platform support for ZYMKEY on CM4 and RPi4.\nThe Zymbit Products also include Bookworm 64-bit support.\nOther significant enhancements in Bootware 1.1: Issue #142 - FIXED. OS updates that change boot.scr can prevent future boot. Affects Ubuntu. Although the PI version of Ubuntu does not use U-Boot, Ubuntu’s dpkg kernel update re-writes the file /boot/firmware/boot.scr. boot.scr was used by Bootware 1.0, and a re-write of the file could leave the system unable to boot. Bootware 1.1 no longer relies on the file.\nEnhancement - The common data partition is now encrypted and the LUKS key is locked by the Zymbit HSM.\nApril 2024 Bootware 1.0 is now released for General Availability. Along with Bootware 1.0 GA, The SCM/SEN product line now officially supports both Bullseye 64-bit and Ubuntu 22.04 64-bit.\nMarch 2024 Raspberry PI OS updated kernels to 6.6.y on March 12th. The kernel no longer overrides an upstream kernel decision to force the base number of the main GPIO controller to be global GPIO 0. If the ZYMKEY4 WAKE_PIN number is not set, the ZYMKEY will not bind. The install_zk_sw.sh script has been updated to set the WAKE_PIN number for you if it detects a kernel version of 6.6.x or later. If you update the kernel on an existing installation without making the change below, you will see 5 flashes per second continuously.\nFor RPI4, RPI5, and CM4 platforms, you will need to set the WAKE_PIN in the following manner:\nDetermine the numbering for GPIO4 by examining /sys/kernel/debug/gpio for the number associated with GPIO4, then set an environment variable in the Zymbit environment variable file:\nsudo su wake_pin=`grep GPIO4 /sys/kernel/debug/gpio | sed -r 's/[^0-9]*([0-9]*).*/\\1/'` echo \"wake_pin=$wake_pin\" # sanity check value is set echo \"ZK_GPIO_WAKE_PIN=$wake_pin\" \u003e /var/lib/zymbit/zkenv.conf systemctl restart zkifc The kernel version can be retrieved with uname -r. As of version 6.6.20, the numbering is: RPI4=516 RPI5=575 CM4=516\nYou do not need to do anything for new installations as the install_zk_sw.sh will take care of things for you.\nDecember 2023 We have added support for Bookworm (64-bit) on the Pi5, PI4 and CM4 for the ZYMKEY, HSM4, and HSM6. Follow the Getting Started guides to install and encrypt.\nOctober 2023 Secure Compute Module moved from Revision A to Revision B. The Zymbit Software did not change. The root filesystem partitioning changed from 100% of the eMMC to 50% of the eMMC (encrypted). This was done to accommodate future support for Bootware, which is available in a Preview mode. A utility is included to repartition to 100% (encrypted) if required.\nSee the Troubleshooting/FAQ for more information on the changes from Rev A to Rev B of the SCM itself. ","categories":"","description":"","excerpt":"Welcome to Zymbit’s Documentation Site! Here, you will find all the …","ref":"/","tags":"","title":"Zymbit Documentation"},{"body":"Bootware 1.0 Limited Notice Bootware 1.1 General Release is now available. The General Release adds support for using ZYMKEY4 on Pi platforms. Bootware 1.0 Limited only supports SCM-based products. Bootware™ is a set of software tools and micro services for the Zymbit Secure Compute Module (SCM) based product line, including the Zymbit Secure Edge Node (SEN).\nTo get started with Bootware, you should have an SCM based product (Secure Edge Node or Dev Kit) up and running. The default hostname is zymbit-dev and the default login is zymbit with a password of zymbit. We recommend you change those during your development process.\nIt is also recommended to have an HDMI console attached when using Bootware. The process of repartitioning and populating partitions can take substantial time, upwards of 45 minutes and the console serves as a point of reference of activity.\nMore information on Bootware from zymbit.com Early Preview Customers and Support If you were participating in the Bootware Preview program, please see: Bootware Preview\nContact Support\n","categories":"","description":"","excerpt":"Bootware 1.0 Limited Notice Bootware 1.1 General Release is now …","ref":"/bootware/archive/bootware-one-zero/","tags":"","title":"Bootware 1.0 Limited (deprecated)"},{"body":" Release Notes - Latest Release 1/13/2023 (RC-23.01) We updated the common Zymbit software release common to all products: ZYMKEY4, HSM4, HSM6, and the new SCM-based product line. Existing customers can do an update/upgrade to get the latest code.\nsudo apt-get update sudo apt-get upgrade -y sudo pip3 install zku --upgrade Zymbit Host Side Code Versions (view with dpkg -l | grep -i zym): libzk 1.1-22 libzymkeyssl 1.0-11 zkapputilslib 1.1-25 zkbootrtc 1.1-15 zkifc 1.2-36 zkpkcs11 1.0-3 zksaapps 1.0-16 zku 1.0.33 Changes Added support for Raspberry OS Bullseye 64-bit and Ubuntu 22.04 Jammy 32-bit and 64-bit Common code base supports across all products including SCM. See SCM release notes for details on SCM features. Fixed: #120 get_public_key() with a very large number crashes zkifc Fixed: #123 zk_pkcs11: Doesn’t work with 64-bit OS Fixed: #113 LED resets to default pattern after 5-10 minutes Fixed: #110 Fixed memory leak in zkifc which eventually could lead to zkifc crashing API functions that include Bip or Slip have been renamed to BIP and SLIP. See API docs for new syntax Issues and Solutions Expired GPG Key Preventing Access to Repository The Zymbit GPG key expired and was renewed on September 30, 2024. New installations should not have any problems. apt-get update may complain that the GPG key has expired. To update your local key, do the following:\ncurl -L https://zk-sw-repo.s3.amazonaws.com/apt-zymkey-pubkey.gpg | sudo gpg --dearmor --yes -o /usr/share/keyrings/zymbit.gpg For those of you that are on older installations, make sure the signed-by option is included in the /etc/apt/sources.list.d/zymbit.list,\nThis parameter - [signed-by=/usr/share/keyrings/zymbit.gpg]\nThe following will check and fix for you,\nsudo sed -i 's/^deb https/deb [signed-by=\\/usr\\/share\\/keyrings\\/zymbit.gpg] https/' /etc/apt/sources.list.d/zymbit.list Wake-Pin Issues for upgrades to Kernel 6.6 and later The installation script takes care of the following for you. If you are doing a new installation, you should not have to worry about the following. If you already installed the Zymbit software and then upgraded the kernel to something beyond 6.6, please note the following.\nRaspberry PI OS Bookworm updated the kernel to version 6.6.y in March 2024. The kernel no longer overrides an upstream kernel decision to force the base number of the main GPIO controller to be global GPIO 0. If the WAKE_PIN number is not set, the ZYMKEY will not bind. You will see 5 flashes per second continuously.For RPI4, RPI5, and CM4 platforms, you will need to set the WAKE_PIN in the following manner:\nDetermine the numbering for GPIO4 by examining /sys/kernel/debug/gpio for the number associated with GPIO4, then set an environment variable in the Zymbit environment variable file:\nsudo su wake_pin=`grep GPIO4 /sys/kernel/debug/gpio | sed -r 's/[^0-9]*([0-9]*).*/\\1/'` echo \"wake_pin=$wake_pin\" # sanity check value is set echo \"ZK_GPIO_WAKE_PIN=$wake_pin\" \u003e /var/lib/zymbit/zkenv.conf systemctl restart zkifc As of 6.6.20, the numbering is: RPI4=516 RPI5=575 CM4=516\nCPU Scaling Governor We have seen some issues with the scaling cpu governor on the raspberry pi interfere with the i2c bus. This sometimes causes the zymkey to be put into a odd state or return failures from operations that get optimized out by the governor. The raspberry pi sets the scaling governor to be “ondemand” by default. We recommend switching this mode to “performance” to get the best out of the zymkey. Details:\nResources CPU Scaling Governor How to set cpu governor to performance. Read article Unattended-upgrades When encrypting your rootfs, we highly recommend turning off unattended-upgrades prior to the encryption process. In some cases primarily with Ubuntu, during an update/upgrade after encryption, the update-initramfs process may fail and leave the system unable to boot.\nTo mitigate this issue, remove the service unattended-upgrades:\nCheck /etc/apt/apt.conf.d/20auto-upgrades. Make sure the following lines are set to 0,\nAPT::Periodic::Update-Package-Lists \"0\"; APT::Periodic::Unattended-Upgrade \"0\"; Stop and remove the unattended-upgrade service:\nsudo systemctl stop unattended-upgrades sudo systemctl disable unattended-upgrades sudo apt-get remove --purge -y unattended-upgrades Products Q: Where can I learn about and/or pre-order future products? Expand for Answer A: Sign up for our new product email updates at the bottom of Zymbit’s homepage.\nQ: What are the differences between Zymbit’s Products? Expand for Answer A: See the Product Comparison Matrix for the differences between Zymkey, HSM4, and HSM6. Please reach out with any further questions.\nQ: How much power do Zymbit products consume? Expand for Answer Zymkey-RPi (3.3V): idle approx. 1mA; max active \u003c 25mA with LED off, \u003c 35mA with LED on. Zymkey-USB (5V): idle approx. 1.5mA; max active \u003c 40mA with LEDs off, \u003c 60mA with LEDs on. See Power Quality for more information.\nQ: What is the expected battery life for Zymbit Products? Expand for Answer Compatibility Q: Which operating systems does Zymbit support? Expand for Answer Q: Which SBCs are compatible with Zymbit Products? Expand for Answer Electrically, the Zymkey-I2C will interface to any single board computer using I2C. Check compatibility with your particular Linux distribution. Raspberry Pi 3, 3B+, 4, Zero RPi Compute Module 3, 4 Q: What curves are supported for Zymbit products? Expand for Answer Zymkey and HSM4: NIST P-256 and secp256r1\nSCM and HSM6: NIST P-256, secp256r1, secp256k1, X25519, ED25519\nAll Products: Only EC curves are supported. No RSA support is provided in hardware. RSA support is provided via hardware lock/unlock of PKCS11 store on host.\nQ: Do Zymbit Products work with Arduino? Expand for Answer A: We have no plans to release an Arduino shield version. While we love Arduinos and use them all the time, they generally don’t have enough resources to handle cryptographic operations at this level.\nQ: Do Zymbit Products work with BeagleBone? Expand for Answer A: Zymbit does not officially support the BeagleBoard platform at this time.\n","categories":"","description":"","excerpt":" Release Notes - Latest Release 1/13/2023 (RC-23.01) We updated the …","ref":"/troubleshooting/general/","tags":"","title":"General FAQ \u0026 Troubleshooting"},{"body":" Q: What Zymbit products support Bootware 1.2? Expand for Answer A: Bootware 1.2 runs on all Zymbit products. Hardware signing is only available on Zymbit products that support the digital wallet: SCM and HSM6. Supported Pi platforms include CM4, Pi4, and Pi5.\nQ: What Operating Systems are supported? Expand for Answer A: Bootware 1.2 supports the following OS options:\nBookworm 64-bit Bullseye 64-bit Ubuntu 22.04 (jammy) 64-bit Q: Can I use Bootware to switch Operating Systems from Bookworm to Bullseye or Ubuntu 22.04? Expand for Answer A: Yes, you can switch between the supported Operating Systems. Note: The CM4/SCM firmware must include bootloader version 2023/01/11 or later in order to work with Ubuntu 22.04. The version can be verified with the vcgencmd bootloader_version command.\nQ: Can I use a custom kernel build? Expand for Answer A: Yes, if it is based off of one of the supported OS images - Bullseye or Ubuntu 22.04. You will need to supply your kernel and the corresponding modules from your build. You will need to link or rename your kernel image kernel8.img for Bookworm/Bullseye on a CM4/SCM/Pi4, or kernel_2712.img for the Pi5, or vmlinuz for Ubuntu.\nQ: What are the partitioning schema? Expand for Answer A: Bootware 1.2 primarily consists of three partitioning schemes:\nBoot 512MB, RootA: Approximately 50%, RootB: Approximately 50%, Encrypted Data partition is user configurable with zbcli update-config (default 512MB) Boot 512MB, RootA: Approximately 100%, Encrypted Data partition is user configurable with zbcli update-config (default 512MB) Boot 512MB, RootA: Approximately 50%, Encrypted Data partition is user configurable with zbcli update-config (default 512MB) Q: Are the partitions encrypted? Expand for Answer A: Yes, the Root and Data partitions are encrypted with LUKS encryption. The Root partitions are protected by separate keys, i.e. RootA can only be unlocked with its key; the same key cannot unlock RootB. The Data partition is encrypted with a shared key between A and B; the Data partition is accessible by both RootA and RootB. The Boot partition is not encrypted.\nQ: What types of curves are used to sign and verify zi images? Expand for Answer A: The sign/verify process relies on ECDSA-based curves, in particular secp256k1. Public/Private key pairs can be generated in either software or Zymbit HSM hardware. The ZYMKEY uses software keys.\nQ: Is there Bare Metal Recovery? Expand for Answer A: Bare metal recovery is not currently available.\n","categories":"","description":"Answers to Frequently asked questions regarding Bootware","excerpt":"Answers to Frequently asked questions regarding Bootware","ref":"/bootware/troubleshooting/faq/","tags":"","title":"Frequently Asked Questions"},{"body":" How to Develop on a CM4 and transfer your Image to an SCM Developing your applications on the CM4 allows you the freedom to start completely over in a well-known environment before transitioning to the secure SCM. The steps below outline how to take your existing CM4 solution directly to an SCM using bootware. The end result of this procedure will be an image in zi format ready for transfer to an SCM.\nSteps Start with Bookworm, Bullseye or Ubuntu 22.04 image Load Zymbit software (a ZYMBIT HSM is not necessary) Load/Install bootware tools Use zbcli imager to create a zi image signed with software key Pre-configure the SCM with a known good A/B partition. This is just in case the CM4 image has any problem Load zi image on SCM with zbcli update 1. Start with Bookworm, Bullseye or Ubuntu Follow the standard instructions from Raspberry Pi Foundation using rpiboot and the Pi Imager to load Bookworm or Bullseye Lite 64-bit or Ubuntu Server 22.04 (jammy). Load all of the necessary software and debug and test your application.\n2. Load the Zymbit software Once the image is put together and loaded on the SCM, load Zymbit software. For now, Zymbit hardware is not needed. You only need to complete the software installation. The following will load all packages and reboot to complete the software installation.\ncurl -G https://s3.amazonaws.com/zk-sw-repo/install_zk_sw.sh | sudo bash 3. Install Bootware 1.2 Tools Load the Bootware software. Part of the zi image creation includes all of the Bootware software. Download the Bootware software to the SCM. The Bootware software can be downloaded with curl:\ncurl -sSf https://raw.githubusercontent.com/zymbit-applications/zb-bin/main/install.sh | sudo bash sudo zbcli install The installation script will require a reboot. With everything in place, you can now run zbcli imager to create an image.\n4. Run zbcli imager and sign with a software-based key sudo zbcli imager zbcli imager will build your zi image. At the end of the zi image creation (takes 15-20 minutes, based on the size of your image), your output location will have the private key file, public key file, and the zi image. You will need your public key file along with the zi file to move to the SCM. You should also keep track of your private key file to use if you need to create and sign additional images. The zi image and Public key can be used via local SCM storage such as a USB stick, or via the network and an HTTPS endpoint. Copy the zi file and public key file to the endpoint.\n5. Setup the SCM Prepare your SCM with Bootware and an A/B partition, and a known good image, such as our example image. This is the safest way to insure should something go wrong loading your CM4 image, you will have a way to recover. The Getting Started Guide details the steps. Complete those steps first.\n6. Load the zi file from your ENDPOINT to the SCM Copy your Public key file to a local folder. Run sudo zbcli update and double-check the settings are correct. Enter “n” to correct the configuration. Specify the ENDPOINT (USB or HTTPS) where the zi file is located. If you need to correct anything, use zbcli update-config. Let zbcli update continue. It will confirm your ENDPOINT and prompt for your public key file. Enter your public key file. The process will then continue to load your zi image onto your partitions and attempt to boot up on that partition.\nIf successful, the SCM will end up successfully bound, and up and running on an encrypted partition. Use lsblk to verify the encrypted partition. You should see four partitions, the root, the Active partition (mounted as cryptrfs_A or cryptrfs_B), the backup partition (not mounted), and the shared DATA partition. The blue LED should be blinking once every three seconds. The CM4 image transfer is complete.\nSee also: zbcli imager\nAdditional Information and Support Contact Support\n","categories":"","description":"Outlines the process for developing on the CM4 and transitioning to the secure SCM","excerpt":"Outlines the process for developing on the CM4 and transitioning to …","ref":"/bootware/features/development/","tags":"","title":"Developing on the CM4"},{"body":" zbcli install Description Requires superuser privilege.\nInstalls the Bootware sofware.\nUsage zbcli install [OPTIONS] Options: -y, --yes Says `yes` to all prompts. This includes rebooting your system -h, --help Print help Example sudo zbcli install See also zbcli uninstall\n","categories":"","description":"Installs the Bootware tools and artifacts","excerpt":"Installs the Bootware tools and artifacts","ref":"/bootware/zbcli/install/","tags":"","title":"zbcli install"},{"body":" How to Develop on a CM4 and transfer your Image to an SCM Developing your applications on the CM4 allows you the freedom to start completely over in a well-known environment before transitioning to the secure SCM. The steps below outline how to take your existing CM4 solution directly to an SCM using bootware. The end result of this procedure will be an image in zi format ready for transfer to an SCM.\nSteps Start with Bullseye or Ubuntu 22.04 image Load Zymbit software (a ZYMBIT HSM is not necessary) Load/Install bootware tools Use zb-imager to create a zi image signed with software key Pre-configure the SCM with a known good A/B partition. This is just in case the CM4 image has any problem Load zi image on SCM with zb-update 1. Start with Bullseye or Ubuntu Follow the standard instructions from Raspberry Pi Foundation using rpiboot and the Pi Imager to load Bullseye Lite 64-bit or Ubuntu Server 22.04 (jammy). Load all of the necessary software and debug and test your application.\n2. Load the Zymbit software Once the image is put together and loaded on the SCM, load Zymbit software. For now, Zymbit hardware is not needed. You only need to complete the software installation. The following will load all packages and reboot to complete the software installation.\ncurl -G https://s3.amazonaws.com/zk-sw-repo/install_zk_sw.sh | sudo bash 3. Install Bootware 1.1 Tools Load the Bootware software. Part of the zi image creation includes all of the Bootware software. Download the Bootware software to the SCM. The Bootware software can be downloaded with curl:\ncurl https://bootware.s3.amazonaws.com/bootware-1.1.tgz --output bootware-1.1.tgz Once the tar file is downloaded, untar:\ntar xvzf bootware-1.1.tgz Run the following install script on the SCM to install the zboot utilities:\ncd bootware-1.1 sudo ./zb-install.sh The installation script will do two reboots. With everything in place, you can now run zb-imager to create an image.\n4. Run zb-imager and sign with a software-based key The next step will be to create the zi image to load with Bootware onto your SCM. Use the Software Key choices since there is no Zymbit HSM hardware involved at this point. zb-imager will default to prompt you to use a software key, and will create one for you.\nsudo zb-imager Make the following selections:\nItem Description Image Type? Choose 1. for a Full Image Name of Image?: Any name. Ex. myImage. Name of the converted output file. A zi extension will be added to the name. Version?: 1.1 Optional. An arbitrary version number for your reference. Next, you will be prompted for Signing Keys. Hit return to choose the default Software option. Choose to let the script create keys for you.\nItem Description Use software-based keys? Yes Key? 1. Create new software key The zb-imager script will now build your zi image. At the end of the zi image creation (takes 15-20 minutes, based on the size of your image), the script will show you the paths for the private key file, public key file, and the zi image. You will need your public key file along with the zi file to move to the SCM. You should also keep track of your private key file to use if you need to create and sign additional images. The zi image and private key can be used via local SCM storage such as a USB stick, or via the network and an HTTPS endpoint. Copy the zi file and public key file to the endpoint.\n5. Setup the SCM Prepare your SCM with Bootware and an A/B partition, and a known good image, such as our example image. This is the safest way to insure should something go wrong loading your CM4 image, you will have a way to recover. The Getting Started Guide details the steps. Complete those steps first.\n6. Load the zi file from your ENDPOINT to the SCM Copy your public key file to a local folder. Run sudo zb-update and double-check the settings are correct. Enter “n” to correct the configuration. Specify the ENDPOINT (USB or HTTPS) where the zi file is located. Choose one root filesystem - false for A/B, update_mode=UPDATE_BACKUP, and resize_a=false. Let zb-update continue. It will confirm your ENDPOINT and prompt for your public key file. Enter your public key file. The process will then continue to load your CM4 image onto the BACKUP partition, and attempt to boot up on that partition.\nIf successful, the SCM will end up successfully bound, and up and running on an encrypted partition. Use lsblk to verify the encrypted partition. The blue LED should be blinking once every three seconds. The CM4 image transfer is complete.\nSee also: zb-imager utility\nAdditional Information and Support Contact Support\n","categories":"","description":"","excerpt":" How to Develop on a CM4 and transfer your Image to an SCM Developing …","ref":"/bootware/archive/bootware-one-zero-general/features/development/","tags":"","title":"Developing on the CM4"},{"body":" zb-install.sh Description Requires superuser privilege. Resides in the original bootware untar directory.\nInstalls the Bootware sofware.\nUsage zb-install.sh [-y] -y\tAnswers Yes to all prompts. Warning: will reboot without confirmation. Example cd ~/bootware-1.1 sudo ./zb-install See also zb-uninstall\n","categories":"","description":"","excerpt":" zb-install.sh Description Requires superuser privilege. Resides in …","ref":"/bootware/archive/bootware-one-zero-general/utilities/zbinstall/","tags":"","title":"Zymbit Bootware Install Utility"},{"body":" Notice Bootware 1.0 GA Release is now available.\nBootware Preview is an Engineering/Developer Preview. This is not meant for Production. Bootware Preview features are not standard product. Only load this feature if you are working directly with Zymbit as a Preview customer.\nWe recommend attaching an HDMI console when using Bootware Preview. The process of repartitioning and populating partitions can take substantial time, upwards of 45 minutes and the console serves as a point of reference of activity.\nBootware Release Schedule: Bootware 1.x General - June 2024 Bootware 1.x Limited - April 2024 Bootware Preview (deprecated) – February 2024. Limited functionality. Not intended for Production. Notable changes from Bootware Preview to GA Bootware 1.0 Utility name changes: The following utilities changed names:\nItem Preview 1.0 Download location https://zk-sw-repo.s3.amazonaws.com/ota_preview/ https://bootware.s3.amazonaws.com/ Bootware tarball zymbit-ota-preview.tgz bootware-1.0.tgz Bootware Install install_zboot_tools.sh zb-install.sh Bootware Imager zymbit-image-converter zb-imager Bootware Updater zboot-install-new-update zb-update Bootware Uninstall uninstall_zboot.sh zb-uninstall.sh Updates: Bootware Preview 2.1 (Jan 10, 2024)\nIssue #140 : Bootware Preview 2.0 has an issue with uboot and cached environment variables. This is a uboot issue but it affects bootware during kernel/os upgrades that include device tree changes. It is highly likely that a device tree area change can leave the system in an unbootable state. u-boot will fail with a “Flattened Device Tree” error and fail to boot. This has been fixed in Preview 2.1 (01092024). zboot version in green will read 0.3.1. Bootware Preview has been updated to include the fix for this issue, along with the example image.\nBOOTWARE PREVIEW FEATURE SET (October 2023) Bootware Preview is designed for customers to do the following: Transfer a Raspberry Pi CM4 image to an SCM Replicate an SCM “golden image” to other SCMs Store an original golden image in one eMMC partition plus a copy for development in a second partition, allowing regression to the original golden image at will To achieve this functionality, Bootware Preview provides the following new SCM functionality: The ability to make and update two partitions (A/B), managed by a partition supervisor called zboot. A zboot methodology to load (and subsequently reload) the A/B partitions from a USB or a URL endpoint The ability to manually select to boot from one partition or the other. Initial tools and scripts for creating and loading images into the A/B partitions. Automatic rollback and recovery of A/B partitions. Important Bootware Preview Restrictions Two partitions (A/B) are supported. A shared data partition is not included in the Preview. In an A/B partition layout, the maximum SCM partition size is 14.4 GB. Images larger than 14.4 GB should not be attempted. Only load SCM or CM4 images that have been tested. The Preview unit cannot recover if it cannot access the zboot bootloader. “bare metal recovery” is not included in the Preview. The Zymbit SCM uses its own/boot/config.txt that both enables zboot and the dwc2 driver. Do not enable otg_mode in config.txt. USB storage devices most likely require a powered hub when using the Zymbit Secure Edge Node or Zymbit Dev IO board. Failure to do so may result in the SCM rebooting. Only Raspberry Pi OS Bullseye64-based images are supported by the Preview. For other images, please contact Zymbit for verification Image security features are not enabled in the Preview release. Secure image rollback and recovery features will be implemented in the final release. Using zboot - Hardened Zymbit boot utility Zboot is Zymbit’s boot utility included with Bootware that pulls and reflashes a device with a new user image. In the current Preview, the image can be downloaded two ways:\nover the network via https from a USB storage device Warning The current Preview of zboot does not have bare metal recovery. The boot process must make it at least to zboot in order to take action to recover. Getting Started - Download and Install Bootware Software Download the Bootware software to the SCM. The Bootware software can be downloaded with curl:\ncurl https://zk-sw-repo.s3.amazonaws.com/ota_preview/zymbit-ota-preview.tgz --output zymbit-ota-preview.tgz Once the tar file is downloaded, untar:\ntar xvzf zymbit-ota-preview.tgz The contents will be extracted into zymbit-ota-preview/. Files extracted:\nItem Description install_zboot_tools.sh Shell script to install zboot tools scripts/ Scripts and configuration files for zboot zboot_artifacts/ zboot executable and boot artifacts Run the following install script on the SCM to install the zboot utilities:\ncd zymbit-ota-preview sudo ./install_zboot_tools.sh Installing zboot tools... Reading package lists... Done Building dependency tree... Done … Installing zboot... Done! After installing the zboot tools. A reboot is required. Reboot now? (Y/n) Reboot to complete the installation process. Once completed, all necessary files required for loading new images via zboot will be installed.\nInstalling and running zboot to reflash an image zboot requires images in a particular format unique to zboot. An image conversion tool is provided. Input images can be either complete binary images of your entire eMMC or tarballs of your /boot and /rootfs partitions. NOTE: This does not have to be done on the running device. The script can be run on any workstation.\nIf you would like to get started with a sample image, we’ve converted the base image installed on the SCM for the preview to a zboot format. Otherwise, continue on to create your own image. Our example image can be downloaded from here, or you can use the URL as a valid endpoint to load a known good image:\ncurl https://zk-sw-repo.s3.amazonaws.com/ota_preview/base_preview.zi --output base_preview.zi The script used to convert to a zboot image is:\nzymbit-image-converter [ test.img | {-b \u003cboot.tar\u003e -r \u003croot.tar} | -z ] [-o \u003cdirectory\u003e ] test.img\tBinary image file of eMMC (e.g. created from dd). Name of output image need not match. -b\t\u003cboot.tar\u003e Use this boot tarball as input. Must include -r option. -r \u003croot.tar\u003e Use this root tarball as input. Must include -b option. -o \u003cdirectory\u003e Output directory for new .zi image. -z Creates a zi image from your current running root file system. Examples of Image conversions: Example to create a zi image from your current running root file system sudo zymbit-image-converter -z Item Description Name of Image?: base_preview Name of the converted output file. A zi extension will be added to the name. The name does not need to match the name given on the command line. Version?: 2.1 An arbitrary version number for your reference. Example to convert a binary image file (created from dd if=/dev/sda bs=4M of=my.img): sudo zymbit-image-converter my.img The script will prompt for information:\nItem Description Name of Image?: base_preview Name of the converted output file. A zi extension will be added to the name. The name does not need to match the name given on the command line. Version?: 2.1 An arbitrary version number for your reference. Boot File System Partition Number? (EX: 1): 1 Partition number of boot filesystem in binary image file. Must be provided; no default. Root File System Partition Number? (EX: 2): 2 Partition number of root filesystem in binary image file. Must be provided; no default. The script extracts the boot/root tarballs of the binary image. It will then packages it up in a Zymbit image and output it to:\n/etc/zymbit/zboot/update_artifacts/output/base_preview.zi\nExample to convert boot/root tarballs (created from tar cvf my_boot.tar \u003cboot_part\u003e, tar cvf my_rfs.tar \u003croot_part\u003e) You will need to provide the names and paths to your tarballs. Run the script:\nsudo zymbit-image-converter -b ./boot.tar -r ./root.tar The script will prompt for information:\nItem Description Name of Image?: base_preview Name of the converted output file. A zi extension will be added to the name. Version?: 2.1 An arbitrary version number for your reference. The script extracts the boot/root tarballs of the binary image. It will then package it up in a Zymbit image and output it to:\n/etc/zymbit/zboot/update_artifacts/output/base_preview.zi\nPut the .zi image from the script on a server or USB drive for download. Zboot downloads images from either a USB storage device or the internet via curl requests.\nUse the Bootware Wizard to Configure your System Bootware Preview includes a a tool to help configure your system called zb-wizard. zb-wizard is meant to set your device environment up for pulling down updates from a configured endpoint and the update policies for how to apply those updates. Bootware recommends update policies with A/B schema to have a stable backup partition for rollback. To start the wizard,\nsudo zb-wizard Choose your settings as described below.\nBootware Wizard -Main Screen Choose your options, save and exit.\nPartition Setup – Specifies the device partition layout after an update. The root file system will be re-partitioned with your chosen configuration. Filesystem sizes estimates are based off of 32GB CM4s.\n1 A Only [HALF DISK] – This will take the remaining disk space available after the boot partition and create an encrypted partition that will use half of this space as the root partition (around 14.4 GB). This leaves half the disk empty on purpose for dev usage.\n2 A only [FULL DISK] – This will take the remaining disk space available after the boot partition (around ~29GB) and create an encrypted partition that will use almost all of this space as the root partition.\n3 A/B – RECOMMENDED This will take the remaining disk space available after the boot partition and create two encrypted partitions, each taking up half of the remaining space (around 14.4 GB). Most useful for rollback and recovery with an Active/Backup configuration.\nUpdate Policy – The update policies are centered around how a new update gets applied to the filesystems on the device. The update policies listed below are only related to (A)ctive/(B)ackup partitioned devices, as (A)ctive only devices only have one filesystem to update.\n1 Backup – RECOMMENDED Apply new updates to current backup filesystem and swap to booting the new updated backup partition as the active partition now. If the new update is bad, it will rollback into the previous stable active partition. Only relevant when configured with A/B partitions.\n2 Active – Apply new updates to only the current active filesystem and keep the backup partition untouched. Only relevant when configured with A/B partitions.\n3 Both – Apply new updates to both filesystems and always boot on the first root partition as the active partition. Warning: A bad update will have nothing to rollback to; the device will have to go through a recovery process.\nEndpoint Setup – The configured endpoint ready with a new update(.zi image). The endpoint can be either an https URL or an external mass storage device like a USB stick.\nEndpoint – Type the endpoint where the .zi image resides for the device to pull updates from. The endpoint will be checked for validity.\nExample https URL: https://zk-sw-repo.s3.amazonaws.com/ota_preview/base_preview.zi Example USB stick: /dev/sda1\nWireless Setup – Bootware supports pulling updates via Wifi or LAN connections. Wifi credentials need to be provided in order for bootware to access the wifi during updates. If no wireless credentials are provided, the wireless interface is disabled in zboot.\nSSID - Provide the Wifi SSID Passphrase - Provide the Wifi passphrase Save and Exit. You may also choose to Revert to the default configuration.\nUse zboot to Install the New Image Once you have completed using the Wizard to configure your Bootware, run zboot-install-new-update to complete the process by repartitioning and loading your image.\nsudo zboot-install-new-update The script will show your configuration for review and confirmation, or give you the option to change the configuration. This method can be used as an alternative to using the Wizaard.\nzboot-install-new-update Review and continue for zboot update\nThe script will prompt for a reboot to complete the process.\nzboot Boot Process The Zboot process will now take place.\nWarning The initial configuration process can take up to 45 minutes to complete. The process can be completed via ssh, but an HDMI console is helpful to follow the process. During the process, the blue LED will be OFF. On the console, you will see:\n“Loading: Encrypted zboot please wait…” message, which takes around 4-5min. The A/B partitions will be configured and setup for LUKS encryption protected by the Zymbit SCM It will then take a few minutes to get/unpack tarballs from the image. It will take some time to unpack the image into the A/B root partitions - approximately 7 minutes, each. Once it’s done unpacking the image to the A and B partitions, it will boot into the updated ACTIVE partition. You can use lsblk to examine the partitions. Reload all utilities The Bootware utilities are needed for Bootware to function. If not included in your newly loaded image, you will need to load the utilities into your partition(s). Our example zi file base_preview.zi has the Bootware Utilities pre-loaded.\nRecovery Each successful boot will clear a max_boot_failure counter. A max_boot_failure count of 3 will trigger the recovery mechanism. The BACKUP partition will become the ACTIVE partition. If neither can boot, the endpoint with a good image will be loaded. A ROLLOVER notification message will be added to the MOTD.\nForce Failover (Change Active/Backup partitions) A failover from Active to Backup is done with the -r option to zboot-install-new-update\nsudo zboot-install-new-update -r Uninstall Bootware A utility is included to uninstall bootware, returning to the standard linux boot process. The uninstall process will leave you in the current encrypted active partition and preserve the contents of that partion as well as the overall partition layout.\ncd ~/zymbit-ota-preview sudo ./uninstall_zboot.sh The script will confirm you would like to uninstall the bootware scripts and artifacts, as well as a required reboot.\nAdditional Information and Support Contact Support\n","categories":"","description":"","excerpt":" Notice Bootware 1.0 GA Release is now available.\nBootware Preview is …","ref":"/bootware/archive/bootware-preview/","tags":"","title":"Bootware Preview (deprecated)"},{"body":"","categories":"","description":"","excerpt":"","ref":"/reference/product-briefs/zymkey4/","tags":"","title":"ZYMKEY4 Product Brief"},{"body":"The Zymkey App Utils library provides an API which allows user space applications to incorporate Zymkey’s cryptographic features, including:\nGeneration of random numbers Locking and unlocking of data objects ECDSA signature generation and verification In addition, the Zymkey App Utils library provides interfaces for administrative functions, such as:\nControl of the LED Setting the i2c address (i2c units only) Setting the tap detection sensitivity A Note About Files Some of the interfaces can take a filename as an argument. The following rules must be observed when using these interfaces:\nAbsolute path names must be provided. For destination filenames, the permissions of the path (or existing file) must be set: Write permissions for all. Write permissions for common group: in this case, user zymbit must be added to the group that has permissions for the destination directory path and/or existing file. Destination path must be fully owned by user and/or group zymbit. Similar rules exist for source filenames: Read permissions for all. Read permissions for common group: in this case, user zymbit must be added to the group that has permissions for the source directory path and/or existing file. Source path must be fully owned by user and/or group zymbit. Crypto Features Random Number Generation This feature is useful when the default host random number generator is suspected of having cryptographic weakness. It can also be used to supplement existing random number generation sources. Zymkey bases its random number generation on an internal TRNG (True Random Number Generator) and performs well under Fourmilab’s ent.\nData Locker Zymkey includes a feature, called Data Locking. This feature is essentially an AES encryption of the data block followed by an ECDSA signature trailer.\nData Locker Keys In addition to a unique ECDSA private/public key pair, each Zymkey has two unique AES keys that are programmed at the factory.\nECDSA Operations Each Zymkey comes out of the factory with three (Zymkey 4i/HSM4) or 12 (HSM6) unique ECDSA private/public key pairs. These private keys are randomly programmed within hardware at the time of manufacture and never exported. In fact, Zymbit doesn’t even know what the value of the private keys are.\nThere are three ECDSA operations available:\nGenerate signature: The Zymkey is capable of generating an ECDSA signature. Verification signature: The Zymkey is capable of verifying an ECDSA signature. Export the ECDSA public key: This saves the public key to a file in PEM format. This operation is useful for generating a Certificate Signing Request (CSR). Other Features LED The Zymkey has an LED which can be turned on, off or flashed at an interval.\ni2c Address For Zymkeys with an i2c interface, the base address can be changed to work around addressing conflicts. The default address is 0x30, but can be changed in the ranges 0x30 - 0x37 and 0x60 - 0x67.\nTap Sensitivity The Zymkey has an accelerometer which can perform tap detection. The sensitivity of the tap detection is configurable.\nProgramming Language Support Currently, C, C++ and Python are supported.\nBinding Before a Zymkey can be effectively used on a host computer, it must be “bound” to it. Binding is a process where a “fingerprint” is made which is composed of the host computer and its SD card serial numbers as well as the Zymkey serial number. If the host computer or SD card is changed from the time of binding, the Zymkey will refuse to accept commands.\nTo learn more about binding your zymkey, go to the Zymbit Community “Getting Started” page for your Zymkey model (e.g. Getting Started with ZYMKEY).\nHSM4 Soft Bind Lock Unlike Zymkey, HSM4 does not have a physical lock tab that is cut to lock the host binding. Instead, it has a software API for locking the binding to the host. See the soft bind lock API description for more information.\nHSM6 Soft Bind Lock See “HSM4: Soft Bind Lock” above.\nECDH ECDH with some Key Derivation Functions (KDFs) is available. The available KDFs include:\nnone: The raw pre-master secret is returned. rfc5869: This KDF can be invoked with SHA256 or SHA512 as the hashing function. pbkdf2: Like rfc5869, SHA256 or SHA512 can be specified. Koblitz Curve Support In addition to NIST P-256 which is available on Zymkey and HSM4, the Koblitz 256 bit curve is available as well.\nMore Key Slots HSM6 now has 12 factory pre-configured NIST P-256 key slots and 512 key pairs for generated key pair and digital wallet allocation for NIST P-256 or Koblitz 256. All of these key slots can be used for ECDSA as well as ECDH operations. It is also possible to remove the keys in the 512 key pair store and also prohibit public key export.\nForeign Public Keyring 128 public key slots are available to form a public key store for storing foreign party public keys. Like the 512 key pair store, public keys can be removed and prohibited from export.\nDigital Wallet HSM6 provides APIs which allow the creation of 1 or more digital wallets per BIP 32/39/44. The number of master seeds and child nodes is only limited by the number of key pairs provided for in the 512 byte key pair store. The BIP 39 feature provides the mnemonic sentence using the 2048 word English dictionary.\nBattery and Temperature Monitoring The HSM6 has APIs for reading the battery voltage as well as monitoring policies for taking action if certain thresholds are exceeded.\nBattery Monitoring The Battery Monitoring feature provides for 1 of 2 actions if the battery voltage below specified threshold (settable from 2.5V or lower via API).\nself-destruct:\nIf the battery voltage goes lower than the threshold, destroy all key material. Good for use cases where a low battery voltage is interpreted as an attempt to attack the low power tamper detect operation. sleep-until-battery-recovery:\nDo not permit full functionality until the battery has gone above the threshold. Good for use cases where battery replacement is desirable. Temperature Monitoring The Temperature Monitoring feature provides protection from attacks that are based on manipulation of temperature (e.g. memory freeze attacks). If invoked, the system may be configured to destroy keys if temperature thresholds are exceeded.\n","categories":"","description":"","excerpt":"The Zymkey App Utils library provides an API which allows user space …","ref":"/api/","tags":"","title":"API Documentation"},{"body":" Q: What Zymbit products support Bootware 1.1? Expand for Answer A: Bootware 1.1 runs on the Secure Compute Module based products - the Secure Edge Node, SCM Development kits, SCM modules. Bootware 1.1 can also run with a ZYMKEY4 on a Dev Kit with an SCM, or with a ZYMKEY on a Raspberry Pi4.\nQ: What Operating Systems are supported? Expand for Answer A: Bootware 1.1 supports the following OS options:\nBookworm 64-bit Bullseye 64-bit Ubuntu 22.04 (jammy) 64-bit Q: Can I use Bootware to switch Operating Systems from Bookworm to Bullseye or Ubuntu 22.04? Expand for Answer A: Yes, you can switch between the supported Operating Systems. Note: The CM4/SCM firmware must include bootloader version 2023/01/11 or later in order to work with Ubuntu 22.04. The version can be verified with the vcgencmd bootloader_version command.\nQ: Can I use a custom kernel build? Expand for Answer A: Yes, if it is based off of one of the supported OS images - Bullseye or Ubuntu 22.04. You will need to supply your kernel and the corresponding modules from your build. You will need to link or rename your kernel image kernel8.img for Bookworm/Bullseye, or vmlinuz for Ubuntu.\nQ: What are the partitioning schema? Expand for Answer A: Bootware 1.1 primarily consists of three partitioning schemes:\nBoot 512MB, RootA: Approximately 50%, RootB: Approximately 50%, Encrypted Data partition 512MB Boot 512MB, RootA: Approximately 100%, Encrypted Data partition 512MB Boot 512MB, RootA: Approximately 50%, Encrypted Data partition 512MB Q: Are the partitions encrypted? Expand for Answer A: Yes, the Root and Data partitions are encrypted with LUKS encryption. The Root partitions are protected by separate keys, i.e. RootA can only be unlocked with its key; the same key cannot unlock RootB. The Data partition is encrypted with a shared key between A and B; the Data partition is accessible by both RootA and RootB. The Boot partition is not encrypted.\nQ: What types of curves are used to sign and verify zi images? Expand for Answer A: The sign/verify process relies on ECDSA-based curves, in particular secp256k1. Public/Private key pairs can be generated in either software or Zymbit HSM hardware. The ZYMKEY uses software keys.\nQ: Is there Bare Metal Recovery? Expand for Answer A: Bare metal recovery is not currently available.\n","categories":"","description":"","excerpt":" Q: What Zymbit products support Bootware 1.1? Expand for Answer A: …","ref":"/bootware/archive/bootware-one-zero-general/troubleshooting/faq/","tags":"","title":"Frequently Asked Questions"},{"body":"This page outlines the steps required to get PCIe ethernet chips using the Intel I225-V controller up and running on the Zymbit Secure Edge Node (SEN). These controllers use the in-tree igc Linux driver, which is not included by default as part of the Raspberry Pi Foundation’s official kernel packages. The process has been tested and validated for the 6.1.93 Raspberry Pi kernel paired with an IOCrest SY-PEX24075 M.2 adapter card, though most any sub-7 watt M.2 card using the I225-V controller should theoretically work (mileage may vary).\nInstallation. There are two options for installation: using prebuilt .deb packages, which target kernel 6.1.93, or building and installing from source.\nOption 1: Install from Prebuilt Debian Packages. This option will install a prebuilt kernel 6.1.93 package, including the necessary igc module, and will work on any existing Debian-based SEN. As part of the installation process, the system’s initramfs (if one is present) will be regenerated, allowing the use of LUKS-encrypted root filesystems to continue working.\nNotice On some newer systems (Debian Bookworm and later), the kernel image and config.txt files may instead be located in the /boot/firmware directory; check the mount point of the first partition on your SD card/eMMC to determine whether this is the case. The prebuilt 6.1.93 kernel package will always install to /boot, so depending on your exact setup, you may have to either remount /dev/mmcblk0p1 at /boot before running dpkg, or else move the installed files from /boot into /boot/firmware after the installation is complete. Download the prebuilt packages, then copy the linux-image-*_arm64.deb, linux-libc-dev_*_arm64.deb, and (optionally) linux-headers-*_arm64.deb files onto the target system.\nThe linux-headers package is required if you plan on doing any out-of-tree kernel module-related development. Otherwise, it is not required for the system to properly run. As root, install the packages using dpkg:\ndpkg -i *.deb Edit /boot/config.txt to boot from the newly installed kernel image. The prebuilt packages will install the kernel at /boot/vmlinuz-6.1.93-v8+. You must either manually copy/rename this file to /boot/kernel8.img, or edit /boot/config.txt to change (or add, if it’s missing) the line kernel=vmlinuz-6.1.93-v8+, otherwise the system will not boot the correct kernel image.\nDepending on which versions of the kernel you are coming from and moving to, you may also need to install an updated devicetree blob. If the kernel was installed from the prebuilt Debian packages, this can be done by copying /usr/lib/linux-image-6.1.93-v8+/broadcom/bcm2711-rpi-cm4.dtb into /boot (or /boot/firmware, depending on your system’s layout).\nOption 2: Build and Install from Source. This option is much more flexible than the alternative and allows working with custom kernels, but requires a suitable Linux kernel build environment. You will need to build the entire kernel in order to obtain the System.map and other files required for depmod, as well as to ensure the igc module version matches that of the core kernel.\nIt is highly recommended that you compile the kernel on a non-Pi workstation. The CM4 is capable of building its own Linux kernel, but doing so will take upwards of 1-2 hours on the Cortex-A72 CPU and require several GiB of disk space. If building on a non-aarch64 host, ensure you have an aarch64 cross toolchain installed on the build machine; you can install one from apt, dnf, or pacman on most x86_64 Linux distributions, or download a prebuilt tarball directly from ARM. Either of the bare-metal or GNU/Linux targets will work. Also, be sure to install your distribution’s required Linux build dependencies; consult your distro’s documentation for specifics.\nObtain RPi Linux sources and checkout the appropriate commit for kernel 6.1.93:\nAs of this writing, the desired commit is at the HEAD of the rpi-6.1.y branch. Adding a --depth 1 argument to the clone command will therefore yield the correct commit HEAD and save significant time, but this will change should more commits be added to this branch in the future.\nIf you wish to clone the entire source tree and history, the gix command will do to so much faster than git (it can be installed with cargo install gitoxide), though note that gix does not support the --branch option.\ngit clone --branch rpi-6.1.y https://github.com/raspberrypi/linux.git git checkout fbd8b3facb36ce888b1cdcf5f45a78475a8208f2 Create a KBuild .config file to target the SEN’s Pi CM4. If building on an aarch64 host with a native toolchain, omit the ARCH and CROSS_COMPILE flags from the below command.\n$TOOLCHAIN_PREFIX should be the prefix of your cross toolchain, such that invoking ${TOOLCHAIN_PREFIX}gcc from the command line will launch the cross GCC.\nThe kernel build system will respect the $ARCH and $CROSS_COMPILE environment variables, if you don’t wish to specify them on the make command line.\nmake ARCH=arm64 CROSS_COMPILE=$TOOLCHAIN_PREFIX bcm2711_defconfig Modify the generated .config file to add support for the igc driver module (CONFIG_IGC).\nAlternatively, the option can be found within the KConfig interactive interface under Device Drivers \u003e Network device support \u003e Ethernet driver support \u003e Intel devices \u003e Intel(R) Ethernet Controller I225-LM/I225-V support. scripts/config --module CONFIG_IGC Build the kernel and modules.\nTo create .deb packages containing the kernel, modules, headers, and libc, you can instead specify the bindeb-pkg target to make. This requires either building on a Debian-based host, or installing the necessary Debian package development tools onto your system. The kernel .deb files themselves will be output into your current parent directory. You can then install them onto the target system by following the above steps for Option 1: Install from Prebuilt Debian Packages.\nIf building directly on the target SEN system, you can invoke make modules_install install after the build is completed to install the kernel \u0026 modules into their appropriate locations.\nIt is also possible to package the kernel into a binary tarball, RPM, or snap. Run make help for more details.\nmake ARCH=arm64 CROSS_COMPILE=$TOOLCHAIN_PREFIX -j$(nproc) Performance Information. The M.2 slot on the SEN Devkit board is a PCIe Gen. 2 x1 bus, which has a bandwidth cap of 4 Gib/s—enough to support the SY-PEX24075 card’s maximum link speed of 2.5Gib/s. Note, however, that it is not quite enough to achieve maximum bandwidth for simultaneous send/receive operations. In such cases, the driver will prioritize Rx bandwidth (as it should), and allocate whatever remains to Tx. Performance metrics from iperf3 are shown below. The SEN was connected via a LAN cable directly to the 2.5G ethernet port on a Linux PC and two iperf3 client-server sessions were established, one for each direction of communication.\nON PC:\n$ iperf3 --udp 5001 --client \u003cSEN IP Address\u003e --bitrate 2.5g --time n --length 65507 ... [ 5] 84674.00-84675.00 sec 270 MBytes 2.27 Gbits/sec 4326 [ 5] 84675.00-84676.00 sec 280 MBytes 2.34 Gbits/sec 4474 [ 5] 84676.00-84677.00 sec 281 MBytes 2.36 Gbits/sec 4505 [ 5] 84677.00-84678.00 sec 280 MBytes 2.35 Gbits/sec 4475 [ 5] 84678.00-84679.00 sec 271 MBytes 2.27 Gbits/sec 4330 [ 5] 84679.00-84680.00 sec 278 MBytes 2.33 Gbits/sec 4455 [ 5] 84680.00-84681.00 sec 280 MBytes 2.35 Gbits/sec 4484 [ 5] 84681.00-84682.00 sec 281 MBytes 2.36 Gbits/sec 4501 [ 5] 84682.00-84683.00 sec 275 MBytes 2.31 Gbits/sec 4399 [ 5] 84683.00-84684.00 sec 270 MBytes 2.27 Gbits/sec 4324 [ 5] 84684.00-84685.00 sec 282 MBytes 2.36 Gbits/sec 4513 [ 5] 84685.00-84686.00 sec 282 MBytes 2.37 Gbits/sec 4514 [ 5] 84686.00-84687.00 sec 271 MBytes 2.27 Gbits/sec 4334 [ 5] 84687.00-84688.00 sec 271 MBytes 2.27 Gbits/sec 4338 [ 5] 84688.00-84689.00 sec 282 MBytes 2.36 Gbits/sec 4507 [ 5] 84689.00-84690.00 sec 282 MBytes 2.37 Gbits/sec 4515 [ 5] 84690.00-84691.00 sec 276 MBytes 2.32 Gbits/sec 4418 ... ON SEN:\n$ iperf3 --udp 5001 --client \u003cPC IP Address\u003e --bitrate 2.5g --time n --length 65507 ... [ 5] 84674.00-84675.00 sec 259 MBytes 2.17 Gbits/sec 4149 [ 5] 84675.00-84676.00 sec 253 MBytes 2.13 Gbits/sec 4056 [ 5] 84676.00-84677.00 sec 233 MBytes 1.95 Gbits/sec 3729 [ 5] 84677.00-84678.00 sec 148 MBytes 1.24 Gbits/sec 2368 [ 5] 84678.00-84679.00 sec 141 MBytes 1.19 Gbits/sec 2264 [ 5] 84679.00-84680.00 sec 229 MBytes 1.92 Gbits/sec 3672 [ 5] 84680.00-84681.00 sec 249 MBytes 2.09 Gbits/sec 3989 [ 5] 84681.00-84682.00 sec 141 MBytes 1.18 Gbits/sec 2250 [ 5] 84682.00-84683.00 sec 163 MBytes 1.37 Gbits/sec 2613 [ 5] 84683.00-84684.00 sec 151 MBytes 1.27 Gbits/sec 2418 [ 5] 84684.00-84685.00 sec 264 MBytes 2.21 Gbits/sec 4226 [ 5] 84685.00-84686.00 sec 204 MBytes 1.71 Gbits/sec 3261 [ 5] 84686.00-84687.00 sec 140 MBytes 1.18 Gbits/sec 2245 [ 5] 84687.00-84688.00 sec 192 MBytes 1.61 Gbits/sec 3067 [ 5] 84688.00-84689.00 sec 265 MBytes 2.22 Gbits/sec 4238 [ 5] 84689.00-84690.00 sec 196 MBytes 1.64 Gbits/sec 3137 [ 5] 84690.00-84691.00 sec 146 MBytes 1.23 Gbits/sec 2341 ... ","categories":"","description":"","excerpt":"This page outlines the steps required to get PCIe ethernet chips using …","ref":"/device-addons/i225-ethernet-card/","tags":"","title":"Driver Installation/Configuration for M.2 Intel I225 Ethernet Controllers on Zymbit Secure Edge Node."},{"body":" Bootware error codes are displayed on the screen (HDMI console is all that is visible until booted) and are logged in /boot/zboot.log. The list below includes all the available error codes.\nzb_config Errors: [ERROR] [0.2.0] [SYSTEM] [0x0802] load_config(): decrypt zb_config.enc Details Description: Failed to decrypt zb_config.enc\nCause: Corrupted zb_config.enc\n[ERROR] [0.2.0] [SYSTEM] [0x0a02] load_config(): load_config(): zbconfig -gen zb_config.enc Details Description: Failed to generate zb_config.enc\nCause: Error writing to /boot/zb_config.enc\n[ERROR] [0.2.0] [SYSTEM] [0x0a01] load_config(): load_config(): key=value Details Description: Unable to parse zb_config.enc\nCause: Corrupted zb_config.enc\nWiFi Errors: [ERROR] [0.2.0] [SYSTEM] [0x0604] start_wifi(): wlan0 wpa_supplicant Details Description: Failed to start wpa supplicant\nCause: Corrupted zb_config.enc\n[ERROR] [0.2.0] [SYSTEM] [0x0603] start_wifi(): wlan0 udhcpc Details Description: Failed to get IP\nCause: Unable to connect to WiFi/Incorrect SSID/Credentials\nTime Errors: [WARNING] [0.2.0] [SYSTEM] [0x0602] set_time(): ntpdate Details Description: Failed to Sync Time\nCause: No network connectivity\nu-boot Environment Errors: [ERROR] [0.2.0] [SYSTEM] [0x0304] set_uboot_variables(): fw_setenv boot_count Details Description: Failed to write boot_count environment variable\nCause: Unable to write to /boot/uboot.env\n[ERROR] [0.2.0] [SYSTEM] [0x0304] set_uboot_variables(): fw_setenv error_code Details Description: Failed to write error_code environment variable\nCause: Unable to write to /boot/uboot.env\n[ERROR] [0.2.0] [SYSTEM] [0x0304] set_uboot_variables(): fw_setenv zb_update Details Description: Failed to write zb_update environment variable\nCause: Unable to write to /boot/uboot.env\n[ERROR] [0.2.0] [SYSTEM] [0x0304] set_uboot_variables(): fw_setenv rollback_count Details Description: Failed to write rollback_count environment variable\nCause: Unable to write to /boot/uboot.env\n[ERROR] [0.2.0] [SYSTEM] [0x0304] set_uboot_variables(): fw_setenv max_boot_attempts Details Description: Failed to write max_boot_attempts environment variable\nCause: Unable to write to /boot/uboot.env\nUser Kernel FitImage Errors: [FATAL] [0.2.0] [GEN_USR_KERNEL] [0x0501] generate_usr_kernel(): File Not Found /boot/kernel8.img Details Description: /boot/kernel8.img not found\n[FATAL] [0.2.0] [GEN_USR_KERNEL] [0x0501] generate_usr_kernel(): File Not Found /boot/initrd.img Details Description: /boot/initrd.img not found\n[FATAL] [0.2.0] [GEN_USR_KERNEL] [0x0701] generate_usr_kernel(): Generate kernel8 FitImage Details Description: Failed to generate kernel8 FitImage\n[FATAL] [0.2.0] [GEN_USR_KERNEL] [0x0802] generate_usr_kernel(): Encrypt $KERNEL FitImage Details Description: Failed to encrypt kernel8 FitImage\n[FATAL] [0.2.0] [GEN_USR_KERNEL] [0x0506] generate_usr_kernel(): mv /boot/kernel8.enc Details Description: Failed to move kernel8.enc to /boot/kernel8.enc\nCause: Unable to write to /boot/kernel8.enc\nUpdate Errors: [FATAL] [0.2.0] [UPDATE] [0x0501] update(): File Not Found /boot/kernel8.img Details Description: /boot/kernel8.img not found\n[FATAL] [0.2.0] [UPDATE] [0x0b01] update(): Failure Details Description: Unexpected ZBoot Update Failure\n[FATAL] [0.2.0] [UPDATE] [0x0701] update(): Generate kernel8 FitImage Details Description: Failed to generate kernel8 FitImage\n[FATAL] [0.2.0] [UPDATE] [0x0802] update(): Encrypt kernel8 FitImage Details Description: Failed to encrypt kernel8 FitImage\n[FATAL] [0.2.0] [UPDATE] [0x0506] update(): mv /boot/kernel8.enc Details Description: Failed to move kernel8.enc to /boot/kernel8.enc\nCause: Unable to write to /boot/kernel8.enc\nRollback Errors: [ERROR] [0.2.0] [ROLLBACK] [0x0c01] rollback(): Max Rollback Attempts Details Description: Maximum rollback attempts exceeded\n[FATAL] [0.2.0] [UPDATE] [0x0501] rollback(): File Not Found File Not Found /boot/kernel8.img Details Description: /boot/kernel8.img not found\n[FATAL] [0.2.0] [UPDATE] [0x0b01] rollback(): Failure Details Description: Unexpected Rollback Failure\n[FATAL] [0.2.0] [UPDATE] [0x0701] rollback(): File Not Found Generate kernel8 FitImage Details Description: Failed to generate kernel8 FitImage\n[FATAL] [0.2.0] [UPDATE] [0x0802] rollback(): File Not Found Encrypt kernel8 FitImage Details Description: Failed to encrypt kernel8 FitImage\n[FATAL] [0.2.0] [UPDATE] [0x0506] rollback(): File Not Found mv /boot/kernel8.enc Details Description: Failed to move kernel8.enc to /boot/kernel8.enc\nCause: Unable to write to /boot/kernel8.enc\nRecovery Errors: [FATAL] [0.2.0] [RECOVERY] [0x0d01] recovery(): Max Recovery Attempts Details Description: Maximum recovery attempts exceeded\n[FATAL] [0.2.0] [RECOVERY] [0x0b01] recovery(): update Failure Details Description: Unexpected Recovery Update Failure\n[FATAL] [0.2.0] [RECOVERY] [0x0d02] recovery(): Failure Details Description: Unexpected Recovery Failure\n[FATAL] [0.2.0] [RECOVERY] [0x0b01] recovery(): update Failure Details Description: Unexpected Recovery Update Failure\n","categories":"","description":"","excerpt":" Bootware error codes are displayed on the screen (HDMI console is all …","ref":"/bootware/archive/bootware-one-zero-general/troubleshooting/error-codes/","tags":"","title":"Bootware Error Codes"},{"body":" Bootware error codes are displayed on the screen (HDMI console is all that is visible until booted) and are logged in /boot/zboot.log. The list below includes all the available error codes.\nzb_config Errors: [ERROR] [0.2.0] [SYSTEM] [0x0802] load_config(): decrypt zb_config.enc Details Description: Failed to decrypt zb_config.enc\nCause: Corrupted zb_config.enc\n[ERROR] [0.2.0] [SYSTEM] [0x0a02] load_config(): load_config(): zbconfig -gen zb_config.enc Details Description: Failed to generate zb_config.enc\nCause: Error writing to /boot/zb_config.enc\n[ERROR] [0.2.0] [SYSTEM] [0x0a01] load_config(): load_config(): key=value Details Description: Unable to parse zb_config.enc\nCause: Corrupted zb_config.enc\nWiFi Errors: [ERROR] [0.2.0] [SYSTEM] [0x0604] start_wifi(): wlan0 wpa_supplicant Details Description: Failed to start wpa supplicant\nCause: Corrupted zb_config.enc\n[ERROR] [0.2.0] [SYSTEM] [0x0603] start_wifi(): wlan0 udhcpc Details Description: Failed to get IP\nCause: Unable to connect to WiFi/Incorrect SSID/Credentials\nTime Errors: [WARNING] [0.2.0] [SYSTEM] [0x0602] set_time(): ntpdate Details Description: Failed to Sync Time\nCause: No network connectivity\nu-boot Environment Errors: [ERROR] [0.2.0] [SYSTEM] [0x0304] set_uboot_variables(): fw_setenv boot_count Details Description: Failed to write boot_count environment variable\nCause: Unable to write to /boot/uboot.env\n[ERROR] [0.2.0] [SYSTEM] [0x0304] set_uboot_variables(): fw_setenv error_code Details Description: Failed to write error_code environment variable\nCause: Unable to write to /boot/uboot.env\n[ERROR] [0.2.0] [SYSTEM] [0x0304] set_uboot_variables(): fw_setenv zb_update Details Description: Failed to write zb_update environment variable\nCause: Unable to write to /boot/uboot.env\n[ERROR] [0.2.0] [SYSTEM] [0x0304] set_uboot_variables(): fw_setenv rollback_count Details Description: Failed to write rollback_count environment variable\nCause: Unable to write to /boot/uboot.env\n[ERROR] [0.2.0] [SYSTEM] [0x0304] set_uboot_variables(): fw_setenv max_boot_attempts Details Description: Failed to write max_boot_attempts environment variable\nCause: Unable to write to /boot/uboot.env\nUser Kernel FIT Image Errors: [FATAL] [0.2.0] [GEN_USR_KERNEL] [0x0501] generate_usr_kernel(): File Not Found /boot/kernel8.img Details Description: /boot/kernel8.img not found\n[FATAL] [0.2.0] [GEN_USR_KERNEL] [0x0501] generate_usr_kernel(): File Not Found /boot/initrd.img Details Description: /boot/initrd.img not found\n[FATAL] [0.2.0] [GEN_USR_KERNEL] [0x0701] generate_usr_kernel(): Generate kernel8 FitImage Details Description: Failed to generate kernel8 FitImage\n[FATAL] [0.2.0] [GEN_USR_KERNEL] [0x0802] generate_usr_kernel(): Encrypt $KERNEL FitImage Details Description: Failed to encrypt kernel8 FitImage (or kernel_2712 or vmlinuz)\n[FATAL] [0.2.0] [GEN_USR_KERNEL] [0x0506] generate_usr_kernel(): mv /boot/kernel8.enc Details Description: Failed to move kernel8.enc to /boot/kernel8.enc (or kernel_2712 or vmlinuz)\nCause: Unable to write to /boot/kernel8.enc\nUpdate Errors: [FATAL] [0.2.0] [UPDATE] [0x0501] update(): File Not Found /boot/kernel8.img (or kernel_2712 or vmlinuz) Details Description: /boot/kernel8.img not found (or kernel_2712 or vmlinuz)\n[FATAL] [0.2.0] [UPDATE] [0x0b01] update(): Failure Details Description: Unexpected ZBoot Update Failure\n[FATAL] [0.2.0] [UPDATE] [0x0701] update(): Generate kernel8 FitImage (or kernel_2712 or vmlinuz) Details Description: Failed to generate kernel8 FitImage (or kernel_2712 or vmlinuz)\n[FATAL] [0.2.0] [UPDATE] [0x0802] update(): Encrypt kernel8 FitImage (or kernel_2712 or vmlinuz) Details Description: Failed to encrypt kernel8 FitImage (or kernel_2712 or vmlinuz)\n[FATAL] [0.2.0] [UPDATE] [0x0506] update(): mv /boot/kernel8.enc (or kernel_2712 or vmlinuz) Details Description: Failed to move kernel8.enc to /boot/kernel8.enc\nCause: Unable to write to /boot/kernel8.enc\nRollback Errors: [ERROR] [0.2.0] [ROLLBACK] [0x0c01] rollback(): Max Rollback Attempts Details Description: Maximum rollback attempts exceeded\n[FATAL] [0.2.0] [UPDATE] [0x0501] rollback(): File Not Found File Not Found /boot/kernel8.img (or kernel_2712 or vmlinuz) Details Description: /boot/kernel8.img not found\n[FATAL] [0.2.0] [UPDATE] [0x0b01] rollback(): Failure Details Description: Unexpected Rollback Failure\n[FATAL] [0.2.0] [UPDATE] [0x0701] rollback(): File Not Found Generate kernel8 FitImage (or kernel_2712 or vmlinuz) Details Description: Failed to generate kernel8 FitImage\n[FATAL] [0.2.0] [UPDATE] [0x0802] rollback(): File Not Found Encrypt kernel8 FitImage (or kernel_2712 or vmlinuz) Details Description: Failed to encrypt kernel8 FitImage\n[FATAL] [0.2.0] [UPDATE] [0x0506] rollback(): File Not Found mv /boot/kernel8.enc (or kernel_2712 or vmlinuz) Details Description: Failed to move kernel8.enc to /boot/kernel8.enc\nCause: Unable to write to /boot/kernel8.enc\nRecovery Errors: [FATAL] [0.2.0] [RECOVERY] [0x0d01] recovery(): Max Recovery Attempts Details Description: Maximum recovery attempts exceeded\n[FATAL] [0.2.0] [RECOVERY] [0x0b01] recovery(): update Failure Details Description: Unexpected Recovery Update Failure\n[FATAL] [0.2.0] [RECOVERY] [0x0d02] recovery(): Failure Details Description: Unexpected Recovery Failure\n[FATAL] [0.2.0] [RECOVERY] [0x0b01] recovery(): update Failure Details Description: Unexpected Recovery Update Failure\n","categories":"","description":"List of available Bootware Error Codes","excerpt":"List of available Bootware Error Codes","ref":"/bootware/troubleshooting/error-codes/","tags":"","title":"Bootware Error Codes"},{"body":"This page outlines the steps required to get PCIe DB9 serial ports up and running on the Zymbit Secure Edge Node (SEN). This device uses Max Linear’s (formerly Exar Corp.) xr17v35x family of chipsets. The process has been tested and validated for the 6.6.31 Raspberry Pi kernel that ships with Debian Bookworm paired with an IOCrest SI-ADA15069 M.2 adapter card.\nBuilding. The IOCrest unit ships with a CD containing working driver code for pre-6.x kernels, located in the EXAR directory on the disc. For convenience, a link to the driver package is also provided here. For kernel 6.0 and later, a patch file is provided below.\nInstall the required build tools. On Debian-based systems: sudo apt install build-essential linux-headers patch Obtain and extract xr17_linux_driver_v2.6.zip.\nEdit the Makefile and change SUBDIRS to M in line 13.\nIf installing on a 6.0 or newer kernel, apply this patch to xr17v35x.c. Follow the steps in the driver package’s readme section 3.2A to unbind the serial ports from the generic driver.\nBuild the module by running make.\nLoad the driver into the kernel:\ninsmod ./xr17v35x.ko The serial ports should now be listed as /dev/ttyXR*.\nInstallation. You may wish to install the driver module so that it is automatically loaded on boot. This section outlines the process required to do so.\nNotice Linux kernel modules are bound to the specific kernel version against which they are built. If the device had previously been working but no longer does after a recent system upgrade, it’s likely that a new kernel was installed and the driver was not recompiled. To remedy this, follow the steps in this guide while running the newly installed kernel. Install xr17v35x.ko into /lib/modules: OPTIONAL: to compress the xr17v35x.ko module, run sudo \u003ccompression-program\u003e /lib/modules/$(uname -r)/kernel/drivers/char/xr17v35x.ko after make install and before running depmod, where \u003ccompression-program\u003e is xz, gzip, etc. cd \u003cpath-to-xr17-lnx2.6.32-and-newer-pak_ver2.6\u003e sudo make install sudo depmod -a Create a file with the following contents called 00-xrserial.rules in /etc/udev/rules.d to ensure device the works across reboots. This will unbind the PCIe device from linux’s generic PCI serial driver and then reload the vendor-specific driver module. If more than one PCIe serial device is present and the below rule doesn’t work, try adding KERNEL==\u003cpath\u003e, to the beginning of the line below, where \u003cpath\u003e is the PCI bus path value used in step 3.2.A of the driver package’s readme. # MaxLinear PCIe dual DB-9 serial port ACTION==\"add\", SUBSYSTEM==\"pci\", ATTR{class}==\"0x070002\", ATTR{vendor}==\"0x13a8\", ATTR{device}==\"0x0352\", ATTR{revision}==\"0x03\", \\ ATTR{driver_override}=\"xrserial\", \\ RUN+=\"/bin/sh -c 'echo $kernel \u003e /sys/$devpath/driver/unbind'\", \\ RUN+=\"/sbin/modprobe -r xr17v35x\", \\ RUN+=\"/sbin/modprobe xr17v35x\" ","categories":"","description":"","excerpt":"This page outlines the steps required to get PCIe DB9 serial ports up …","ref":"/device-addons/xr17v3521-dual-pcie-uart/","tags":"","title":"Driver Installation/Configuration for M.2 Exar Corp. XR17V3521 Dual PCIe UART on Zymbit Secure Edge Node."},{"body":"","categories":"","description":"","excerpt":"","ref":"/reference/product-briefs/","tags":"","title":"Product Briefs"},{"body":"","categories":"","description":"","excerpt":"","ref":"/getting-started/scm/","tags":"","title":"Secure Compute Module - SCM"},{"body":"Overview Blockchain accounts, signatures, and transactions have an additional layer of complexity over traditional cryptographic keys and signatures. Our Wallet SDK aims to abstract away this complexity, enabling you to create and manage multiple blockchain wallets and seamlessly integrate with various blockchains without having to deal with their technical intricacies.\nNOTE: Only available on the HSM6, SCM, and SEN\nArchitecture The Zymbit Wallet SDK is the package which contains our libraries which support Blockchain account creation, management, and use. The SDK consists of modular components which can work independently or together, depending on your use case, to create a seamless interface between Zymbit’s HD hardware wallet and blockchains. More details can be found in the documentation.\n","categories":"","description":"","excerpt":"Overview Blockchain accounts, signatures, and transactions have an …","ref":"/reference/zymbit-wallet-sdk/","tags":"","title":"Zymbit Wallet SDK"},{"body":"","categories":"","description":"","excerpt":"","ref":"/getting-started/scm-dev-kit3/","tags":"","title":"Secure Compute Module - Dev Kit 3"},{"body":"","categories":"","description":"","excerpt":"","ref":"/getting-started/scm-dev-kit2/","tags":"","title":"Secure Compute Module - Dev Kit 2"},{"body":"","categories":"","description":"","excerpt":"","ref":"/getting-started/sen/","tags":"","title":"Secure Edge Node"},{"body":" Updated Release 10/10/2023 (RC-23.01 base software unchanged) Updated the SCM release to support the Rev B release of the SCM hardware.\nSummary of changes:\nPre-loaded OS options Raspberry PI OS Lite 64-bit (Bookworm) - FACTORY CONFIGURED (NO CHANGE) Raspberry PI OS Lite 64-bit (Bullseye) - OPTIONAL, FACTORY CONFIGURED (NO CHANGE) Ubuntu Server 22.04 64-bit (Jammy) - OPTIONAL, FACTORY CONFIGURED (NO CHANGE) Root partition now 50% of available eMMC space (encrypted). Message included on login as a reminder, along with steps to expand the root partition to 100% of space (encrypted) SCM Hardware changes FW 01.02.02release - Supports SCM Rev B. SCM Rev B has different boot timing as compared to Rev A. This has to do with additional checks and with new requirements related to Zymbit bootware(tm). Average boots times are similar, however, some boot times may be longer by approximately 50 seconds. This is normal behavior for SCM Rev B units. SCM Rev. B has one new 40-pin connector and a different connector for tamper detect and battery backer. Please see the ECN for complete details. The new tamper/battery connector improves physical security of the SCM, improves compatibility with generic CM4 boards, and provides additional features. The new 40-pin expansion connector provides access to additional USB ports as well as additional security and integration features in future versions of the SCM. Known Issues Notice Issue Number #159 - Major Affects SCM, Firmware version: 01.02.02release (not in earlier firmware releases)\nOn B1 versions of the SCM with firmware version 01.02.02release, generated key pairs created with gen_key_pair() are removed during reboot.\nYou can determine the version with:\npython3 -c \"import zymkey; print(zymkey.client.get_firmware_version())\"\nDetails and Workaround: gen_key_pair(key_type) creates key pairs for slots 16 and up, but a reboot removes the key slots. Keys generated using the BIP32 wallet with gen_wallet_master_seed()/gen_wallet_child_key() keys are not removed on reboot. The BIP32 wallet keys can be used as a workaround for B1 units.\nFor example,\nInstead of:\nkey_slot = gen_key_pair(\"secp256k1\")\nUse:\nseed = zymkey.client.gen_wallet_master_seed(\"secp256k1\", \"\", \"wallet_name\")\nkey_slot = zymkey.client.gen_wallet_child_key(seed, 0, False)\nFrom this point on you can use the key_slot in the same manner to get_public_key(key_slot) or remove_key(key_slot)\nNotes: The problem does not affect the use of slots 0 through 15. The problem does not affect public keys stored in the Foreign key store. BIP32 wallets are hierarchical key stores, meaning removing the wallet master seed will remove all the keys in that wallet; removing a parent will remove all child slots of the parent. See BIP32 for more information. BIP32 wallets can be recovered if you setup a recovery method using either BIP39 mnemonics, or SLIP39 Shamir’s Secret Sharing of mnemonics. Zymbit supports both methods. Your particular application of keys may lend itself to different key hierarchy strategies - you could put one key in each wallet and create many wallets or put many keys in one wallet. For details on wallets, you can see https://docs.zymbit.com/tutorials/digital-wallet/ If you are creating multiple wallets, each wallet must have a unique name. This only affects SCMs with firmware 01.02.02release. This does not affect the HSM6.\nZymbit IO board: Subject to rebooting during high USB in rush current. See Engineering Note 20230721. Zymbit IO board: The ID EEPROM I2C pins are not connected. To use this feature with the Zymbit IO board, you will need two green wires to pins 27 and 28. Contact Support for more information. Zymbit Host Side Code: libzk 1.1-22 libzymkeyssl 1.0-10 zkapputilslib 1.1-25 zkbootrtc 1.1-15 zkifc 1.2-35 zkpkcs11 1.0-3 zksaapps 1.0-16 zku 1.0.33 Modifications from Standard Raspberry PI OS Lite The SCM ships with a pre-installed version of Raspberry PI OS Lite (bookworm 64bit) with a more secure configuration.\nNotice The pre-installed image is encrypted and cannot be replaced via rpiboot in the field. Please contact support@zymbit.com if you require a different image. The table below summarizes changes made to the standard image.\nDefault As Shipped SSH optionally enabled SSH with password allowed Hostname is raspberrypi Hostname changed to zymbit-dev Default user of pi Default user is zymbit. Password zymbit LED Reference Common LED patterns:\nOnce every 3 seconds\nThis indicates that your SCM is working and running. Three rapid blinks every 3 seconds\nThis indicates the SCM is in Production Mode and is working and running. Constant rapid blinking (waiting for host to connect)\nThis indicates that your SCM is operational but has not bound to the host. If the SCM continues to blink this pattern, it could mean that there is a problem with the host Pi or that the SCM is not seen by the Pi. Rapid blinking then LED off permanently\nThis indicates the SCM is in Production Mode but cannot bind with the CM4. In Production Mode the binding with a particular Pi becomes permanent. Can indicate an improper salt file, sometimes due to a major OS upgrade. The SCM has the following fatal LED structure.\nPreamble: 10 very rapid flashes Off for 1 second Main code: a number of 0.5 second flashes which define the main code Off for 1 second Optional subcode: a number of 0.5 second flashes which define the subcode The fatal LED sequence is repeated 3 times, after which the SCM reboots.\nMain Code Sub Code Description 4 2 Supervised Boot failure: At least one Supervised Boot file failed signature check. 5 None ATECC Serial number mismatch. Usually the result of the keys being erased due to a tamper breach with self-destruct policy. 6 None Digest of keys area of SCM flash have failed. Could be caused by a tamper breach or a hardware failure. Also the result of Battery Voltage Threshold self_destruct action. 6 subcode Tamper detect event in self destruct mode while in developer mode. Subcode represents aggregate of all channels witnessed. 8 None SCM unable to send response back to host. Can be caused by overutilized host CPU which causes heartbeats to not be sent to SCM. 20 1 Temperature below low boundary in self destruct mode in developer mode. 20 2 Temperature above high boundary in self destruct mode in developer mode. 22 9 Supervised Boot failure: True failure in Supervised Boot process. ","categories":"","description":"","excerpt":" Updated Release 10/10/2023 (RC-23.01 base software unchanged) Updated …","ref":"/troubleshooting/scm/","tags":"","title":"SCM FAQ and Troubleshooting"},{"body":"","categories":"","description":"","excerpt":"","ref":"/reference/engineering-notes/","tags":"","title":"Engineering Notes"},{"body":" GPIO Pinout Reference SCM Motherboard D35 GPIO Pinout Note the standard GPIO pinout is accessed on the bottom side of the D35 board.\nKnown Issues - Rev A1 Zymbit IO board: Subject to rebooting during high USB in rush current. See Engineering Note 20230721. Zymbit IO board: The ID EEPROM I2C pins are not connected. To use this feature with the Zymbit IO board, you will need two green wires to pins 27 and 28. Contact Support for more information. ","categories":"","description":"","excerpt":" GPIO Pinout Reference SCM Motherboard D35 GPIO Pinout Note the …","ref":"/troubleshooting/scm-mobo/","tags":"","title":"SCM Motherboard D35 FAQ and Troubleshooting"},{"body":" Bootware® applies updates through zymbit images or *.zi files. These files are created by using the zbcli imager tool to package up a zymbit image for the user. These images can be signed by either hardware keys stored in the HSM or with software key files generated by the ecdsa library. zbcli imager will generate both the hardware keys and the software keys based off of SECP256k1.\nHardware key generation (SCM-based products and HSM6): zbcli imager leverages the BIP32/BIP39 wallet APIs of the SCM for key generation. The wallet is named “bootware” and will generate the signing key pair with the wallet address of “m/0/n” (where n is a random number between 0-100). The wallet address “m/0/n” info will be stored in the zymbit image: header.txt. After the zbcli imager finishes signing the image with the signing key, the tool will say what slot the “m/0/n” key is residing in, as well as prompt the user for saving the BIP39 mnemonic to file. The BIP39 mnemonic is a 24 word sentence that can be used to regenerate the master keypair or “m” of the wallet. So this is one way to re-clone the same hardware generated key between different publishing nodes. To verify the image on the node that needs to apply the update, use zbcli update-config to set the key slot number. zbcli update will use the key slot number to verify with.\nThe best way to transport the key over from the publishing node to the receiving node. Use the Python API:\nOn the publishing node:\n# Save this public_key to a file public_key = zymkey.client.get_public_key(signing_key_slot_number) On the receiving node:\n# Store the public key in the HSM to verify updates with foreign_key_slot = zymkey.client.store_foreign_public_key(\"secp256k1\", public_key) Using zbcli update on receiving node:\nsudo zbcli update --key-slot=foreign_key_slot Software key generation (All products): zbcli imager leverages the python ecdsa library to generate a SECP256K1 key pair as private_key.pem/pub_key.pem. These key files will be saved to the same location as the image that is being created. Both the zbcli imager and zbcli update tools will take in a filepath to these key files when the user specifies software keys for signing/verifying.\nWarning: If using the “LOCAL DEVICE” configuration of zbcli update. Do not use a file path that points at a pub_key.pem on the local device. zbcli update will remount the local device on /etc/zymbit/zboot/mnt so the filepath will change.\nUsing zbcli update on receiving node:\nsudo zbcli update --key-file=/home/zymbit/pub_key.pem See also: zbcli imager\nzbcli update\n","categories":"","description":"Overview of Hardware (SCM and HSM6) and Software sign and verify","excerpt":"Overview of Hardware (SCM and HSM6) and Software sign and verify","ref":"/bootware/features/signing/","tags":"","title":"Bootware\u003csup\u003e\u0026reg;\u003c/sup\u003e Signing and Verifying"},{"body":" Troubleshooting Troubleshooting Checklist Before contacting Zymbit with troubleshooting related questions, please read through the following troubleshooting checklist.\nPower supply. Most of the problems we see are from a poor power source. Start with a good power supply from the PI foundation or Canakit, not a phone charger. The recommended power for the PI4 is 5V and 3 amps. For a PI5, the recommended power supply should provide 5V, 5 amps. I2C enabled. Double check that you have enabled the I2C bus. An easy way to check is “ls -l /dev/i2c-1”. If /dev/i2c-1 exists, the I2C bus is enabled. apt update and upgrade. Be sure that your software is up to date. Installation. The curl script will reboot your system once completed. After the reboot, the blue LED on your Zymbit device should blink once every 3 seconds. You must get to this step before proceeding to encryption, etc. If your issue is not related to any of the above list, read through the FAQ below to see if your issue is answered. If you still do not see a solution to your problem, reach out on our Community Forum. Thank you!\nQ: Why does the LED continue to blink rapidly? It never blinks with the described pattern of once (in Development mode) or three times (in Production mode) every three seconds. Expand for Answer A: Check the following:\nCheck that the Raspberry Pi power is sufficient. The red LED on most Raspberry Pi models indicates if the Pi is being powered adequately. If it is not lit at all or flashes intermittently, try a different power supply or a different USB cable.\nMake sure that you have enabled i2c support using raspi-config BEFORE your install the software. Also, when you enable i2c communications be sure to follow the enable-disable-enable sequence.\nIf i2c support has been enabled correctly and the Zymkey LED is still rapidly blinking, check proper physical installation of the Zymkey as detailed in this “Getting Started” guide.\nZymkey uses GPIO header pins 3 and 5 for i2c communications and pin 7 as an interrupt signal to the Pi. Pin 7 should preferably be dedicated exclusively to Zymkey. Other devices may share the i2c bus with Zymkey, but there may still be address conflicts. By default, Zymkey uses slave address 0x30. If the address conflict cannot be resolved on the other i2c devices, there is a way of changing the i2c address through an API call. Using this application, the Zymkey address can be changed anywhere in the ranges of 0x30-0x37 or 0x60-0x67.\nExpand for API information to change i2c address Python: set_i2c_address\nC: int zkSetI2CAddr ( zkCTX ctx, int addr)\nSee API Documentation\nOftentimes the 1-Wire interface relies on pin 7 (GPIO 4) for communication. If the 1-Wire interface is enabled, try disabling through raspi-config. If that resolves the problem take steps to either move the Zymkey interrupt signal from GPIO 4 or the 1-Wire interface from GPIO 4.\nif the directory at /var/lib/zymbit or any of the files and/or subdirectories are corrupted or deleted, the Zymkey will fail to work. IMPORTANT: if this happens when the Zymkey is locked (i.e. Production Mode), the Zymkey can never be used again.\nQ: The LED blinks rapidly when booting, but eventually turns off. It doesn’t blink once or three times every 3 seconds as described. Expand for Answer A: This issue could be caused by the same issues described in the first question (Why does the LED continue to blink rapidly?). Additionally, this can be caused if a locked (Production Mode) Zymkey is moved to another Pi.\nQ: What do the different LED blinking patterns mean? Expand for Answer 1 second very rapid flash, 1 second off, 8 slow blinks This indicates interrupted communications. 1 second very rapid flash, 1 second off, 5 slow blinks This indicates a failure to communicate with ATECC. The most likely cause is the Zymkey is in Production Mode, tamper detect was set to self-destruct, and a tamper detect event caused the Zymkey to self-destruct. If tamper detect is not armed, this indicates a hardware problem. Constant rapid blinking (waiting for host to connect) This indicates that you Zymkey is operational but has not bound to the host. If the Zymkey continues to blink this pattern, it could mean that there is a problem with the host Pi or that the i2c is not configured or that the i2c and wake pins are not making contact. Once every 3 seconds This indicates that your Zymkey is working and running. Three rapid blinks every 3 seconds This indicates the Zymkey is in Production Mode and is working and running. Rapid blinking then LED off permanently This indicates the Zymkey is in Production Mode but cannot bind with the RPi / SD card pair. In Production Mode the binding with a particular Pi and SD card becomes permanent. Most likely cause for this is that the Zymkey, the SD card, or the PI has been swapped out. Q: How do I set an alternative I2C address? Expand for Answer A: You can change the I2C address through our standard APIs:\nC: int zkSetI2CAddr ( zkCTX ctx, int addr) Python: set_i2c_address The I2C communication between the Zymkey and the Host is encrypted, but will not interfere with other devices on the same bus (assuming there is no address conflict).\nSee API Documentation\nQ: Why does my Zymkey fail to restart after cycling power? Expand for Answer A: Zymkey monitors the quality of 5V power coming into the host computer. If the voltage drops below a specified limit, even momentarily, then Zymkey will disable all security services to the host. This is a security feature to prevent power cycle and brown-own attacks. If you are powering a display, modem, or other power-hungry device from your Pi, then check the capacity and quality of your power supply. Learn more \u003e\nQ: Why is my Zymkey “invisible” to the i2c-tools suite? Expand for Answer A: Some people have become accustomed to using i2c-detect to do a first level check for correct installation and baseline functionality of i2c devices. However, these tools only really work if the i2c device communicates via a protocol that sits on top of i2c called SMBus or SMB (System Management Bus). Instead, Zymkey communicates to the host at a much more fundamental level, in part because the Zymkey protocol traffic is encrypted.\nYou can tell if you successfully installed it by observing the blue LED. If it is flashing once every 3 seconds, then binding completed. You can also use the systemctl command. It should say “active (running)”:\nsystemctl status zkifc\nQ: If the install fails, can I run it more than once? Expand for Answer A: Yes, you should have no problem running it multiple times if it were to fail.\nEncrypting Root File System Summary of steps Start with a blank USB device. USB storage should be twice the size of the SD card. The process for encrypting the SD card stops zkifc. The blue LED will flash rapidly during the encryption process. It will return to blinking once every 3 seconds when complete. The process will automatically do two reboots. Be patient. If the encryption process does not complete, it’s best to start fresh and try again. Q: How can I check if the system matches the default parameters? Expand for Answer A: lsblk will show you the partitions. Look for the name of your / partition (default is mmcblk0p2) and the USB device (default is sda). Example output:\nNAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT mmcblk0 179:0 0 14.9G 0 disk |-mmcblk0p1 179:1 0 256M 0 part /boot `-mmcblk0p2 179:2 0 14.6G 0 part / sda 8:0 0 32.0G 0 disk |_sda1 8:1 0 32.0G 0 part Q: How can I monitor the status after phase 1 reboot? Expand for Answer A: Once you get to the second phase and login, you can monitor progress with\njournalctl -fu cfg_SD_crfs\nThat will show you progress of the second half of the encryption process.\nQ: Can I re-run encryption with the same USB stick? Expand for Answer A: The script is designed to re-use information on the USB stick to encrypt a “golden” image in production on more than one device. If the file original_zk_root.tgz exists on the USB stick, it will use that file and skip the step of creating a whole new tarball of the rootfs. If you truly want to start over, start by reformatting/erasing your USB stick.\nQ: If my PI automounts the USB device, will that interfere with the process? Expand for Answer A: The script attempts to unmount the external device, but in some cricumstances the device may stay mounted and the process will fail. You will get a message either on your screen or in journalctl -fu cfg_SD_crfs during the second phase indicating the drive was already mounted. Unmount the drive and try again.\n# Check /dev/sda* mount points for devices mounted to /media/* lsblk # if mounted, unmount sudo umount /media* # re-run service sudo systemctl restart cfg_SD_crfs # monitor progress journalctl -fu cfg_SD_crfs Q: How can I confirm my file system is encrypted and protected? Expand for Answer A: Since zkifc is stopped during the process, the blue LED will flash rapidly until the whole process completes. Once both of the automautic reboots are completed, the blue LED will return to flashing once every 3 seconds.\nlsblk will show you that you now have a “cryptrfs” partition under your mmcblk0p2 (default)\ndf -h will also show “/dev/mapper/cryptrfs” for the “/” file system.\nIf your system reboots twice, the LED returns to flashing once every 3 seconds, and lsblk displays a “cryptrfs” partition, you can be confident your system is encrypted and protected.\nFor more help, see Zymbit’s Community Forum. Features Q: What curves are supported for Zymbit products? Expand for Answer Zymkey and HSM4: NIST P-256 and secp256r1\nHSM6: NIST P-256, secp256r1, secp256k1, X25519, ED25519\nQ: How do I use HSM6’s store_foreign_public_key function to store a Zymkey or HSM4 public key on HSM6? Expand for Answer A: The easiest way is to save the HSM4 key directly to a binary file, copy that file to the HSM6 and read in the binary file.\nHSM4 side:\n#!/usr/bin/python3 import zymkey # Get the public key from slot 0 and save it in a file pub_key_file = '/tmp/pub_key_slot0' slot = 0 key = zymkey.client.get_public_key(slot) with open(pub_key_file, \"wb\") as f: f.write(key) copy /tmp/pub_key_slot0 over to the HSM6 PI\nHSM6 side:\n#!/usr/bin/python3 import zymkey key_file = \"/tmp/pub_key_slot0\" key = open(key_file, \"rb\").read() # Store the key in the foreign key store foreign_slot = zymkey.client.store_foreign_public_key('secp256r1', key) Q: How can I reset the clock to the current timestamp? Expand for Answer A: The clock will sync to the current timestamp once the Pi has achieved NTP sync. This requires you to have access to the Internet.\nQ: How do I access the devices (RTC, accelerometer, crypto) on Zymkey? Expand for Answer A: For Zymkey and HSMs, kernel drivers and libraries for all of the devices are included in the Zymkey software package via the APIs.\nQ: My GPG Key expired and I cannot access the Zymkey Repository. How do I update the Key? Expand for Answer A: You can update your existing key with the following command:\ncurl -L https://zk-sw-repo.s3.amazonaws.com/apt-zymkey-pubkey.gpg | sudo gpg --dearmor --yes -o /usr/share/keyrings/zymbit.gpg Q: Can the Zymkey detect if the SD card has been removed? Expand for Answer A: No, but perimeter detect can be configured to prevent access to the SD card. When a tamper event is detected, the Zymkey will, when properly configured via the API, destroy all critical key material and the root fs will fail to be decrypted upon boot.\nBattery \u0026 Power Questions Q: Should I use an external battery on my Zymkey or HSM? Expand for Answer A: The following table compares Zymkey and HSM operational modes while connected to Main Power, Battery Power, and No Power.\nThe battery is required to maintain the Real Time Clock and the perimeter detect circuits when the host power is removed. Without the battery, these two functions will not be active when the host power is removed.\nQ: What happens when the battery dies? How can I change the battery when it dies, without self-destructing my device? Expand for Answer A: If the battery dies and the host is not connected to power, some features will go out, such as Perimeter Detect and Real Time Clock. See the table below for more information.\nWith Zymkey and HSM4, if tamper detect is enabled and the battery dies or is removed, the device will self-destruct. This is an intentional security feature. If tamper detect is NOT enabled, you should connect the host device to power to change the battery.\nHSM6 has a battery monitoring feature to help the user prevent the battery from dying. If the battery dies, HSM6 users have the ability to choose whether the device should self-destruct or hold in reset mode until the battery is changed.\nKernel \u0026 Kernel Boot Questions Q: Can you tell the kernel not to run a shell? Expand for Answer A: Someone could easily replace the kernel and, while it is possible to configure initramfs to not permit the busybox shell to, that can be sidestepped as well. Even if you hack your own changes to the kernel to ignore the init option, someone could replace your kernel. Also, kernel updates would have to be done manually and the updates from the apt repo would have to be blacklisted.\nQ: Can you tell the kernel to ignore cmdline.txt? Expand for Answer A: There are many reasons why this is infeasible, but the main one is that, since the GPU initially functions as a bootloader processor during boot and since Broadcom has not made the GPU compiler publicly available as well as the source code for the bootloader, one cannot simply compile their own code that would ignore cmdline.txt.\nQ: Is it possible to encrypt the boot partition? Expand for Answer A: No because the GPU bootloader does not have encryption features implemented and, even in lieu of that, it does not know how to communicate with Zymkey. The best solution, then, would be to implement an independent secure boot procedure. As mentioned above, we are currently working on adding this feature in a future product.\nProduction (“self-destruct”) Mode Questions Q: When using the perimeter-detect feature, does the “self-destruct” mode work (destroy all of its key material) even when the Lock Tab hasn’t been cut? Expand for Answer A: Self-destruct mode works only after the Lock Tab has been cut.\nQ: Is there a way to turn off “self-destruct” mode? Expand for Answer A: No, once turned on, “self-destruct” mode is permanent.\nQ: If my Zymkey does “self-destruct,” can I create new keys and reuse the hardware? Expand for Answer The SBC and SD card hardware will be reusable. Because the SD card contents are encrypted and the decryption key was destroyed, the data is lost. The Zymkey will not be reusable because the key slots will be destroyed. Q: If I cut the Lock-Tab on a Zymkey, can I move that Zymkey to another Pi or change the SD card? Expand for Answer A: No. Cutting the Lock-Tab permanently binds that instance of Zymkey to the specific instances of host computer and SD card. This is a security feature to prevent credentials being moved from one host to another. DO NOT cut the Lock-Tab if you are still in development and expect to change the host or SD cards.\nQ: Will Zymkey still self-destruct, even when my SBC is powered off? Expand for Answer A: Yes, because Zymkey is battery powered. As long as the battery is sufficiently charged, it will still self-destruct.\nOther Q: Where can I learn about and/or pre-order future products? Expand for Answer A: Sign up for our new product email updates at the bottom of Zymbit’s homepage.\nQ: Which SBCs are compatible with Zymkey? Expand for Answer Electrically, the Zymkey-I2C will interface to any single board computer using I2C. Check compatibility with your particular Linux distribution. Raspberry Pi 3, 3B+, 4, Zero RPi Compute Module 3, 4 Q: Does Zymkey work with Arduino? Expand for Answer A: We have no plans to release an Arduino shield version. While we love Arduinos and use them all the time, they generally don’t have enough resources to handle cryptographic operations at this level.\nQ: Does Zymkey work with BeagleBone? Expand for Answer A: Zymbit does not officially support the BeagleBoard platform at this time.\nQ: Which operating systems does Zymkey support? Expand for Answer Q: How much power does Zymkey consume? Expand for Answer Zymkey-RPi (3.3V): idle approx. 1mA; max active \u003c 25mA with LED off, \u003c 35mA with LED on. Zymkey-USB (5V): idle approx. 1.5mA; max active \u003c 40mA with LEDs off, \u003c 60mA with LEDs on. See Power Quality for more information.\n","categories":"","description":"","excerpt":" Troubleshooting Troubleshooting Checklist Before contacting Zymbit …","ref":"/troubleshooting/zymkey4/","tags":"","title":"ZYMKEY4 FAQ \u0026 Troubleshooting"},{"body":" zbcli imager Description Requires superuser privilege.\nBootware requires images in a particular format. Use zbcli imager to convert images into Zymbit Image (zi) format. The script will prompt you for all required information. The Flags in the Usage below can be used to provide that information from the command line and skip prompts.\nUsage zbcli imager [OPTIONS] Options: --boot-tarball \u003cBOOT_TARBALL\u003e Path of boot tarball --root-tarball \u003cROOT_TARBALL\u003e Path of root tarball --binary-image \u003cBINARY_IMAGE\u003e Path of binary image to convert to Zymbit image --image-name \u003cIMAGE_NAME\u003e Zymbit image name --image-version \u003cIMAGE_VERSION\u003e Zymbit image version --full-image Generate image of update type: FULL --overlay-image Generate image of update type: OVERLAY --new-key Generate a new key for signing/verifying --save-wallet-info If a new HSM wallet slot was generated, saves the mnemonic and public key -f, --key-file \u003cKEY_FILE\u003e Path of HSM key slot to sign the image with -o, --output-directory \u003cOUTPUT_DIRECTORY\u003e Output directory for new .zi images -h, --help Print help Examples Example: create a zi image from your currently running root file system This is an example of how you can create a snapshot image of your running system. You can perform your development and configuration on one system, and once you are satisfied your system is working correctly, create an image to use for backup purposes and for propogation to other units.\nFirst, mount a USB stick or some other external device to store the image.\nsudo mount /dev/sda1 /mnt Run the imager. Options can be provided on the command line to run without prompting.\nsudo zbcli imager The script will prompt for information. We will use the mount point of our USB stick, /mnt. Provide the mount point, a name for your image (without a zi extension, it will be added automatically), and choose Full image of live system.\nValidated bootware installation --------- Pi Module: Raspberry Pi 4 Operating System: Rpi-Bookworm Zymbit module: Zymkey Kernel: kernel8.img --------- Cleaned '/etc/zymbit/zboot/update_artifacts/tmp' ✔ Enter output directory · /mnt ✔ Enter image name · myFullImage ? Select image type › ❯ Full image of live system Overlay image from files added with zb-manifest The script will ask for an optional image version. This is entirely for your use. It is not used by Bootware.\nNext, the script will ask for a private key with which to sign the image. If you are using an SCM or an HSM6, hardware signing by a key from the SCM or HSM is available. Software signing is also available for all products. You can choose to create a new key, or use an existing key. Pre-existing software keys will require a key file in PEM format. Pre-existing hardware keys will require providing information as to which slot on the SCM or HSM6 contains the key. Below, we selected to use and create a new software key.\nThe image creation now has all required information and begins.\n✔ Enter output directory · /mnt ✔ Enter image name · myFullImage ✔ Select image type · Full image of live system ✔ (Optional) enter image version · ✔ Select key · Create new software key Created signing key Created '/etc/zymbit/zboot/update_artifacts/file_manifest' Created '/etc/zymbit/zboot/update_artifacts/file_deletions' Verified path unmounted '/etc/zymbit/zboot/mnt' Cleaned '/etc/zymbit/zboot/mnt' Verified disk size (required: 2.57 GiB, free: 11.01 GiB) Copied file (/boot/firmware/zboot_bkup/kernel8.img.A) to (/boot/firmware/kernel8.img) Created initramfs Created snapshot of boot (/etc/zymbit/zboot/update_artifacts/tmp/.tmpQxuGnU/myFullImage_boot.tar) Running [=======\u003e ] 2/11 (00:16:36): taking snapshot of root The image creation time is dependent on the size of the boot and root filesystems. When completed, /mnt will contain your zi image, and, if you chose to create a new software key, a private key file and a public key file. You can now distribute the zi image file and the public key for verification to load the zi image file on additional units.\nExample: create a zi image from a binary disk image You can also make a zi image directly from a previously created disk image file, created with dd or some other imaging utility. This may be a preferred method if tied into a CI/CD procedure used to generate complete image files. This process assumes your image contains two partitions corresponding to a boot and root file system. zbcli imager will assume the boot partition is partition 1 and the root partition is partition 2.\nYou will need the path to the image file.\nsudo zbcli imager --binary-image /home/zymbit/my.img The imager will prompt for information:\nValidated bootware installation --------- Pi Module: Raspberry Pi 5 Operating System: Rpi-Bookworm Zymbit module: Zymkey Kernel: kernel_2712.img --------- Cleaned '/etc/zymbit/zboot/update_artifacts/tmp' ✔ Enter output directory · /home/zymbit ✔ Enter image name · myImage ✔ (Optional) enter image version · ✔ Select key · Create new software key Created signing key Verified path unmounted '/etc/zymbit/zboot/mnt' Cleaned '/etc/zymbit/zboot/mnt' Verified disk size (required: 5.94 GiB, free: 22.76 GiB) Moved (/boot/firmware/zbootrd) =\u003e (/etc/zymbit/zboot/mnt/zbootrd) Unmounted '/etc/zymbit/zboot/mnt' Running [ ] 0/8 (00:00:41): Upon completion, you will have a zi image based on your original image file in your specified output directory.\nExample: create a zi image from boot \u0026 root tarballs A zi image can be created by providing two tarballs - one of your boot filesystem and one of your root filesystem. You will need to provide the names and paths to your tarballs. Run the imager:\nsudo zbcli imager --boot-tarball ./boot.tar --root-tarball ./root.tar The imager will prompt for information:\nValidated bootware installation --------- Pi Module: Raspberry Pi 5 Operating System: Rpi-Bookworm Zymbit module: Zymkey Kernel: kernel_2712.img --------- Cleaned '/etc/zymbit/zboot/update_artifacts/tmp' ✔ Enter output directory · /home/zymbit ✔ Enter image name · myImage ✔ (Optional) enter image version · ✔ Select key · Create new software key Created signing key Verified path unmounted '/etc/zymbit/zboot/mnt' Cleaned '/etc/zymbit/zboot/mnt' Verified disk size (required: 3.89 GiB, free: 24.81 GiB) Copied file (./boot.tar) to (/etc/zymbit/zboot/update_artifacts/tmp/.tmpHLetYc/myImage_boot.tar) Copied file (./root.tar) to (/etc/zymbit/zboot/update_artifacts/tmp/.tmpHLetYc/myImage_rfs.tar) Verified boot tarball (/etc/zymbit/zboot/update_artifacts/tmp/.tmpHLetYc/myImage_boot.tar) Verified zymbit and zboot tool installation Created staging directory (/etc/zymbit/zboot/update_artifacts/tmp/.tmpsQODep) Created '/etc/zymbit/zboot/update_artifacts/tmp/.tmpsQODep/header.txt' Running [===============\u003e ] 3/8 (00:00:44): creating update artifacts tarball zbcli imager requires a private key. It can generate one for you if you do not have one. The key can either be software-based or Zymbit HSM-based. See Signing/Verifying Images for more information.\nAll necessary parameters for each type of image creation can be provided on the command line to circumvent the need for interactive input.\nOutput zbcli imager outputs the private key and public key if using software keys, along with the zi image, into the specified output directory.\n","categories":"","description":"Generates signed zymbit images (zi)","excerpt":"Generates signed zymbit images (zi)","ref":"/bootware/zbcli/imager/","tags":"","title":"zbcli imager"},{"body":" Quickstart - Download and Install Bootware Register for Bootware Technical Updates In this Getting Started guide we describe how to bring up a common use case for Bootware - A/B partitioning for fallback and recovery.\nThe default SCM/SEN as shipped has Zymbit software pre-installed. For setups using the ZYMKEY4 or other Zymbit HSMs, the installation is up to the user. The Zymbit product should be up and running with the blue LED flashing once every three seconds before installing Bootware. We recommend partitioning your /boot partition with a size of 512MB (default for Bookworm). There is no need to setup encryption of your root filesystem as Bootware will do this for you.\nAn HDMI console is highly recommended for setting up your unit with Bootware. The process of repartitioning and loading takes time and the console is handy for monitoring progress.\nBootware 1.2 includes a new, consolidated user interface. The process of installation and configuration has changed since 1.1.\nDetails of the commands in this Quickstart are linked in-line. See the Features section for more information on how to use Bootware.\nOverview of steps to get up and running You must have the Zymbit SCM/HSM and libraries successfully installed before installing Bootware. The blue LED should blink once every three seconds.\nDownload the Bootware management tool, zbcli. Run zbcli install to install Bootware. Run zbcli imager to create and sign a Zymbit image file (zi image) of your current root file system as a backup. Run zbcli update-config to configure Partitions and Recovery strategy. For this Quickstart, we will setup A/B partitions. Run zbcli update to load a known-good example zi image into the Backup (B) partition; set B to the Active partition. Run zbcli rollback-swap to force a Rollback to your original partition to verify your A/B setup is working. 1. Download Bootware A bootstrap utility to detect and load the correct build of Bootware can be downloaded with curl:\ncurl -sSf https://raw.githubusercontent.com/zymbit-applications/zb-bin/main/install.sh | sudo bash The install will identify your Pi and OS and then prompt you if you’d like to include hardware signing. The SCM and HSM6 support hardware signing. All Zymbit products support software signing. For the purpose of this tutorial, we will use software signing. Use the arrow keys to move the selection to \u003e No.\nzb-install.sh: bootstrapping the zbcli installer --------- Pi Module: Raspberry Pi 4/Compute Module 4 Operating System: Rpi-Bookworm Zymbit module: Secure Compute Module Kernel: kernel8.img --------- ? 'zbcli' comes with software signing by default. Include hardware signing? › Yes ❯ No Next, you will be asked to select a version of the zbcli from a list of recent versions to install. In most cases, you will want to select the latest version. Use the up and down arrows to select the version. You can use Ctrl-C to exit at any time.\n? Select version › zbcli-1.2.0-rc.25 zbcli-1.2.0-rc.24 zbcli-1.2.0-rc.23 2. Run zbcli install Install Bootware. Answer yes when prompted to complete the installation.\nsudo zbcli install After installing the Bootware tools and artifacts, you will need to reboot into zboot. You will be prompted for confirmation to reboot.\n? Bootware installation will require 62.59 MiB in `/boot/firmware` and will modify config.txt and rc.local. The system will be configured to boot from U-Boot. No system data will be lost. Found kernel '/boot/firmware/kernel8.img' Created '/etc/zymbit/zboot/mnt' Created '/etc/zymbit/zboot/scripts' Created '/etc/zymbit/zboot/zboot_backup' Created '/boot/firmware/zboot_bkup' Installed 'u-boot-tools' Created '/etc/fw_env.config' Created '/usr/bin/zb_get_root_dev.sh' Created '/usr/bin/zbconfig' Found OpenSSL 3 Created '/boot/firmware/zb_config.enc' Modified zbconfig 'kernel_filename' Installed zboot Modified '/etc/rc.local' Created '/lib/cryptsetup/scripts/zk_get_shared_key' Modified '/boot/firmware/config.txt' Created '/etc/update-motd.d/01-zymbit-fallback-message' Modified /etc/update-motd.d/01-zymbit-fallback-message ? A reboot into zboot is required. Reboot now? (y/n) › yes Reboot to complete the installation process and to boot through zboot. Once completed, all necessary files required for loading new images via Bootware will be installed.\n3. Run zbcli imager to create a Bootware-ready Zymbit Image backup (zi image) Bootware requires images in a secure, signed format for loading with zboot. We refer to these images as “zi images.” An image conversion tool, zbcli imager, creates the zi image. zbcli imager can take a snapshot of your running system or read from tarballs of your bootfs and rootfs partitions. Images can also be partial file additions and deletions called Overlay images.\nIf you are Developing on a CM4 directly and need to transition to an SCM, See Developing on the CM4 for instructions on how to create an image from your CM4 to load onto the SCM.\nCreate a zi image backup from your current running root file system Use zbcli imager to create a zi image backup of your current system. Once created, the zi image can be propagated to other disk partitions securely. A private/public key pair will be used for signing the zi image at time of creation and verifying during the update process. Key pairs can either be created in software or using the Zymbit HSM hardware. For this Quickstart, we will use software keys. Details on signing and verifying can be found here.\nIn this guide, we will output the image directly to a USB stick. Mount the USB stick for access,\nsudo mount /dev/sda1 /mnt Start the imager module of zbcli. We will run interactively. You can also run non-interactively by supplying all necessary parameters on the command line. See zbcli imager for details.\nAll necessary information will be prompted for starting with the output directory and the name of the image file. The output directory will be excluded from the image. A .zi extension will be added to the image name provided.\nsudo zbcli imager Validated bootware installation --------- Pi Module Raspberry Pi 4 Operating System Rpi-Bookworm Zymbit module Secure Compute Module Kernel kernel8.img --------- Cleaned '/etc/zymbit/zboot/update_artifacts/tmp' ✔ Enter output directory · /mnt ✔ Enter image name · my_image Next, you will be prompted for what type of image to make: A full image of the live system or an Overlay image from files added with zbcli manifest. An Overlay image can be used to add, replace, or delete a select group of files for updates, patches, etc. For this example, we will create a complete image from the running system. Select the Full Image option.\n? Select image type › ❯ Full image of live system Overlay image from files added with zbcli manifest You can optionally provide an image version. This is for your use in helping to identify the image later. It is not used in the process.\nNext, you will be prompted for signing keys. Keys can be Software or Hardware based and are used for signing and verification of images. Software keys are supported on all Zymbit products. Hardware keys are supported with Secure Compute Module (SCM) or HSM6 products. Had we chosen earlier to include hardware key support, we would be asked to choose either hardware or software key support. We chose earlier to not include hardware key support. You can use an existing key or instruct the imager to create new ones for you. For this Quickstart, we will generate a new Software key. Select Create new software key\n? Select key slot › ❯ Create new software key Use pre-existing software key The imager will now build your zi image. Progress will be shown on the screen.\nValidated bootware installation --------- Pi Module Raspberry Pi 4 Operating System Rpi-Bookworm Zymbit module Secure Compute Module Kernel kernel8.img --------- Cleaned '/etc/zymbit/zboot/update_artifacts/tmp' ✔ Enter output directory · /mnt ✔ Enter image name · my_image ✔ Select image type · Full image of live system ✔ (Optional) enter image version · ✔ Select key slot · Create new software key slot Created signing key Verified path unmounted '/etc/zymbit/zboot/mnt' Cleaned '/etc/zymbit/zboot/mnt' Verified disk size (required: 3.97 GiB, free: 8.31 GiB) Created initramfs Running [====\u003e ] 1/10 (00:04:47): taking snapshot of boot The imager may take some time, depending on the size of your file system. Progress will be reported on the screen. Once completed, the zi image and private/public key will be saved to your specified output directory (/mnt). Keep your private key private. The zi image can be used from the local storage device or a remote server accessible via HTTPS. The public key file will be needed to load the zi image.\nWhen complete, there will be three files in your output folder: the public key, the private key, and the zi image.\n... Created signing key Created '/etc/zymbit/zboot/update_artifacts/file_manifest' Created '/etc/zymbit/zboot/update_artifacts/file_deletions' Verified path unmounted '/etc/zymbit/zboot/mnt' Cleaned '/etc/zymbit/zboot/mnt' Deleted '/etc/crypttab' Verified disk size (required: 2.54 GiB, free: 10.05 GiB) Created initramfs Created snapshot of boot (/etc/zymbit/zboot/update_artifacts/tmp/.tmpEyFuyt/my_image_boot.tar) Created snapshot of root (/etc/zymbit/zboot/update_artifacts/tmp/.tmpEyFuyt/my_image_rfs.tar) Verified boot tarball (/etc/zymbit/zboot/update_artifacts/tmp/.tmpEyFuyt/my_image_boot.tar) Verified zymbit and zboot tool installation Created staging directory (/etc/zymbit/zboot/update_artifacts/tmp/.tmpmwFylk) Created '/etc/zymbit/zboot/update_artifacts/tmp/.tmpmwFylk/header.txt' Created tarball (/etc/zymbit/zboot/update_artifacts/tmp/.tmpmwFylk/update_artifact.tar) Created header signature Created update artifact signature Created file manifest signature Created file deletions signature Created '/etc/zymbit/zboot/update_artifacts/tmp/.tmpmwFylk/signatures' Created signatures (/etc/zymbit/zboot/update_artifacts/tmp/.tmpmwFylk/signatures) Copied file (/etc/zymbit/zboot/update_artifacts/file_manifest) to (/etc/zymbit/zboot/update_artifacts/tmp/.tmpmwFylk/file_manifest) Copied file (/etc/zymbit/zboot/update_artifacts/file_deletions) to (/etc/zymbit/zboot/update_artifacts/tmp/.tmpmwFylk/file_deletions) Created tarball (/mnt/my_image.zi) Created '/mnt/my_image_private_key.pem' Saved private key '/mnt/my_image_private_key.pem' Created '/mnt/my_image_pub_key.pem' Saved public key '/mnt/my_image_pub_key.pem' Saved image '/mnt/my_image.zi' (2.54 GiB) Finished in 894.5s $ ls -l /mnt total 1134224 -rwxr-xr-x 1 root root 242 Sep 8 11:55 my_image_private_key.pem -rwxr-xr-x 1 root root 178 Sep 8 11:55 my_image_pub_key.pem -rwxr-xr-x 1 root root 1161410560 Sep 8 11:55 my_image.zi Additional examples of zbcli imager usage can be found here: zbcli imager usage\n4. Run zbcli update-config to configure the Partitioning and Image loading Now we will use the zi image and public key we just created to configure an A/B partition and load the image into the BACKUP (B) partition.\nFirst, copy the public key file created earlier by the imager from /dev/sda1 to a location on your local filesystem.\ncp /mnt/my_image_pub_key.pem . Use the Bootware zbcli update-config to Configure your System Bootware includes a tool to help configure your system called zbcli update-config. zbcli update-config is meant to setup your device environment to load a zi image from a configured endpoint, as well as choose an update policy for how to apply zi images. More information on zbcli update-config can be found here. Navigate through the menus with up and down arrows. Use ENTER to make a choice. Each configuration option will display the available options with explanations.\nWe are going to set a configuration with A/B partitioning that will UPDATE the BACKUP, leaving the A partition as the stable partition for fallback.\nNotice The A and B partitions will roughly split the disk space available. If your current partition size exceeds half of the total disk size, the update mode will be switched to UPDATE_BOTH, and your zi image will be loaded into both the A and B partitions. You will be notified that your UPDATE mode has switched from UPDATE_BACKUP to UPDATE_BOTH. After the update has been applied to the A \u0026 B partitions, you can then switch to UPDATE_BACKUP via zbcli update-config. sudo zbcli update-config Validated bootware installation --------- Pi Module Raspberry Pi 4 Operating System Rpi-Bookworm Zymbit module Secure Compute Module Kernel kernel8.img --------- ❯ Configure partition layout Configure update policy Configure update endpoint Configure wireless network Revert to default configuration Save and exit Choose your settings as described below.\nFor Configure partition layout, choose [RECOMMENDED] A/B:\n❯ [RECOMMENDED] A/B: This will take the remaining disk space available after the boot partition and create two encrypted partitions, each taking up half of the remaining space. Most useful for rollback and recovery with an Active/Backup configuration. For Configure update policy, choose [RECOMMENDED] BACKUP:\n❯ [RECOMMENDED] BACKUP: Applies new updates to current backup filesystem and swap to booting the new updated backup partition as the active partition now. If the new update is bad, it will rollback into the previous stable active partition. For Configure data partition size in MB, choose the size of the encrypted shared DATA partition. The default is 512MB.\n? Enter size of data partition in MB › 1024 For Configure update endpoint, choose the block device that holds your zi image file.\nUsing update endpoint '/dev/sda1' Defaulting to configured endpoint '/dev/sda1' Info update endpoints can be either an HTTPS URL or an external mass storage device like a USB stick. ? Enter update endpoint › /dev/sda1 zbcli update-config will attempt to verify the zi image name if the endpoint is reachable.\nConfigure wireless network - Along with local devices, such as a USB stick, Bootware supports pulling remote updates via Wi-Fi or LAN connections. Wi-Fi credentials need to be provided in order for bootware to access the wifi during updates. If no wireless credentials are provided, the wireless interface is disabled in zboot.\nSave and exit to save and exit zbcli update-config. You can Ctrl-C at any point before saving to exit the configurator without applying any changes.\n5. Run zbcli update to create the Backup partition and load the zi image. Once you are satisfied with your Bootware configuration, run zbcli update to complete the process of repartitioning and loading your image.\nsudo zbcli update Validated bootware installation --------- Pi Module Raspberry Pi 4 Operating System Rpi-Bookworm Zymbit module Secure Compute Module Kernel kernel8.img --------- Cleaned '/etc/zymbit/zboot/update_artifacts/tmp' Found update configs ? Proceed with current configs? These can be modified through 'sudo zbcli update-config' --------- Update endpoint /dev/sda1 Update name my_image Endpoint type LOCAL Partition layout A/B Update policy UPDATE_BACKUP --------- (y/n) › yes The script will show your configuration for review and confirmation and give you the option to change the configuration. If not correct, enter no to exit. You may then re-run zbcli update-config to correct the configuration. If the configuration is not valid, zbcli update will exit.\nNext, you need to enter the path to your public key file (in PEM format). For this example, we will use the public key file we copied locally earlier.\n✔ Enter public key file (Pem format) · ./my_image_pub_key.pem If verification with the Public Key succeeds, zbcli update will continue with progress information, then prompt for a reboot to complete the process.\nBootware Boot Process The Bootware update process will now take place. Upon reboot in UPDATE_BACKUP mode, zboot will allocate, create, and encrypt a B partition, then load the contents of your zi image onto it. The A partition will remain untouched, and the system will come back online with partition B (cryptrfs_B) as its root filesystem.\nIf your original partition was more than half the available disk space and you were switched to UPDATE_BOTH during configuration, both A and B will have been created and your image loaded into both. In this case, the system will come back online after the update with its root filesystem on partition A (cryptrfs_A).\nNotice The initial configuration process can take 30 to 60 minutes to complete depending on the size of the image. The setup process with zbcli can be completed via SSH, but an HDMI console is helpful to follow the progress from within zboot. The Zymkey’s blue LED will return to flashing once every three seconds once the update process completes and the linux system has come back online. On the console, you will see:\n“Loading: Encrypted zboot please wait…” message, which takes around 4-5min. The A/B partitions will be configured and setup for LUKS encryption protected by the Zymbit HSM. It will then take a few minutes to process and validate the image. Depending on the size of the zi image, it may take a significant amount of time to load its contents into the root partition(s) being targeted for update. Once zboot is done unpacking the image to the B partition, it will boot your system with the B (UPDATE_BACKUP mode) / A (UPDATE_BOTH mode) partition as the ACTIVE partition. You can use lsblk to examine the partition layout. 4. Quickcheck: Manual Rollback (Active/Backup partitions) To verify you now have two valid partitions, manually trigger a rollover from Active to Backup with zbcli rollback-swap. This will reboot your system into its non-active root partition. No update process will be invoked and the contents of both partitions will remain enchanged.\nsudo zbcli rollback-swap Once again, you can use lsblk to verify the active partition has changed. You should now have identical Active and Backup partitions with working images ready for your development.\nIf Bootware detects that the system has failed to reach a systemd init target for 3 consecutive attempts in a row, it will automatically initiate a rollback-swap of the root partitions upon the next reboot.\nAdditional Information and Support Contact Support\n","categories":"","description":"Getting Started tutorial to get Bootware up and running","excerpt":"Getting Started tutorial to get Bootware up and running","ref":"/bootware/getting-started/","tags":"","title":"Getting Started: Bootware 1.2"},{"body":" Included here are instructions and notes to help bring up peripheral devices for use with the Secure Edge Node (SEN).\n","categories":"","description":"","excerpt":" Included here are instructions and notes to help bring up peripheral …","ref":"/device-addons/","tags":"","title":"SEN Device Add-ons"},{"body":" Quickstart - Download and Install Bootware Software In this Getting Started guide we describe how to bring up a common use case for Bootware - A/B partitioning for fallback and recovery.\nThe default SCM/SEN as shipped has Zymbit software pre-installed. The Zymbit product should be up and running with the blue LED flashing once every three seconds. All of the default images will have a hostname of zymbit-dev and a login of zymbit/zymbit. Change the hostname and login during your development.\nAn HDMI console is highly recommended for setting up your unit with Bootware. The process of repartitioning and loading takes time and the console is handy for monitoring progress.\nDetails of the commands in this Quickstart are linked in line. See the Features section for more information on how to use Bootware.\nOverview of steps to get up and running Download the Bootware tools package and untar. Run zb-install to install the Bootware tools Run zb-imager to create and sign a Zymbit image file (zi image) of your current root file system as a backup. Run zb-wizard to configure Partitions and Recovery strategy. For this Quickstart, we will setup A/B partitions. Run zb-update to load a known good example zi image into the Backup (B) partition; set B to as the Active partition. Use the “-r” option to force a Rollback to your original partition to verify your A/B setup is working. 1. Download Bootware Download the Bootware software to the SCM. The Bootware software can be downloaded with curl:\ncurl https://bootware.s3.amazonaws.com/bootware-1.1.tgz --output bootware-1.1.tgz Once the tar file is downloaded, untar:\ntar xvzf bootware-1.1.tgz The contents will be extracted into bootware-1.1. Files extracted:\nItem Description zb-install.sh Shell script to install Bootware tools scripts/ Scripts and configuration files for Bootware zboot_artifacts/ zboot executable and boot artifacts zb-uninstall.sh Shell script to uninstall Bootware tools Run the following install script on the SCM to install the zboot utilities:\ncd bootware-1.1 sudo ./zb-install.sh Installing zboot tools... Reading package lists... Done Building dependency tree... Done … Installing zboot... Done! After installing the zboot tools. A reboot is required. Reboot now? (Y/n) Reboot to complete the installation process. The process takes two reboots. Once completed, all necessary files required for loading new images via zboot will be installed. The install process will change the boot sequence to use u-boot and Zymbit’s zboot, but does not alter your filesystem.\n2. Run zb-imager to create Bootware-ready Zymbit Image backup (zi image) Bootware requires images in a secure, signed format for loading with zboot. An image conversion tool, zb-imager, creates the zi image. zb-imager can take a snapshot of your running system or input can be tarballs of your /boot and /rootfs partitions. Images can also be partial file additions and deletions called Overlay images.\nIf you are Developing on a CM4 directly and need to transition to the SCM, See Developing on the CM4 for instructions on how to create an image from your CM4 to load onto the SCM.\nCreate a zi image backup from your current running root file system Use zb-imager to create a Zymbit Image (zi) backup of your current running system. Once created, the zi image can be propagated to other disk partitions securely. A Private/Public key pair will be used for signing the zi image at time of creation and verifying at time of loading onto a new partition. Key pairs can either be created in software or using the Zymbit HSM hardware. For this Quickstart, we will use software keys. Details on signing and verifying can be found here.\nsudo zb-imager Make the following selections:\nItem Description Image Type? Choose 1. for a Full Image Name of Image?: Any name. Ex. myImage. Name of the converted output file. A zi extension will be added to the name. Version?: 1.1 Optional. An arbitrary version number for your reference. Next, you will be prompted for Signing Keys. Keys can be Software or Hardware based. You can use an existing key or the script will create keys for you. For this Quickstart, we will assume you need to generate Software keys,\nItem Description Use software-based keys? Yes Key? 1. Create new software key The zb-imager script will now build your zi image.\nThe imager takes 20 minutes or longer depending on the size of your file system. Once completed, the zi image and Private/Public key will be saved in /etc/zymbit/zboot/update_artifacts/output/. Keep your private key private. The zi image can be copied to either a local storage device such as a USB stick or a remote server accessible via HTTPS. The public key file will be needed to load the zi image.\nAdditional examples of zb-imager usage can be found here: zb-imager usage\n3. Run zb-wizard to configure the Partitioning and Image loading For this quickstart, we will use a known-good zi image. We’ve converted the pre-installed base image on the SCM to the zi format. We will configure the zi image to be accessed remotely via HTTPS.\nIf you wish to run from a local source such as a USB stick, our example image can be downloaded from here:\nFor bullseye,\ncurl https:///bootware.s3.amazonaws.com/zymbit_bullseye64_1.1.zi --output zymbit_bullseye64_1.1.zi For bookworm,\ncurl https:///bootware.s3.amazonaws.com/zymbit_bookworm64_1.1.zi --output zymbit_bookworm64_1.1.zi For ubuntu,\ncurl https:///bootware.s3.amazonaws.com/zymbit_ubuntu64_22.04_1.1.zi --output zymbit_ubuntu64_22.04_1.1.zi You will need the corresponding public key in order to verify the downloaded image. The public key in PEM format for either the bullseye image or the ubuntu image can be downloaded here:\ncurl https:///bootware.s3.amazonaws.com/pub_key_1.1.pem --output pub_key_1.1.pem Use the Bootware Wizard to Configure your System Bootware includes a tool to help configure your system called zb-wizard. zb-wizard is meant to setup your device environment to load a zi image from a configured endpoint and the update policies for how to apply those updates. More information on zb-wizard can be found here.\nWe are going to configure with A/B partitioning to have a stable backup partition for fallback. To start the wizard,\nsudo zb-wizard Choose your settings as described below.\nBootware Wizard -Main Screen Choose your options, save and exit.\nPartition Setup – Specifies the device partition layout after an update. The root file system will be re-partitioned with your chosen configuration. Filesystem sizes estimates are based off of 32GB CM4s. Choose the recommended Option 3 A/B.\n3 A/B – RECOMMENDED This will take the remaining disk space available after the boot partition and create two encrypted partitions, each taking up half of the remaining space (around 14.4 GB). Update Policy – The update policies define if image updates are applied to the Backup, Active, or Both partitions. Choose the recommended Option 1 - Backup. This way you know you have a good Active partition for fallback.\nEndpoint Setup – The configured endpoint with image. The endpoint can be either an HTTPS URL or a local external mass storage device like a USB stick or nVME drive. We are going to use the URL of our known good image:\nFor bullseye,\nhttps:///bootware.s3.amazonaws.com/zymbit_bullseye64_1.1 For bookworm,\nhttps:///bootware.s3.amazonaws.com/zymbit_bookworm64_1.1 For ubuntu,\nhttps:///bootware.s3.amazonaws.com/zymbit_ubuntu64_22.04_1.1 If you opted to download one of the zi images to a local device, enter the device endpoint name instead.\n/dev/sda1 zb-wizard will attempt to verify the zi image is reachable.\nWireless Setup – Bootware supports pulling updates via Wifi or LAN connections. Wifi credentials need to be provided in order for bootware to access the wifi during updates. If no wireless credentials are provided, the wireless interface is disabled in zboot.\nSave and Exit to exit zb-wizard.\n4. Run zb-update to create the Backup partition and load the zi image. Once you have completed using the Wizard to configure your Bootware, run zb-update to complete the process of repartitioning and loading your image.\nsudo zb-update The script will show your configuration for review and confirmation and give you the option to change the configuration.\nParameter Setting Notes update_endpoint https://bootware.s3.amazonaws.com/zymbit_bullseye64_1.1 or the endpoint for bookworm or ubuntu from above endpoint_type HTTPS if you are using a local endpoint, adjust, e.g. /dev/sda1 one_root_fs false We are using A/B: two root partitions update_mode UPDATE_BACKUP We are only going to load the image onto the BACKUP partition resize_a false We are not going to make one big A partition. We are making an A and B Hit return or Y to start the download process.\nOnce completed, zb-update will ask you to confirm the name of the image, and the verification public key information. For this example, that will be the software-based public key PEM file downloaded earlier.\nParameter Setting Notes Use software-based keys for verifying Y Use software keys Existing key path? pub_key_1.1.pem Adjust if not downloaded to your local directory The script will prompt for a reboot to complete the process.\nzboot Boot Process The Bootware boot process will now take place. zboot will boot your system. Upon reboot, an encrypted B partition will be created and the zi image will be loaded onto B. The A partition will remain untouched.\nWarning The initial configuration process can take up to an hour to complete, depending on the size of the image. The process can be completed via ssh, but an HDMI console is helpful to follow the process. During the process, the blue LED will be OFF. On the console, you will see:\n“Loading: Encrypted zboot please wait…” message, which takes around 4-5min. The B partitions will be configured and setup for LUKS encryption protected by the Zymbit SCM It will then take a few minutes to get/unpack tarballs from the image, and verify the signature It will take some time to unpack the image into the B root partition, depending on the size of the image. Once it’s done unpacking the image to the B partition, it will boot into the B partition as the ACTIVE partition. You can use lsblk to examine the partitions. 4. Quickcheck - Force Failover (Change Active/Backup partitions) To verify you now have your A partition intact, force a failover from Active to Backup with the -r option to zb-update\nsudo zb-update -r You should now have Active and Backup partitions with working images ready for your development.\nAdditional Information and Support Contact Support\n","categories":"","description":"","excerpt":" Quickstart - Download and Install Bootware Software In this Getting …","ref":"/bootware/archive/bootware-one-zero-general/getting-started/","tags":"","title":"Getting Started"},{"body":" Bootware applies updates through zymbit images or *.zi files. These files are created by using the zb-imager tool to package up a zymbit image for the user. These images can be signed by either hardware keys stored in the HSM or with software key files generated by the ecdsa library. zb-imager will generate both the hardware keys and the software keys based off of SECP256k1.\nHardware key generation: Zb-imager leverages the BIP32/BIP39 wallet APIs of the SCM for key generation. The wallet is named “bootware” and will generate the signing key pair with the wallet address of “m/0/n” (where n is a random number between 0-100). The wallet address “m/0/n” info will be stored in the zymbit image: header.txt. After the zb-imager finishes signing the image with the signing key, the tool will say what slot the “m/0/n” key is residing in, as well as prompt the user for saving the bip39 mnemonic to file. The BIP39 mnemonic is a 24 word sentence that can be used to regenerate the master keypair or “m” of the wallet. So this is one way to re-clone the same hardware generated key between different publishing nodes. To verify the image on the node that needs to apply the update, zb-update will ask for an existing key slot number to verify with.\nThe best way to transport the key over from the publishing node to the receiving node:\nOn the publishing node:\n#Save this public_key to a file public_key = zymkey.client.get_public_key(signing_key_slot_number) On the receiving node:\n#Store the public key in the HSM to verify updates with foreign_key_slot = zymkey.client.store_foreign_public_key(\"secp256k1\", public_key) Using zb-update on receiving node:\nsudo zb-update --key-slot=foreign_key_slot Software key generation: Zb-imager leverages the python ecdsa library to generate a SECP256K1 key pair as private_key.pem/pub_key.pem. These key files will be saved to the same location as the image that is being created. Both the zb-imager and zb-update tools will take in a filepath to these key files when the user specifies software keys for signing/verifying.\nWarning: If using the “LOCAL DEVICE” configuration of zb-update. Do not use a file path that points at a pub_key.pem on the local device. Zb-update will remount the local device on /etc/zymbit/zboot/mnt so the filepath will change.\nUsing zb-update on receiving node:\nsudo zb-update --key-file=/home/zymbit/pub_key.pem See also: zb-imager\nzb-update\n","categories":"","description":"","excerpt":" Bootware applies updates through zymbit images or *.zi files. These …","ref":"/bootware/archive/bootware-one-zero-general/features/signing/","tags":"","title":"Zymbit Bootware Signing and Verifying"},{"body":" zb-imager Description Requires superuser privilege.\nBootware requires images in a particular format. Use zb-imager to convert images into Zymbit Image (zi) format. The script will prompt you for all required information. The Flags in the Usage below can be used to provide that information from the command line and skip that prompt.\nUsage zb-imager [-k \u003ckey slot\u003e ] | [--output-directory=\u003coutput dir\u003e] Flags Description --------------------------------------------------------------------------------------------------------------------- --boot-tarball Use this boot tarball --root-tarball Use this root tarball --binary-image Convert a binary image to a zymbit image --image-name The image name of the zymbit image --image-version The image version of the zymbit image --full-image Generate a image of update type:FULL --overlay-image Generate a image of update type:OVERLAY --use-hardware Use Zymbit HSM to sign/verify the image --use-software Use priv/pub key pem files to sign/verify the image --new-key Generate a new key for signing/verifying --save-wallet-info If a new HSM wallet slot was generated. Save the mnemonic and public key -k, --key-slot The HSM key slot to sign the image with -f, --key-file The private key pem to sign the image with -o, --output-directory Output directory for new .zi images -z, --take-snapshot Create a .zi snapshot of current running system. -h, --help To view the manual. --------------------------------------------------------------------------------------------------------------------- Examples Example to create a zi image from your current running root file system sudo zb-imager The script will prompt for information.\nChecking for zymbit scm... Image type? 1. Full image of this live system 2. Overlay image from files added with zb-manifest : 1 Image Name?: myFullImage Version? [OPTIONAL]: 1.1 Note:Software/Hardware keys are not interchangeable. Stick with one method. Use software-based keys for Signing? (No for hardware-based keys) (Y/n): Y Key? 1. Create new software key files 2. Use a pre-existing software key files : 2 Existing private key file? (Pem format): private_key.pem Setting up environment... Copying boot from live system... Example to create a zi image from a binary image created with dd (created from dd if=/dev/sda bs=4M of=my.img): You will need the path to the image file.\nsudo zb-imager --binary-image /home/zymbit/my.img The script will prompt for information:\nChecking for zymbit scm... Image Name?: bullseye Version? [OPTIONAL]: 1.1 Boot File System Partition Number? (EX: 1): 1 Root File System Partition Number? (EX: 2): 2 Note:Software/Hardware keys are not interchangeable. Stick with one method. Use software-based keys for Signing? (No for hardware-based keys) (Y/n): Y Key? 1. Create new software key files 2. Use a pre-existing software key files : 2 Existing private key file? (Pem format): /home/zymbit/keys/private_key.pem Setting up environment... Copying boot files from binary image... Example to convert boot/root tarballs (created from: tar cvf my_boot.tar \u003cboot_part\u003e; tar cvf my_rfs.tar \u003croot_part\u003e) You will need to provide the names and paths to your tarballs. Run the script:\nsudo zb-imager --boot-tarball ./boot.tar --root-tarball ./root.tar The script will prompt for information:\nChecking for zymbit scm... Image type? 1. Full image of this live system 2. Overlay image from files added with zb-manifest : 1 Image Name?: myImage Version? [OPTIONAL]: 1.1 Note:Software/Hardware keys are not interchangeable. Stick with one method. Use software-based keys for Signing? (No for hardware-based keys) (Y/n): Y Key? 1. Create new software key files 2. Use a pre-existing software key files : 2 Existing private key file? (Pem format): private_key.pem Setting up environment... Verifying image... Checking for zymbit bootware.. Checking for zymbit tools.. Done! Creating headers... Creating Zymbit Image... zb-imager will also need a private key. It can generate one for you if you do not have one. The key can either be software-based or Zymbit HSM-based. See Signing/Verifying Images for more information.\nOutput zb-imager will output the private key and public key if using software keys, along with the zi image. If you do not specify an output location, the files will be placed in /etc/zymbit/zboot/update_artifacts/output.\n","categories":"","description":"","excerpt":" zb-imager Description Requires superuser privilege.\nBootware requires …","ref":"/bootware/archive/bootware-one-zero-general/utilities/zbimager/","tags":"","title":"Zymbit Bootware Image Converter"},{"body":"Updated: 2022-04-18\nWhat is a Hardware Wallet? Zymbit’s Hardware Wallet conforms to BIP32, BIP39, BIP44 documents for Hierarchical Deterministic (HD) wallets. An HD wallet derives all new addresses/keys from a master seed, thus creating a hierarchical wallet structure. BIP32 is the first seed standard for HD wallets, while BIP39 is a standard that converts a mnemonic sentence (a sentence of random words) into a 512 bit seed used for Master Seed recovery. BIP44 allows for multiple accounts in the form of children derivations from the master seed.\nA Hardware Wallet, or cold storage wallet, allows you to connect online and access your digital assets, and then safely store the referenced asset in the hardware wallet. The asset does not need to be stored on online servers or platforms. The private keys of the Hardware wallet remain on the device and are never exposed.\nA Software Wallet, also known as a Soft Wallet or Desktop Wallet locally stores your keys on your desktop or in some other online location. The disadvantage of a Soft Wallet is that the presence of the keys online makes them far more susceptible to attacks.\nWhat is the Zymbit Embedded Hardware Wallet? Zymbit Embedded Hardware Wallet functionality is available in Zymbit products, HSM6 and SCM. These products are designed to easily integrate into IoT and blockchain appliances that manage large numbers of keys and/or participate in blockchain and crypto transactions.\nThe core features of Zymbit Embedded Hardware Wallets are:\nBIP32 – Hierarchical Deterministic Wallet BIP39 – Master Seed Mnemonic Code Generator BIP44 – Multi-Account Hierarchy Support SLIP39 – Shamirs Secret Sharing See example APIs for secure easy integration with host computer (Python, C, C++) Dedicated secure hardware with tamper protection and response. Why use a Hardware Wallet? To make secure crypto transactions, a user needs to have a public/private key pair. The public key is an address used for receiving incoming goods, while the private key is used for sending those goods. Losing this key pair will be disastrous, as this will effectively give someone access to the assets in that key pair. This is why for additional security it’s best practice to change addresses (keys) for every transaction. HD wallets automatically derive new addresses to use, thus eliminating the problem for the user to generate hundreds of keys on their own.\nManaging your Hardware Wallet and Security Awareness The master seed is where all new key pairs will be derived from. Each new child key pair is created based off a existing parent key pair in the wallet. If a child key pair ever becomes ‘compromised’, it can’t be tracked up the parent nodes. However this does warrant security awareness, that it will compromise all children key pairs derived from the stolen key pair.\nWarning For security reasons, the user is expected to keep track of all the key pairs via either the node address on the wallet or the slot it was allocated to on the Zymbit module. It’s better to lose a branch than a whole tree, so keep your master seed safe and locked away! Prerequisites Zymbit Modules that support this feature:\nHSM6 SCM Follow the Getting Started guide first, installing all baseline software.\nAll code snippets written in this article are written using python3. For more Zymbit API documentation (Python/C/C++) visit: API Documentation\nUsing the Zymbit Hardware Wallet: Example code snippet to show how to use the Zymbit wallet API\n#!/usr/bin/python3 import zymkey # Create a master seed and return the BIP39 mnemonic master_key_generator = bytearray(\"3xampleM@sterK3Y\", 'utf-8') wallet_name = \"MyExampleWallet\" # Use the BIP39 recovery strategy to tell zymkey to return a mnemonic. Takes a base 64 encoded string for a BIP39 passphrase. Can be empty string. use_BIP39_recovery = zymkey.RecoveryStrategyBIP39() master_slot, BIP39_mnemonic = zymkey.client.gen_wallet_master_seed(\"secp256k1\", master_key_generator, wallet_name, use_BIP39_recovery) print(\"Master Slot:%s\\nBIP39 mnemonic (write this down!):\\n%s\" % (master_slot, BIP39_mnemonic)) # Generate a child key from the master seed child_slot = zymkey.client.gen_wallet_child_key(master_slot, 3, True) child_pub_key = zymkey.client.get_public_key(child_slot) print(\"Child Slot:%s\\nChild Public Key:%s\" % (child_slot, child_pub_key)) # Get node address of the child key slot node_addr = zymkey.client.get_wallet_node_addr(child_slot) print(\"Node index:'%s' Wallet Name:'%s' Master Slot:'%s'\" % (node_addr[0], node_addr[1], node_addr[2])) # Get the key slot of the child key using our previous master key slot and wallet name key_slot = zymkey.client.get_wallet_key_slot(node_addr[0],wallet_name, master_slot) print(\"Key Slot:%s\" % (key_slot,)) # Remove the master seed zymkey.client.remove_key(master_slot) # Restore the master seed with our previous written down BIP39 mnemonic! restored_seed_slot = zymkey.client.restore_wallet_master_seed(\"secp256k1\", bytearray(\"3xampleM@sterK3Y\", 'utf-8'), wallet_name, use_BIP39_recovery, BIP39_mnemonic) print(\"Restored slot:%s\" % (restored_seed_slot,)) # Clean up the example slots zymkey.client.remove_key(master_slot) zymkey.client.remove_key(child_slot) Creating a master seed (new wallet) The Zymbit module with wallet support can have multiple master seeds be stored in its key store, allowing for management of a variety of keyrings to work with. Master seeds and its derivations are additionally backed by EC curve cryptography for an extra layer of encryption/security. The ec curves currently supported are nistp256, secp256r1, secp256k1. The master_key_generator is used to generate the BIP32 master seed, can be empty string. The RecoveryStrategy parameter dictates what recovery algorithm to return when generating the master seed. If the base RecoveryStrategy is used or none is specified, then no mnemonic will be returned. Current supported recovery strategies are none, BIP39. This example generates a master seed with the RecoveryStrategyBIP39. The BIP39 mnemonic is a 24 word string that can be used to restore or recreate a previous generated master seed. Note that a wallet name is also unique! There can not be multiple wallets with the same name.\nWarning Make sure to write the BIP39 mnemonic and store it somewhere safe! The master seed is the key to its kingdom. Don’t give it out to just anybody! The function gen_wallet_master_seed returns the allocated master seed slot and the BIP39 mnemonic if the bool flag is set True\n# Create a master seed and return the BIP39 mnemonic master_key_generator = bytearray(\"3xampleM@sterK3Y\", 'utf-8') wallet_name = \"MyExampleWallet\" # Use the BIP39 recovery strategy to tell zymkey to return a mnemonic. Takes a base 64 encoded string for a BIP39 passphrase. Can be empty string. use_BIP39_recovery = zymkey.RecoveryStrategyBIP39() master_slot, BIP39_mnemonic = zymkey.client.gen_wallet_master_seed(\"secp256k1\", master_key_generator, wallet_name, use_BIP39_recovery) print(\"Master Slot:%s\\nBIP39 mnemonic (write this down!):\\n%s\" % (master_slot, BIP39_mnemonic)) Generating a child Key Child key pairs are generated from both the slot and index of another key pair. BIP32 has two possible derivations hardened and non-hardened. Non-hardened key pairs can be linked back to its parent key pair with just its public key. Hardened key pairs cannot be linked back to its parent key. So for best security practices, it’s advised to generate hardened key pairs wherever possible.\nThe function gen_wallet_child_key returns allocated slot on success.\n# Generate a child key from the master seed child_slot = zymkey.client.gen_wallet_child_key(master_slot, 3, True) child_pub_key = zymkey.client.get_public_key(child_slot) print(\"Child Slot:%s\\nChild Public Key:%s\" % (child_slot, child_pub_key)) Node Address: The index parameter in the above example will add a new number 3 to the node address string in the wallet. Apostrophes after the number denote hardened keys. Below is an example node address string.\nm / 3' / 1' / 0' / 1 / 28\nGet a node address from a key slot If the user knows the key slot, they can get the node index and wallet name with this function.\nThe function get_wallet_node_addr(int slot) returns an array [node index string, wallet name, master seed slot number].\n# Get node address of the child key slot node_addr = zymkey.client.get_wallet_node_addr(child_slot) print(\"Node address:'%s' Wallet Name:'%s' Master Slot:'%s'\" % (node_addr[0], node_addr[1], node_addr[2])) Get a key slot from a wallet node address If the user knows the wallet node index string and either the master seed slot or the wallet name it belongs to, they can get the key slot with this function. Both master seed slot and wallet name are optional arguments, but if neither are filled, then it will throw an exception.\nThe function get_wallet_key_slot(string node_index, string wallet_name, int master_slot) returns the key slot on success.\n# Get the key slot of the child key using our previous master key slot and wallet name key_slot = zymkey.client.get_wallet_key_slot(node_addr[0],\"MyExampleWallet\", master_slot) print(\"Key Slot:%s\" % (key_slot,)) Restore a wallet master seed from a BIP39 mnemonic With the BIP39 mnemonic sentence, BIP39 passphrase, master generatorkey, and wallet name of a previously generated master seed, a user can restore a lost master seed or make a copy of the master seed on a different device.\nWarning Keep in mind that this only restores the master seed. The children nodes will have to be manually generated again. The function restore_wallet_master_seed returns the allocated key slot on success.\n# Remove the master seed zymkey.client.remove_key(master_slot) # Restore the master seed with our previous written down BIP39 mnemonic! use_BIP39_recovery = zymkey.RecoveryStrategyBIP39() restored_seed_slot = zymkey.client.restore_wallet_master_seed(\"secp256k1\", bytearray(\"3xampleM@sterK3Y\", 'utf-8'), \"MyExampleWallet\", use_BIP39_recovery, BIP39_mnemonic) print(\"Restored slot:%s\" % (restored_seed_slot,)) Troubleshooting Troubleshooting Community\n","categories":"","description":"","excerpt":"Updated: 2022-04-18\nWhat is a Hardware Wallet? Zymbit’s Hardware …","ref":"/tutorials/digital-wallet/wallet-example/","tags":"","title":"Working with the Zymbit Hardware Wallet"},{"body":"","categories":"","description":"","excerpt":"","ref":"/reference/product-briefs/hsm4/","tags":"","title":"HSM4 Product Brief"},{"body":"","categories":"","description":"","excerpt":"","ref":"/reference/cad/","tags":"","title":"CAD Files"},{"body":"","categories":"","description":"","excerpt":"","ref":"/getting-started/zymkey4/","tags":"","title":"ZYMKEY4"},{"body":" ZI Overlay Images Overlay Images are meant to update devices without nuking and remaking the LUKS-encrypted partitions. Overlay updates can be much smaller in size than “FULL” updates, as they are meant to drop in a crate of files over an existing bootware enabled system. Overlay updates simply try and unpack the update over the system and overwrite any previous existing files of the same name.\nThe process flow for loading an overlay image:\nUse zbcli manifest to include files to add/delete/modify in your partitions\nUse zbcli imager to create the overlay image from the manifest file entries\nUse zbcli update-config and zbcli-update to update your partitions\nThe files that are packed into an overlay image are specified by the user with the tool zbcli manifest.\nzbcli manifest is a simple tool that basically modifies two files:\n/etc/zymbit/zboot/update_artifacts/file_manifest /etc/zymbit/zboot/update_artifacts/file_deletions The file_manifest tracks which files are specified by the user to wrap into an overlay image using zbcli imager. file_manifest can contain both directory paths and file paths.\nThe file_deletions tracks which files are to be deleted after the file_manifest of files is dropped into the system. file_deletions can also contain both directory paths and file paths.\nDo not include the zboot ramdisk /boot/firmware/zboot.enc in overlay updates. The imager will refuse to generate an overlay image that contains zboot.enc.\nOverlay updates and system reboots Applying overlay updates requires rebooting into zboot in these two scenarios:\nWhen updating the kernel and initramfs When updating the non-active/backup partition No reboot is necessary when the UPDATE_ACTIVE policy is in effect: the update mechanism will apply changes live while the system is running. Note that a reboot is still required if the update contains a new kernel, as zboot needs to remake the FIT image with the incoming kernel.\nzbcli update will prompt the user with a “This update requires a reboot” when one of the conditions above is fulfilled.\nExample: Update the kernel on a bootware-enabled device Overlay updates expect the system to have already gone through a FULL update at least once. There should be LUKS-encrypted devices as well as backed up artifacts in /boot/firmware/zboot_bkup/.\nWhy doesn’t apt upgrade the kernel on the system?\nBootware creates a secure FIT (Flattened uImage Tree) image labeled usr-kernel.enc in /boot/firmware. This contains the kernel that is loaded by zboot on each boot. Only zboot is allowed to remake and sign/encrypt the FIT image.\nThe FIT image consists of two things:\nKernel (kernel8.img/kernel_2712.img for Raspberry Pi OS, vmlinuz for Ubuntu) Zymbit generated initramfs (For unlocking the LUKS system with keys in the HSM) To update the kernel on the device and remake the FIT Image:\nBoth FULL and OVERLAY image updates that contain a kernel will trigger a rebuild of the FIT image, but an overlay update will be much faster if that is the only thing a user wishes to update.\nExample: Add the kernel to the addition manifest using zbcli manifest sudo zbcli manifest add /boot/firmware/kernel8.img You can see the the file path via the zbcli manifest print subcommand:\nValidated bootware installation --------- Pi Module: Raspberry Pi 5 Operating System: Rpi-Bookworm Zymbit module: Hardware Security Module 6 Kernel: kernel_2712.img --------- Files to be overwritten /boot/firmware/kernel_2712.img No files to be deleted Finished in 0s Create the overlay image with zbcli imager.\nThis zi image is only populated with the files specified in file_manifest.\nsudo zbcli imager --overlay-image --image-name=overlay Follow the prompts to provide optional version information, as well as the Private Key information.\nRun zbcli update-config with the correct endpoint and policies. Then point it at overlay.zi.\nsudo zbcli update-config Reboot to apply the changes.\nSee also: zbcli manifest\nzbcli imager\nzbcli update-config\nzbcli update\n","categories":"","description":"How to use Overlay (partial) image updates to update/modify/remove individual files","excerpt":"How to use Overlay (partial) image updates to update/modify/remove …","ref":"/bootware/features/overlays/","tags":"","title":"Zymbit Bootware Overlay Image Updates"},{"body":" zbcli update-config Description Requires superuser privilege.\nBootware includes a tool to help configure your system called zbcli update-config. zbcli update-config is meant to setup your device environment for pulling down updates from a configured endpoint and specify the update policies for how to apply those updates. The tool can be run interactively or non-interactively by specifying options on its command line.\nUsage: zbcli update-config [OPTIONS] Options: --partition \u003cPARTITION\u003e Configures partition layout [possible values: a/b, a-half-disk, a-full-disk] --update-policy \u003cUPDATE_POLICY\u003e Configures update mode [possible values: backup, active, both] --data-part-size-mb \u003cDATA_PART_SIZE_MB\u003e Configures data partition of size MB --update-endpoint \u003cUPDATE_ENDPOINT\u003e Configures update endpoint either as HTTPS URL or external mass storage device --wifi-ssid \u003cWIFI_SSID\u003e Configures Wi-Fi SSID --wifi-passphrase \u003cWIFI_PASSPHRASE\u003e Configures Wi-Fi passphrase -h, --help Print help Example sudo zbcli update-config The command will validate your bootware installation and then present a list of configuration options.\nValidated bootware installation --------- Pi Module: Raspberry Pi 5 Operating System: Rpi-Bookworm Zymbit module: Zymkey Kernel: kernel_2712.img --------- ❯ Configure partition layout Configure update policy Configure data partition size in MB Configure update endpoint Configure wireless network Save and exit Choose your settings as described below.\nConfigure partition layout – Specifies the device partition layout after an update. The root file system will be re-partitioned with your chosen configuration. Filesystem sizes estimates are based off of 32GB storage.\n? Select device partition layout after an update › ❯ [RECOMMENDED] A/B: This will take the remaining disk space available after the boot partition and create two encrypted partitions, each taking up half of the remaining space. Most useful for rollback and recovery with an Active/Backup configuration. Only A (half disk): This will take the remaining disk space available after the boot partition and create an encrypted partition that will use half of this space as the root partition. This leaves half the disk empty on purpose for dev usage. Only A (full disk): This will take the remaining disk space available after the boot partition and create an encrypted partition that will use almost all of this space as the root partition. Configure update policy – The update policies are centered around how a new update gets applied to the filesystems on the device. The update policies listed below are only related to (A)ctive/(B)ackup partitioned devices, as (A)ctive only devices only have one filesystem to update.\n? Select update policy › [RECOMMENDED] BACKUP: Applies new updates to current backup filesystem and swap to booting the new updated backup partition as the active partition now. If the new update is bad, it will rollback into the previous stable active partition. ACTIVE: Applies new updates to only the current active filesystem and keeps the backup partition untouched. ❯ BOTH: Applies new updates to both filesystems and always boot on the first root partition as the active partition. Warning: a bad update will have nothing to rollback to and the device will have to go through a recovery process. Configure data partition size in MB - Along with A/B partitions for your root file system, Bootware includes a shared, encrypted data partition. The data partition can be accessed from either the Active or Backup partition. The default partition size is 512MB. Use this option to specify the size of the shared data partition in MegaBytes (MB).\n? Enter size of data partition in MB › Configure update endpoint – The endpoint holding the update image (zi image). rUupdate endpoints can be either an HTTPS URL or an external mass storage device like a USB stick. The default endpoint is the local device /dev/sda1. The endpoint provided will be checked for a valid file with a ‘zi’ extension.\n? Enter update endpoint › Example https URL: https://bootware.s3.amazonaws.com/zymbit_bookworm64_1.1.zi\nExample USB stick: /dev/sda1\nConfigure wireless network – Bootware supports pulling updates via Wifi or LAN connections. Wifi credentials need to be provided in order for bootware to access the wifi during updates. These credentials are configured separately from the host OS wireless credentials as they run within Bootware. If no wireless credentials are provided, the wireless interface in Bootware is disabled.\nEnter Wi-Fi SSID · my_wifi ✔ Enter Wi-Fi passphrase · ******** ✔ Re-enter Wi-Fi passphrase · ******** Wi-Fi configuration set Save and exit. The final step is Save all your configuration settings and exit. The settings will be used for future updates by executing the zbcli update command, or automatically during the rollback/recovery process.\nSee also zbcli update\n","categories":"","description":"update-config - Sets configs for installing updates","excerpt":"update-config - Sets configs for installing updates","ref":"/bootware/zbcli/update-config/","tags":"","title":"zbcli update-config"},{"body":" zbcli is a standalone binary executable for carrying out all necessary Bootware installation and configuration tasks.\nUsage: zbcli \u003cCommand\u003e Options: -h, –help Print help\n-V, –version Print version\nCommands: ","categories":"","description":"Description of zbcli executable, handling most Bootware operations","excerpt":"Description of zbcli executable, handling most Bootware operations","ref":"/bootware/zbcli/","tags":"","title":"zbcli"},{"body":" ","categories":"","description":"","excerpt":" ","ref":"/bootware/archive/bootware-one-zero-general/utilities/","tags":"","title":"Utilities and Scripts"},{"body":" Overlay Images are meant to update devices without nuking and remaking the luks encrypted partitions on the SCM. Overlay updates can be much smaller in size than “FULL” updates, as they are meant to drop in a crate of files over an existing bootware enabled system. Overlay updates simply try and unpack the update over the system and overwrite any previous existing files of the same name. The files that are packed into an overlay image is specified by the user with the tool zb-manifest.\nzb-manifest is a simple tool that basically modifies two files:\n/etc/zymbit/zboot/update_artifacts/file_manifest /etc/zymbit/zboot/update_artifacts/file_deletions The file_manifest is a file that keeps track of the files that are specified by the user to wrap into an overlay image using zb-imager. file_manifest can contain both folder paths and file paths.\nThe file_deletions is a file that keeps track of what files are deleted after the file_manifest of files is dropped into the system. file_deletions can also contain both folder paths and file paths.\nOverlay updates and system reboots Overlay updates will need to reboot into zboot to fully apply an overlay update for these two scenarios:\nWhen updating the kernel and initramfs When updating the non-active/backup partition Overlay updates will not need to reboot the system on UPDATE_ACTIVE policies as they will try to unpack the overlay.zi over the active system. This is not true if the update contains a new kernel, as zboot needs to remake the usr-kernel.enc in /boot with the new kernel.\nzb-update will prompt the user with a “This update requires a reboot” when one of the conditions above is fulfilled.\nExample: Updating a kernel on a bootware enabled device Overlay updates expects the user’s system to already have gone through a “FULL” update before. This means it expects there to be LUKS encrypted devices as well as backed up artifacts in /boot/zboot_bkup.\nWhy apt update/upgrade doesn’t update the kernel on the system?\nZboot creates a secure FIT image labelled usr-kernel.enc in /boot. This effectively functions as the kernel that gets booted by zboot every boot-up. This FIT image only gets remade by zboot.\nThe FIT image consists of two things:\nKernel (kernel8.img for raspiOS, vmlinuz for Ubuntu) Zymbit generated initramfs (For unlocking the LUKS system with keys in the HSM) To update one’s kernel on the device and remake the FIT Image:\nBoth a “FULL” and “OVERLAY” image that contain a kernel will remake the FIT image, but an overlay update will be much faster if that is the only thing a user wants to update.\nExample: have zb-manifest add the kernel to the file_manifest\nsudo zb-manifest --add /boot/kernel8.img You can see the the file path get added here\ncat /etc/zymbit/zboot/update_artifacts/file_manifest \u003e/boot/kernel8.img Create the overlay image with zb-imager.\nThis .zi is only filled with the files specified in file_manifest.\nsudo zb-imager --overlay-image --image-name=overlay ... Created overlay.zi! Run zb-update with the correct endpoint and policies. Then point it at overlay.zi.\nsudo zb-update ... Found these .zi Pick one?: 1. overlay 2. Cancel \u003e 1 ... This update requires a reboot. Reboot now? (Y/n): \u003e Y See also: zb-manifest utility\nzb-imager utility\nzb-update utility\n","categories":"","description":"","excerpt":" Overlay Images are meant to update devices without nuking and …","ref":"/bootware/archive/bootware-one-zero-general/features/overlays/","tags":"","title":"Zymbit Bootware Overlay Image Updates"},{"body":" zb-wizard Description Bootware Preview includes a dialog enabled tool to help configure your system called zb-wizard. zb-wizard is meant to set your device environment up for pulling down updates from a configured endpoint and the update policies for how to apply those updates prior to running zb-update. To start the wizard,\nExample sudo zb-wizard Choose your settings as described below.\nBootware Wizard -Main Screen Choose your options, save and exit.\nPartition Setup – Specifies the device partition layout after an update. The root file system will be re-partitioned with your chosen configuration. Filesystem sizes estimates are based off of 32GB CM4s.\n1 A Only [HALF DISK] – This will take the remaining disk space available after the boot partition and create an encrypted partition that will use half of this space as the root partition (around 14.4 GB). This leaves half the disk empty on purpose for dev usage.\n2 A only [FULL DISK] – This will take the remaining disk space available after the boot partition (around ~29GB) and create an encrypted partition that will use almost all of this space as the root partition.\n3 A/B – RECOMMENDED This will take the remaining disk space available after the boot partition and create two encrypted partitions, each taking up half of the remaining space (around 14.4 GB). Most useful for rollback and recovery with an Active/Backup configuration.\nUpdate Policy – The update policies are centered around how a new update gets applied to the filesystems on the device. The update policies listed below are only related to (A)ctive/(B)ackup partitioned devices, as (A)ctive only devices only have one filesystem to update.\n1 Backup – RECOMMENDED Apply new updates to current backup filesystem and swap to booting the new updated backup partition as the active partition now. If the new update is bad, it will rollback into the previous stable active partition. Only relevant when configured with A/B partitions.\n2 Active – Apply new updates to only the current active filesystem. If the backup filesystem exists, keep the backup filesystem untouched.\n3 Both – Apply new updates to both filesystems and always boot on the first root partition as the active partition. Warning: A bad update will have nothing to rollback to; the device will have to go through a recovery process.\nEndpoint Setup – The configured endpoint ready with a new update(.zi image). The endpoint can be either an https URL or an external mass storage device like a USB stick.\nEndpoint – Type the endpoint where the .zi image resides for the device to pull updates from. The endpoint will be checked for validity.\nExample https URL: https://bootware.s3.amazonaws.com/zymbit_bookworm64_1.1.zi Example USB stick: /dev/sda1\nWireless Setup – Bootware supports pulling updates via Wifi or LAN connections. Wifi credentials need to be provided in order for bootware to access the wifi during updates. If no wireless credentials are provided, the wireless interface is disabled in zboot.\nSSID - Provide the Wifi SSID Passphrase - Provide the Wifi passphrase Save and Exit. You may also choose to Revert to the default configuration.\nSee also zb-update\n","categories":"","description":"","excerpt":" zb-wizard Description Bootware Preview includes a dialog enabled tool …","ref":"/bootware/archive/bootware-one-zero-general/utilities/zbwizard/","tags":"","title":"Zymbit Bootware Configuration Wizard"},{"body":"Updated: 2023-05-11\nWhat is Zymbit’s Wallet SDK? Blockchain accounts, signatures, and transactions have an additional layer of complexity over traditional cryptographic keys and signatures. Our Wallet SDK aims to abstract away this complexity, enabling you to create and manage multiple blockchain wallets and seamlessly interact with smart contracts in your applicaitons without having to deal with their technical intricacies.\nThese examples are derived from the documentation.\nInstallation pip install zymbitwalletsdk ETH Keyring Examples Creating an ETH Keyring If you have an existing wallet on your module, you can initialize an ETH Keyring using either the wallet name or its corresponding master slot. Here’s how:\nfrom zymbitwalletsdk import ZymbitEthKeyring keyring = ZymbitEthKeyring(wallet_name = \"MyExampleWallet\") print(keyring) or\nfrom zymbitwalletsdk import ZymbitEthKeyring keyring = ZymbitEthKeyring(master_slot = 16) print(keyring) Output:\nZymbitEthKeyring( type = ETH base_path = m/44'/60'/0'/0 wallet_name = MyExampleWallet master_slot = 16 base_slot = 20 accounts = [ (Path: m/44'/60'/0'/0/0, Address: 0x93D458d6B14A02943A07708a24D8A9F142Fc5A00, Slot: 26) (Path: m/44'/60'/0'/0/1, Address: 0x9fB80f688e4a4f68cd94e0DD4263B03cA7CC52ff, Slot: 27) (Path: m/44'/60'/0'/0/2, Address: 0x29e9f7D65886c6c1e164AFd4823A477eB0F1F75a, Slot: 28) ] ) Adding Accounts There are three methods you can use to add accounts. Here is how you use them:\nfrom zymbitwalletsdk import ZymbitEthKeyring keyring = ZymbitEthKeyring(master_slot=16) print(keyring.add_account(index = 12)) print(keyring.add_accounts(n = 2)) print(keyring.add_accounts_list(index_list = [15, 26])) print(keyring.get_accounts()) Output:\n(Path: m/44'/60'/0'/0/12, Address: 0x092aa5e156F4FE5b3944B8A2421E45a23B8d1B00, Slot: 34) [(Path: m/44'/60'/0'/0/13, Address: 0xA4cfAD05453e3FBB98EFD9A68f71E71B331d9e8A, Slot: 35), (Path: m/44'/60'/0'/0/14, Address: 0xd1B6206a83401dc042c04C9A751a7eB65645f144, Slot: 36)] [(Path: m/44'/60'/0'/0/15, Address: 0xaDAC0304B9A471838a4e704d05C90Df36ad587C6, Slot: 37), (Path: m/44'/60'/0'/0/26, Address: 0x2fb995cd644992a9a838fe18Db818c83BdE719FD, Slot: 38)] [(Path: m/44'/60'/0'/0/0, Address: 0x93D458d6B14A02943A07708a24D8A9F142Fc5A00, Slot: 26), (Path: m/44'/60'/0'/0/1, Address: 0x9fB80f688e4a4f68cd94e0DD4263B03cA7CC52ff, Slot: 27), (Path: m/44'/60'/0'/0/2, Address: 0x29e9f7D65886c6c1e164AFd4823A477eB0F1F75a, Slot: 28), (Path: m/44'/60'/0'/0/12, Address: 0x092aa5e156F4FE5b3944B8A2421E45a23B8d1B00, Slot: 34), (Path: m/44'/60'/0'/0/13, Address: 0xA4cfAD05453e3FBB98EFD9A68f71E71B331d9e8A, Slot: 35), (Path: m/44'/60'/0'/0/14, Address: 0xd1B6206a83401dc042c04C9A751a7eB65645f144, Slot: 36), (Path: m/44'/60'/0'/0/15, Address: 0xaDAC0304B9A471838a4e704d05C90Df36ad587C6, Slot: 37), (Path: m/44'/60'/0'/0/26, Address: 0x2fb995cd644992a9a838fe18Db818c83BdE719FD, Slot: 38)] Remove an Account If you want to remove an account from a keyring, here is how to do it:\nfrom zymbitwalletsdk import ZymbitEthKeyring, ZymbitKeyringManager, EthConnect keyring = ZymbitEthKeyring(wallet_name = \"MyExampleWallet\") accounts = keyring.get_accounts() print(accounts) account_to_remove = accounts[2] keyring.remove_account(address = account_to_remove.address) accounts = keyring.get_accounts() print(accounts) Output:\n[(Path: m/44'/60'/0'/0/0, Address: 0x93D458d6B14A02943A07708a24D8A9F142Fc5A00, Slot: 26), (Path: m/44'/60'/0'/0/1, Address: 0x9fB80f688e4a4f68cd94e0DD4263B03cA7CC52ff, Slot: 27), (Path: m/44'/60'/0'/0/2, Address: 0x29e9f7D65886c6c1e164AFd4823A477eB0F1F75a, Slot: 28), (Path: m/44'/60'/0'/0/12, Address: 0x092aa5e156F4FE5b3944B8A2421E45a23B8d1B00, Slot: 34), (Path: m/44'/60'/0'/0/13, Address: 0xA4cfAD05453e3FBB98EFD9A68f71E71B331d9e8A, Slot: 35), (Path: m/44'/60'/0'/0/14, Address: 0xd1B6206a83401dc042c04C9A751a7eB65645f144, Slot: 36), (Path: m/44'/60'/0'/0/15, Address: 0xaDAC0304B9A471838a4e704d05C90Df36ad587C6, Slot: 37), (Path: m/44'/60'/0'/0/26, Address: 0x2fb995cd644992a9a838fe18Db818c83BdE719FD, Slot: 38)] [(Path: m/44'/60'/0'/0/0, Address: 0x93D458d6B14A02943A07708a24D8A9F142Fc5A00, Slot: 26), (Path: m/44'/60'/0'/0/1, Address: 0x9fB80f688e4a4f68cd94e0DD4263B03cA7CC52ff, Slot: 27), (Path: m/44'/60'/0'/0/12, Address: 0x092aa5e156F4FE5b3944B8A2421E45a23B8d1B00, Slot: 34), (Path: m/44'/60'/0'/0/13, Address: 0xA4cfAD05453e3FBB98EFD9A68f71E71B331d9e8A, Slot: 35), (Path: m/44'/60'/0'/0/14, Address: 0xd1B6206a83401dc042c04C9A751a7eB65645f144, Slot: 36), (Path: m/44'/60'/0'/0/15, Address: 0xaDAC0304B9A471838a4e704d05C90Df36ad587C6, Slot: 37), (Path: m/44'/60'/0'/0/26, Address: 0x2fb995cd644992a9a838fe18Db818c83BdE719FD, Slot: 38)] Keyring Manager Examples Initialize the keyring manager to manage multiple keyrings from zymbitwalletsdk import ZymbitEthKeyring, ZymbitKeyringManager keyring1 = ZymbitEthKeyring(wallet_name = \"MyExampleWallet\") keyring2 = ZymbitEthKeyring(wallet_name = \"MyExampleWallet1\") keyring_manager = ZymbitKeyringManager(keyrings = [keyring1, keyring2]) print(keyring_manager.get_keyrings()) Output:\n[ZymbitEthKeyring( type = ETH base_path = m/44'/60'/0'/0 wallet_name = MyExampleWallet master_slot = 16 base_slot = 20 accounts = [ (Path: m/44'/60'/0'/0/0, Address: 0x93D458d6B14A02943A07708a24D8A9F142Fc5A00, Slot: 26) (Path: m/44'/60'/0'/0/1, Address: 0x9fB80f688e4a4f68cd94e0DD4263B03cA7CC52ff, Slot: 27) (Path: m/44'/60'/0'/0/12, Address: 0x092aa5e156F4FE5b3944B8A2421E45a23B8d1B00, Slot: 34) (Path: m/44'/60'/0'/0/13, Address: 0xA4cfAD05453e3FBB98EFD9A68f71E71B331d9e8A, Slot: 35) (Path: m/44'/60'/0'/0/14, Address: 0xd1B6206a83401dc042c04C9A751a7eB65645f144, Slot: 36) (Path: m/44'/60'/0'/0/15, Address: 0xaDAC0304B9A471838a4e704d05C90Df36ad587C6, Slot: 37) ] ), ZymbitEthKeyring( type = ETH base_path = m/44'/60'/0'/0 wallet_name = MyExampleWallet1 master_slot = 21 base_slot = 25 accounts = [ (Path: m/44'/60'/0'/0/0, Address: 0x2E57A173B2BB0a4946A8AA7fD99f373d4bf39820, Slot: 29) (Path: m/44'/60'/0'/0/1, Address: 0xD997aCb016Ea0BD1ABFE654737Bf11AA81F4D6b0, Slot: 30) (Path: m/44'/60'/0'/0/2, Address: 0xd067C0696d115f4FEF13d4B2f48291760d008288, Slot: 31) (Path: m/44'/60'/0'/0/3, Address: 0x3586115959ec349567E2605D47aD16bcEAbc2193, Slot: 32) (Path: m/44'/60'/0'/0/4, Address: 0x8E0ce12A484a5D206ce43d2e1c1CEb56E9943410, Slot: 33) ] )] Create a wallet and corresponding ETH keyring Create a wallet and its coressponding ETH keyring using the keyring manager.\nNOTE: Store the mnemonic phrase securely\nfrom zymbitwalletsdk import ZymbitEthKeyring, ZymbitKeyringManager keyring1 = ZymbitEthKeyring(wallet_name = \"MyExampleWallet\") keyring2 = ZymbitEthKeyring(wallet_name = \"MyExampleWallet1\") keyring_manager = ZymbitKeyringManager(keyrings = [keyring1, keyring2]) new_keyring = keyring_manager.create_keyring(ZymbitEthKeyring, \"MyExampleWallet2\") print(\"Master slot and Mnemonic: \", new_keyring) print(keyring_manager.get_keyrings()) Output:\nMaster slot and Mnemonic: (28, 'all damp fire farm glad vital rich material infant shove tuna exist penalty simple choose time magnet shiver phone that idea grain merry accident') [ZymbitEthKeyring( type = ETH base_path = m/44'/60'/0'/0 wallet_name = MyExampleWallet master_slot = 16 base_slot = 20 accounts = [ (Path: m/44'/60'/0'/0/0, Address: 0x93D458d6B14A02943A07708a24D8A9F142Fc5A00, Slot: 26) (Path: m/44'/60'/0'/0/1, Address: 0x9fB80f688e4a4f68cd94e0DD4263B03cA7CC52ff, Slot: 27) (Path: m/44'/60'/0'/0/12, Address: 0x092aa5e156F4FE5b3944B8A2421E45a23B8d1B00, Slot: 34) (Path: m/44'/60'/0'/0/13, Address: 0xA4cfAD05453e3FBB98EFD9A68f71E71B331d9e8A, Slot: 35) (Path: m/44'/60'/0'/0/14, Address: 0xd1B6206a83401dc042c04C9A751a7eB65645f144, Slot: 36) (Path: m/44'/60'/0'/0/15, Address: 0xaDAC0304B9A471838a4e704d05C90Df36ad587C6, Slot: 37) ] ), ZymbitEthKeyring( type = ETH base_path = m/44'/60'/0'/0 wallet_name = MyExampleWallet1 master_slot = 21 base_slot = 25 accounts = [ (Path: m/44'/60'/0'/0/0, Address: 0x2E57A173B2BB0a4946A8AA7fD99f373d4bf39820, Slot: 29) (Path: m/44'/60'/0'/0/1, Address: 0xD997aCb016Ea0BD1ABFE654737Bf11AA81F4D6b0, Slot: 30) (Path: m/44'/60'/0'/0/2, Address: 0xd067C0696d115f4FEF13d4B2f48291760d008288, Slot: 31) (Path: m/44'/60'/0'/0/3, Address: 0x3586115959ec349567E2605D47aD16bcEAbc2193, Slot: 32) (Path: m/44'/60'/0'/0/4, Address: 0x8E0ce12A484a5D206ce43d2e1c1CEb56E9943410, Slot: 33) ] ), ZymbitEthKeyring( type = ETH base_path = m/44'/60'/0'/0 wallet_name = MyExampleWallet2 master_slot = 28 base_slot = 41 accounts = [ ] )] Add a keyring from zymbitwalletsdk import ZymbitEthKeyring, ZymbitKeyringManager keyring1 = ZymbitEthKeyring(wallet_name = \"MyExampleWallet\") keyring2 = ZymbitEthKeyring(wallet_name = \"MyExampleWallet1\") keyring_manager = ZymbitKeyringManager(keyrings = [keyring1, keyring2]) keyring3 = ZymbitEthKeyring(wallet_name = \"MyExampleWallet2\") keyring_manager.add_keyring(keyring3) print(keyring_manager.get_keyrings()) Output:\n[ZymbitEthKeyring( type = ETH base_path = m/44'/60'/0'/0 wallet_name = MyExampleWallet master_slot = 16 base_slot = 20 accounts = [ (Path: m/44'/60'/0'/0/0, Address: 0x93D458d6B14A02943A07708a24D8A9F142Fc5A00, Slot: 26) (Path: m/44'/60'/0'/0/1, Address: 0x9fB80f688e4a4f68cd94e0DD4263B03cA7CC52ff, Slot: 27) (Path: m/44'/60'/0'/0/12, Address: 0x092aa5e156F4FE5b3944B8A2421E45a23B8d1B00, Slot: 34) (Path: m/44'/60'/0'/0/13, Address: 0xA4cfAD05453e3FBB98EFD9A68f71E71B331d9e8A, Slot: 35) (Path: m/44'/60'/0'/0/14, Address: 0xd1B6206a83401dc042c04C9A751a7eB65645f144, Slot: 36) (Path: m/44'/60'/0'/0/15, Address: 0xaDAC0304B9A471838a4e704d05C90Df36ad587C6, Slot: 37) ] ), ZymbitEthKeyring( type = ETH base_path = m/44'/60'/0'/0 wallet_name = MyExampleWallet1 master_slot = 21 base_slot = 25 accounts = [ (Path: m/44'/60'/0'/0/0, Address: 0x2E57A173B2BB0a4946A8AA7fD99f373d4bf39820, Slot: 29) (Path: m/44'/60'/0'/0/1, Address: 0xD997aCb016Ea0BD1ABFE654737Bf11AA81F4D6b0, Slot: 30) (Path: m/44'/60'/0'/0/2, Address: 0xd067C0696d115f4FEF13d4B2f48291760d008288, Slot: 31) (Path: m/44'/60'/0'/0/3, Address: 0x3586115959ec349567E2605D47aD16bcEAbc2193, Slot: 32) (Path: m/44'/60'/0'/0/4, Address: 0x8E0ce12A484a5D206ce43d2e1c1CEb56E9943410, Slot: 33) ] ), ZymbitEthKeyring( type = ETH base_path = m/44'/60'/0'/0 wallet_name = MyExampleWallet2 master_slot = 28 base_slot = 41 accounts = [ ] )] Get a keyring from zymbitwalletsdk import ZymbitEthKeyring, ZymbitKeyringManager keyring1 = ZymbitEthKeyring(wallet_name = \"MyExampleWallet\") keyring2 = ZymbitEthKeyring(wallet_name = \"MyExampleWallet1\") keyring3 = ZymbitEthKeyring(wallet_name = \"MyExampleWallet2\") keyring_manager = ZymbitKeyringManager(keyrings = [keyring1, keyring2, keyring3]) print(keyring_manager.get_keyring(wallet_name = \"MyExampleWallet1\")) Output:\nZymbitEthKeyring( type = ETH base_path = m/44'/60'/0'/0 wallet_name = MyExampleWallet1 master_slot = 21 base_slot = 25 accounts = [ (Path: m/44'/60'/0'/0/0, Address: 0x2E57A173B2BB0a4946A8AA7fD99f373d4bf39820, Slot: 29) (Path: m/44'/60'/0'/0/1, Address: 0xD997aCb016Ea0BD1ABFE654737Bf11AA81F4D6b0, Slot: 30) (Path: m/44'/60'/0'/0/2, Address: 0xd067C0696d115f4FEF13d4B2f48291760d008288, Slot: 31) (Path: m/44'/60'/0'/0/3, Address: 0x3586115959ec349567E2605D47aD16bcEAbc2193, Slot: 32) (Path: m/44'/60'/0'/0/4, Address: 0x8E0ce12A484a5D206ce43d2e1c1CEb56E9943410, Slot: 33) ] ) Remove a keyring Removing a keyring using the keyring manager removes the keys permanently from the module and the keyring manager instance. If the remove_master flag is set to True, it removes the master key from the device as well.\nfrom zymbitwalletsdk import ZymbitEthKeyring, ZymbitKeyringManager keyring1 = ZymbitEthKeyring(wallet_name = \"MyExampleWallet\") keyring2 = ZymbitEthKeyring(wallet_name = \"MyExampleWallet1\") keyring3 = ZymbitEthKeyring(wallet_name = \"MyExampleWallet2\") keyring_manager = ZymbitKeyringManager(keyrings = [keyring1, keyring2, keyring3]) keyring_manager.remove_keyring(master_slot = keyring3.master_slot, remove_master=True) print(keyring_manager.get_keyrings()) Output:\n[ZymbitEthKeyring( type = ETH base_path = m/44'/60'/0'/0 wallet_name = MyExampleWallet master_slot = 16 base_slot = 20 accounts = [ (Path: m/44'/60'/0'/0/0, Address: 0x93D458d6B14A02943A07708a24D8A9F142Fc5A00, Slot: 26) (Path: m/44'/60'/0'/0/1, Address: 0x9fB80f688e4a4f68cd94e0DD4263B03cA7CC52ff, Slot: 27) (Path: m/44'/60'/0'/0/12, Address: 0x092aa5e156F4FE5b3944B8A2421E45a23B8d1B00, Slot: 34) (Path: m/44'/60'/0'/0/13, Address: 0xA4cfAD05453e3FBB98EFD9A68f71E71B331d9e8A, Slot: 35) (Path: m/44'/60'/0'/0/14, Address: 0xd1B6206a83401dc042c04C9A751a7eB65645f144, Slot: 36) (Path: m/44'/60'/0'/0/15, Address: 0xaDAC0304B9A471838a4e704d05C90Df36ad587C6, Slot: 37) ] ), ZymbitEthKeyring( type = ETH base_path = m/44'/60'/0'/0 wallet_name = MyExampleWallet1 master_slot = 21 base_slot = 25 accounts = [ (Path: m/44'/60'/0'/0/0, Address: 0x2E57A173B2BB0a4946A8AA7fD99f373d4bf39820, Slot: 29) (Path: m/44'/60'/0'/0/1, Address: 0xD997aCb016Ea0BD1ABFE654737Bf11AA81F4D6b0, Slot: 30) (Path: m/44'/60'/0'/0/2, Address: 0xd067C0696d115f4FEF13d4B2f48291760d008288, Slot: 31) (Path: m/44'/60'/0'/0/3, Address: 0x3586115959ec349567E2605D47aD16bcEAbc2193, Slot: 32) (Path: m/44'/60'/0'/0/4, Address: 0x8E0ce12A484a5D206ce43d2e1c1CEb56E9943410, Slot: 33) ] )] EthConnect Library Examples For this tutorial, we use the Sepolia test network to test sending our transactions.\nCreate and Broadcast an ETH Transaction (EIP-1559) from zymbitwalletsdk import ZymbitEthKeyring, ZymbitKeyringManager, EthConnect from web3 import Web3 import binascii web3 = Web3(Web3.HTTPProvider(\"YOUR ETH NODE'S HTTPS ENDPOINT\")) keyring = ZymbitEthKeyring(wallet_name = \"MyExampleWallet1\") sending_account = keyring.get_accounts()[1] chain_id = web3.eth.chain_id nonce = web3.eth.get_transaction_count(sending_account.address) value_in_wei = EthConnect.eth_to_wei(0.0001) recipient_address = keyring.get_accounts()[0].address gas_price = web3.eth.gas_price gas_limit = 21000 transaction = EthConnect.create_transaction(chain_id = chain_id, nonce = nonce, value = value_in_wei, to = recipient_address, max_fee_per_gas = gas_price, gas = gas_limit) print(transaction) signed_transaction = EthConnect.sign_transaction(transaction, keyring, address = sending_account.address) print(signed_transaction) serialized_transaction = EthConnect.rlp_serialize_transaction(signed_transaction) transaction_result_hash = web3.eth.send_raw_transaction(serialized_transaction) print(\"Transaction broadcast hash:\\n%s\" % binascii.hexlify(transaction_result_hash).decode(\"utf-8\")) Output:\nEthTransaction(chain_id=11155111, nonce=30, max_priority_fee_per_gas=1, max_fee_per_gas=1000000007, gas=21000, to=b'.W\\xa1s\\xb2\\xbb\\nIF\\xa8\\xaa\\x7f\\xd9\\x9f7=K\\xf3\\x98 ', value=100000000000000, data=b'', access_list=()) SignedEthTransaction(chain_id=11155111, nonce=30, max_priority_fee_per_gas=1, max_fee_per_gas=1000000007, gas=21000, to=b'.W\\xa1s\\xb2\\xbb\\nIF\\xa8\\xaa\\x7f\\xd9\\x9f7=K\\xf3\\x98 ', value=100000000000000, data=b'', access_list=(), y_parity=True, r=44987742661489270771188443846316967428376177535265140127433627783003713851105, s=54741034043774433582032940802071398050179513067469791027144539380885541407020) Transaction broadcast hash: 4c2118a229b63ee096408233a19bea3d93340b44d141a397072093f98306d064 You can view the transaction details here\nContract Transactions (EIP-1559) For the deploying and executing contract examples, we will be using the following solidity contract:\npragma solidity \u003e=0.7.0 \u003c0.9.0; contract Counter { uint public counter; event IncrementedCounter (uint counter, address indexed sender); constructor(uint initial) { counter = initial; } function increment_counter() public { counter += 1; emit IncrementedCounter(counter, msg.sender); } } Create an ETH Deploy Contract Transaction To deploy a contract, you need to save the contract ABI as a JSON file and the hex encoded bytecode as a txt file on your Pi’s local file system. Once you have done that, you can deploy a contract like this:\nfrom zymbitwalletsdk import ZymbitEthKeyring, ZymbitKeyringManager, EthConnect from web3 import Web3 import binascii web3 = Web3(Web3.HTTPProvider(\"YOUR ETH NODE'S HTTPS ENDPOINT\")) keyring = ZymbitEthKeyring(wallet_name = \"MyExampleWallet1\") sending_account = keyring.get_accounts()[1] chain_id = web3.eth.chain_id nonce = web3.eth.get_transaction_count(sending_account.address) value_in_wei = EthConnect.eth_to_wei(1) recipient = keyring.get_accounts()[0].address gas_price = web3.eth.gas_price gas_limit = 2100000 transaction = EthConnect.create_deploy_contract_transaction(chain_id = chain_id, nonce = nonce, contract_abi_path = './ABI.json', contract_bytecode_path = \"./bytecode.txt\", constructor_args = [0], max_fee_per_gas = gas_price, gas = gas_limit) signed_transaction = EthConnect.sign_transaction(transaction, keyring, address = sending_account.address) serialized_transaction = EthConnect.rlp_serialize_transaction(signed_transaction) transaction_result_hash = web3.eth.send_raw_transaction(serialized_transaction) print(\"Transaction broadcast hash:\\n%s\" % binascii.hexlify(transaction_result_hash).decode(\"utf-8\")) Output:\nTransaction broadcast hash: d8163f20bd3baf0f59ee23091eda5b0160147b7a4e4eeb3988306e3534a7e03d You can view the transaction details here\nCreate an ETH Execute Contract Transaction In this example, we are going to invoke the increment_counter function in our deployed contract. Here’s how to do it:\nfrom zymbitwalletsdk import ZymbitEthKeyring, ZymbitKeyringManager, EthConnect from web3 import Web3 import binascii web3 = Web3(Web3.HTTPProvider(\"YOUR ETH NODE'S HTTPS ENDPOINT\")) keyring = ZymbitEthKeyring(wallet_name = \"MyExampleWallet1\") sending_account = keyring.get_accounts()[1] chain_id = web3.eth.chain_id nonce = web3.eth.get_transaction_count(sending_account.address) value_in_wei = EthConnect.eth_to_wei(1) contract_address = \"0xE575A1F131be23223ee59f00379FF13B913E9063\" # The deployed contract's address on the Sepolia test network gas_price = web3.eth.gas_price gas_limit = 2100000 transaction = EthConnect.create_execute_contract_transaction(chain_id = chain_id, nonce = nonce, contract_abi_path = './ABI.json', contract_address = contract_address, function_name= \"increment_counter\", args = [], max_fee_per_gas = gas_price, gas = gas_limit) signed_transaction = EthConnect.sign_transaction(transaction, keyring, address = sending_account.address) serialized_transaction = EthConnect.rlp_serialize_transaction(signed_transaction) transaction_result_hash = web3.eth.send_raw_transaction(serialized_transaction) print(\"Transaction broadcast hash:\\n%s\" % binascii.hexlify(transaction_result_hash).decode(\"utf-8\")) Output:\nTransaction broadcast hash: ae5bc454c77405d6492e794a71fdb74342c8429091bc41967ba1f0ce3753c147 You can view the transaction details here\n","categories":"","description":"","excerpt":"Updated: 2023-05-11\nWhat is Zymbit’s Wallet SDK? Blockchain accounts, …","ref":"/tutorials/digital-wallet/zymbit-wallet-python-sdk/","tags":"","title":"Working with Zymbit's Wallet Python SDK"},{"body":"","categories":"","description":"","excerpt":"","ref":"/reference/product-briefs/hsm6/","tags":"","title":"HSM6 Product Brief"},{"body":"","categories":"","description":"","excerpt":"","ref":"/reference/conformity/","tags":"","title":"Conformity Documents"},{"body":"","categories":"","description":"","excerpt":"","ref":"/troubleshooting/","tags":"","title":"FAQ and Troubleshooting"},{"body":"","categories":"","description":"","excerpt":"","ref":"/getting-started/hsm4/","tags":"","title":"HSM4"},{"body":" Troubleshooting Troubleshooting Checklist Before contacting Zymbit with troubleshooting related questions, please read through the following troubleshooting checklist.\nPower supply. Most of the problems we see are from a poor power source. Start with a good power supply from the PI foundation or Canakit, not a phone charger. The recommended power for the PI4 is 5V and 3 amps. For a PI5, the recommended power supply should provide 5V, 5 amps. I2C enabled. Double check that you have enabled the I2C bus. An easy way to check is “ls -l /dev/i2c-1”. If /dev/i2c-1 exists, the I2C bus is enabled. apt update and upgrade. Be sure that your software is up to date. Installation. The curl script will reboot your system once completed. After the reboot, the blue LED on your Zymbit device should blink once every 3 seconds. You must get to this step before proceeding to encryption, etc. If your issue is not related to any of the above list, read through the FAQ below to see if your issue is answered. If you still do not see a solution to your problem, reach out on our Community Forum. Thank you!\nQ: Why does the LED continue to blink rapidly? It never blinks with the described pattern of once (in Development mode) or three times (in Production mode) every three seconds. Expand for Answer A: Check the following:\nCheck that the Raspberry Pi power is sufficient. The red LED on most Raspberry Pi models indicates if the Pi is being powered adequately. If it is not lit at all or flashes intermittently, try a different power supply or a different USB cable.\nMake sure that you have enabled i2c support using raspi-config BEFORE your install the software. Also, when you enable i2c communications be sure to follow the enable-disable-enable sequence.\nIf i2c support has been enabled correctly and the HSM4 LED is still rapidly blinking, check proper physical installation of the HSM4 as detailed in this “Getting Started” guide.\nHSM4 uses GPIO header pins 3 and 5 for i2c communications and pin 7 as an interrupt signal to the Pi. Pin 7 should preferably be dedicated exclusively to HSM4. Other devices may share the i2c bus with HSM4, but there may still be address conflicts. By default, HSM4 uses slave address 0x30. If the address conflict cannot be resolved on the other i2c devices, there is a way of changing the i2c address through an API call. Using this application, the HSM4 address can be changed anywhere in the ranges of 0x30-0x37 or 0x60-0x67.\nExpand for API information to change i2c address Python: set_i2c_address\nC: int zkSetI2CAddr ( zkCTX ctx, int addr)\nSee API Documentation\nOftentimes the 1-Wire interface relies on pin 7 (GPIO 4) for communication. If the 1-Wire interface is enabled, try disabling through raspi-config. If that resolves the problem take steps to either move the HSM4 interrupt signal from GPIO 4 or the 1-Wire interface from GPIO 4.\nif the directory at /var/lib/zymbit or any of the files and/or subdirectories are corrupted or deleted, the HSM4 will fail to work. IMPORTANT: if this happens when the HSM4 is locked (i.e. Production Mode), the HSM4 can never be used again.\nQ: The LED blinks rapidly when booting, but eventually turns off. It doesn’t blink once or three times every 3 seconds as described. Expand for Answer A: This issue could be caused by the same issues described in the first question (Why does the LED continue to blink rapidly?). Additionally, this can be caused if a locked (Production Mode) HSM4 is moved to another Pi.\nQ: What do the different LED blinking patterns mean? Expand for Answer 1 second very rapid flash, 1 second off, 8 slow blinks This indicates interrupted communications. 1 second very rapid flash, 1 second off, 5 slow blinks This indicates a failure to communicate with ATECC. The most likely cause is the HSM4 is in Production Mode, tamper detect was set to self-destruct, and a tamper detect event caused the HSM4 to self-destruct. If tamper detect is not armed, this indicates a hardware problem. Constant rapid blinking (waiting for host to connect) This indicates that you HSM4 is operational but has not bound to the host. If the HSM4 continues to blink this pattern, it could mean that there is a problem with the host Pi or that the i2c is not configured or that the i2c and wake pins are not making contact. Once every 3 seconds This indicates that your HSM4 is working and running. Three rapid blinks every 3 seconds This indicates the HSM4 is in Production Mode and is working and running. Rapid blinking then LED off permanently This indicates the HSM4 is in Production Mode but cannot bind with the RPi / SD card pair. In Production Mode the binding with a particular Pi and SD card becomes permanent. Most likely cause for this is that the HSM4, the SD card, or the PI has been swapped out. Q: How do I set an alternative I2C address? Expand for Answer A: You can change the I2C address through our standard APIs:\nC: int zkSetI2CAddr ( zkCTX ctx, int addr) Python: set_i2c_address The I2C communication between the Zymkey and the Host is encrypted, but will not interfere with other devices on the same bus (assuming there is no address conflict).\nSee API Documentation\nQ: Why does my HSM4 fail to restart after cycling power? Expand for Answer A: HSM4 monitors the quality of 5V power coming into the host computer. If the voltage drops below a specified limit, even momentarily, then HSM4 will disable all security services to the host. This is a security feature to prevent power cycle and brown-own attacks. If you are powering a display, modem, or other power-hungry device from your Pi, then check the capacity and quality of your power supply. Learn more \u003e\nQ: Why is my HSM4 “invisible” to the i2c-tools suite? Expand for Answer A: Some people have become accustomed to using i2c-detect to do a first level check for correct installation and baseline functionality of i2c devices. However, these tools only really work if the i2c device communicates via a protocol that sits on top of i2c called SMBus or SMB (System Management Bus). Instead, HSM4 communicates to the host at a much more fundamental level, in part because the HSM4 protocol traffic is encrypted.\nYou can tell if you successfully installed it by observing the blue LED. If it is flashing once every 3 seconds, then binding completed. You can also use the systemctl command. It should say “active (running)”:\nsystemctl status zkifc\nQ: If the install fails, can I run it more than once? Expand for Answer A: Yes, you should have no problem running it multiple times if it were to fail.\nEncrypting Root File System Summary of steps Start with a blank USB device. USB storage should be twice the size of the SD card. The process for encrypting the SD card stops zkifc. The blue LED will flash rapidly during the encryption process. It will return to blinking once every 3 seconds when complete. The process will automatically do two reboots. Be patient. If the encryption process does not complete, it’s best to start fresh and try again. Q: How can I check if the system matches the default parameters? Expand for Answer A: lsblk will show you the partitions. Look for the name of your / partition (default is mmcblk0p2) and the USB device (default is sda). Example output:\nNAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT mmcblk0 179:0 0 14.9G 0 disk |-mmcblk0p1 179:1 0 256M 0 part /boot `-mmcblk0p2 179:2 0 14.6G 0 part / sda 8:0 0 32.0G 0 disk |_sda1 8:1 0 32.0G 0 part Q: How can I monitor the status after phase 1 reboot? Expand for Answer A: Once you get to the second phase and login, you can monitor progress with\njournalctl -fu cfg_SD_crfs\nThat will show you progress of the second half of the encryption process.\nQ: Can I re-run encryption with the same USB stick? Expand for Answer A: The script is designed to re-use information on the USB stick to encrypt a “golden” image in production on more than one device. If the file original_zk_root.tgz exists on the USB stick, it will use that file and skip the step of creating a whole new tarball of the rootfs. If you truly want to start over, start by reformatting/erasing your USB stick.\nQ: If my PI automounts the USB device, will that interfere with the process? Expand for Answer A: The script attempts to unmount the external device, but in some cricumstances the device may stay mounted and the process will fail. You will get a message either on your screen or in journalctl -fu cfg_SD_crfs during the second phase indicating the drive was already mounted. Unmount the drive and try again.\n# Check /dev/sda* mount points for devices mounted to /media/* lsblk # if mounted, unmount sudo umount /media* # re-run service sudo systemctl restart # monitor progress journalctl -fu cfg_SD_crfs Q: How can I confirm my file system is encrypted and protected? Expand for Answer A: Since zkifc is stopped during the process, the blue LED will flash rapidly until the whole process completes. Once both of the automautic reboots are completed, the blue LED will return to flashing once every 3 seconds.\nlsblk will show you that you now have a “cryptrfs” partition under your mmcblk0p2 (default)\ndf -h will also show “/dev/mapper/cryptrfs” for the “/” file system.\nIf your system reboots twice, the LED returns to flashing once every 3 seconds, and lsblk displays a “cryptrfs” partition, you can be confident your system is encrypted and protected.\nFor more help, see Zymbit’s Community Forum. Features Q: What curves are supported for Zymbit products? Expand for Answer Zymkey and HSM4: NIST P-256 and secp256r1\nHSM6: NIST P-256, secp256r1, secp256k1, X25519, ED25519\nQ: How do I use HSM6’s store_foreign_public_key function to store a Zymkey or HSM4 public key on HSM6? Expand for Answer A: The easiest way is to save the HSM4 key directly to a binary file, copy that file to the HSM6 and read in the binary file.\nHSM4 side:\n#!/usr/bin/python3 import zymkey # Get the public key from slot 0 and save it in a file pub_key_file = '/tmp/pub_key_slot0' slot = 0 key = zymkey.client.get_public_key(slot) with open(pub_key_file, \"wb\") as f: f.write(key) copy /tmp/pub_key_slot0 over to the HSM6 PI\nHSM6 side:\n#!/usr/bin/python3 import zymkey key_file = \"/tmp/pub_key_slot0\" key = open(key_file, \"rb\").read() # Store the key in the foreign key store foreign_slot = zymkey.client.store_foreign_public_key('secp256r1', key) Q: How can I reset the clock to the current timestamp? Expand for Answer A: The clock will sync to the current timestamp once the Pi has achieved NTP sync. This requires you to have access to the Internet.\nQ: How do I access the devices (RTC, accelerometer, crypto) on HSM4? Expand for Answer A: For Zymkey and HSMs, kernel drivers and libraries for all of the devices are included in the Zymkey software package via the APIs.\nQ: My GPG Key expired and I cannot access the Zymkey Repository. How do I update the Key? Expand for Answer A: You can update your existing key with the following command:\ncurl -L https://zk-sw-repo.s3.amazonaws.com/apt-zymkey-pubkey.gpg | sudo gpg --dearmor --yes -o /usr/share/keyrings/zymbit.gpg Q: Can the HSM4 detect if the SD card has been removed? Expand for Answer A: No, but perimeter detect can be configured to prevent access to the SD card. When a tamper event is detected, the HSM4 will, when properly configured via the API, destroy all critical key material and the root fs will fail to be decrypted upon boot.\nBattery \u0026 Power Questions Q: Should I use an external battery on my Zymkey or HSM? Expand for Answer A: The following table compares Zymkey and HSM operational modes while connected to Main Power, Battery Power, and No Power.\nThe battery is required to maintain the Real Time Clock and the perimeter detect circuits when the host power is removed. Without the battery, these two functions will not be active when the host power is removed.\nQ: What happens when the battery dies? How can I change the battery when it dies, without self-destructing my device? Expand for Answer A: If the battery dies and the host is not connected to power, some features will go out, such as Perimeter Detect and Real Time Clock. See the table below for more information.\nWith Zymkey and HSM4, if tamper detect is enabled and the battery dies or is removed, the device will self-destruct. This is an intentional security feature. If tamper detect is NOT enabled, you should connect the host device to power to change the battery.\nHSM6 has a battery monitoring feature to help the user prevent the battery from dying. If the battery dies, HSM6 users have the ability to choose whether the device should self-destruct or hold in reset mode until the battery is changed.\nKernel \u0026 Kernel Boot Questions Q: Can you tell the kernel not to run a shell? Expand for Answer A: Someone could easily replace the kernel and, while it is possible to configure initramfs to not permit the busybox shell to, that can be sidestepped as well. Even if you hack your own changes to the kernel to ignore the init option, someone could replace your kernel. Also, kernel updates would have to be done manually and the updates from the apt repo would have to be blacklisted.\nQ: Can you tell the kernel to ignore cmdline.txt? Expand for Answer A: There are many reasons why this is infeasible, but the main one is that, since the GPU initially functions as a bootloader processor during boot and since Broadcom has not made the GPU compiler publicly available as well as the source code for the bootloader, one cannot simply compile their own code that would ignore cmdline.txt.\nQ: Is it possible to encrypt the boot partition? Expand for Answer A: No because the GPU bootloader does not have encryption features implemented and, even in lieu of that, it does not know how to communicate with HSM4. The best solution, then, would be to implement an independent secure boot procedure. As mentioned above, we are currently working on adding this feature in a future product.\nProduction (“self-destruct”) Mode Questions Q: When using the perimeter-detect feature, does the “self-destruct” mode work (destroy all of its key material) even when the Lock Tab hasn’t been cut? Expand for Answer A: Self-destruct mode works only after the Lock Tab has been cut.\nQ: Is there a way to turn off “self-destruct” mode? Expand for Answer A: No, once turned on, “self-destruct” mode is permanent.\nQ: If my HSM4 does “self-destruct,” can I create new keys and reuse the hardware? Expand for Answer The SBC and SD card hardware will be reusable. Because the SD card contents are encrypted and the decryption key was destroyed, the data is lost. The HSM4 will not be reusable because the key slots will be destroyed. Q: If I cut the Lock-Tab on a HSM4, can I move that HSM4 to another Pi or change the SD card? Expand for Answer A: No. Cutting the Lock-Tab permanently binds that instance of HSM4 to the specific instances of host computer and SD card. This is a security feature to prevent credentials being moved from one host to another. DO NOT cut the Lock-Tab if you are still in development and expect to change the host or SD cards.\nQ: Will HSM4 still self-destruct, even when my SBC is powered off? Expand for Answer A: Yes, because HSM4 is battery powered. As long as the battery is sufficiently charged, it will still self-destruct.\nOther Q: Where can I learn about and/or pre-order future products? Expand for Answer A: Sign up for our new product email updates at the bottom of Zymbit’s homepage.\nQ: Which SBCs are compatible with HSM4? Expand for Answer Electrically, the Zymkey-I2C will interface to any single board computer using I2C. Check compatibility with your particular Linux distribution. Raspberry Pi 3, 3B+, 4, Zero RPi Compute Module 3, 4 Q: Does HSM4 work with Arduino? Expand for Answer A: We have no plans to release an Arduino shield version. While we love Arduinos and use them all the time, they generally don’t have enough resources to handle cryptographic operations at this level.\nQ: Does HSM4 work with BeagleBone? Expand for Answer A: Zymbit does not officially support the BeagleBoard platform at this time.\nQ: Which operating systems does HSM4 support? Expand for Answer Q: How much power does HSM4 consume? Expand for Answer HSM4-RPi (3.3V): idle approx. 1mA; max active \u003c 25mA with LED off, \u003c 35mA with LED on. HSM4-USB (5V): idle approx. 1.5mA; max active \u003c 40mA with LEDs off, \u003c 60mA with LEDs on. See Power Quality for more information.\n","categories":"","description":"","excerpt":" Troubleshooting Troubleshooting Checklist Before contacting Zymbit …","ref":"/troubleshooting/hsm4/","tags":"","title":"HSM4 FAQ \u0026 Troubleshooting"},{"body":" zbcli update Description Requires superuser privilege.\nUtility to perform Bootware updates; re-partitions and loads images into the Active, Backup or Both partitions\nUsage zbcli update [OPTIONS] Options: -f, --key-file \u003cKEY_FILE\u003e Public pem file verifying the update (software signed) -y Says `yes` to all prompts. This includes rebooting your system -n Do not the reboot the system when `yes` flag is enabled -h, --help Print help Examples sudo zbcli update The script will show your configuration for review and confirmation.\nAfter confirmation of the config parameters, the script will prompt for a reboot to complete the process.\nValidated bootware installation --------- Pi Module: Raspberry Pi 5 Operating System: Rpi-Bookworm Zymbit module: Zymkey Kernel: kernel_2712.img --------- Created '/etc/zymbit/zboot/update_artifacts/tmp' Found update configs ? Proceed with current configs? These can be modified through 'zbcli update-config' --------- Update endpoint /dev/sda1 Update name zymbit_bookworm64_pi5_1.2 Endpoint type LOCAL Partition layout A/B Update policy UPDATE_BOTH --------- (y/n) › yes You will need to supply a public key in order to verify the update image. The public key should correspond to the private key used for the image signing process. The key pairs can either be a software key file in PEM format, or a reference to a hardware key slot from the Zymbit HSM key store.\n? Enter public key file (Pem format) › pub_key.pem After verifying the contents of the zi image with your supplied public key, status of the process will be displayed and you will be asked if you would like to reboot now.\n✔ Enter public key file (Pem format) · pub_key.pem Mounted '/dev/sda1' to '/etc/zymbit/zboot/update_artifacts/tmp/.tmpUaPKTT' Found image tarball (/etc/zymbit/zboot/update_artifacts/tmp/.tmpUaPKTT/zymbit_bookworm64_pi5_1.2.zi) Unpacked '/etc/zymbit/zboot/update_artifacts/tmp/.tmpoPa4D2/file_deletions' Unpacked '/etc/zymbit/zboot/update_artifacts/tmp/.tmpoPa4D2/file_manifest' Unpacked '/etc/zymbit/zboot/update_artifacts/tmp/.tmpoPa4D2/signatures' Unpacked '/etc/zymbit/zboot/update_artifacts/tmp/.tmpoPa4D2/header.txt' Unpacked '/etc/zymbit/zboot/update_artifacts/tmp/.tmpoPa4D2/update_artifact.tar' Decoded header signature Decoded image signature Decoded manifest signature Decoded deletions signature Found header data Found image data Found manifest data Found file deletions data Verified header signature Verified image signature Verified manifest signature Verified file deletions signature Modified zbconfig 'public_key' Modified zbconfig 'new_update_needed' Modified zbconfig 'root_a' Modified zbconfig 'root_b' Modified zbconfig 'root_dev' Modified zbconfig 'update_with_new_image' Modified zbconfig 'kernel_filename' ? Scheduled update for the next reboot. Reboot now? (y/n) › yes If you are ready to reboot, answer yes to start the update process.\nBootware Update Process The Bootware Update process will now take place.\nWarning The initial configuration process can take over an hour to complete, depending on partitioning and the size of the image(s). The process can be completed via ssh, but an HDMI console is helpful to follow the process. During the process, the blue LED will be OFF. On the console, you will see:\nBootware will load and decrypt the Zymbit hardened uboot and zboot. A message that an update will take place will be displayed. The A/B partitions and the DATA partition will be configured and setup for LUKS encryption protected by the Zymbit SCM or HSM. NOTE: This process will use fdisk to repartition. fdisk will present warnings that the disk is in use, which can be ignored. It will take some time to unpack the image into the A/B root partitions depending on the size of the image. Once it’s done unpacking the image to the A and B partitions, it will boot into the updated ACTIVE partition. You can use lsblk to examine the partitions. For instance, lsblk NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINTS mmcblk0 179:0 0 29.7G 0 disk ├─mmcblk0p1 179:1 0 512M 0 part /boot/firmware ├─mmcblk0p2 179:2 0 14.4G 0 part │ └─cryptrfs_A 254:0 0 14.3G 0 crypt / ├─mmcblk0p3 179:3 0 14.4G 0 part └─mmcblk0p4 179:4 0 512M 0 part └─cryptrfs_DATA 254:1 0 496M 0 crypt where mmcblk0p2 is partition A, mmcblk0p3 is partition B, and mmcblk0p4 is the shared data partition.\nIf the ACTIVE partition is partition A, you will see cryptrfs_A (encrypted partition A) mounted at /. If the ACTIVE partition is partition B, you will see cryptrfs_B mounted at /.\nOptions to run non-interactively The update process can be run non-interactively by providing the the public key for verification and the -y option on the command line. Note: This will carry out an update and a reboot with no confirmation later in the process.\nsudo zbcli update -f \u003cmy_pub_key_file.pem\u003e -y To run non-interactively up to the point of reboot confirmation, include the -n along with -y.\nsudo zbcli update -y -n See Also zbcli update-config\n","categories":"","description":"Schedules Bootware to perform device update on the next reboot","excerpt":"Schedules Bootware to perform device update on the next reboot","ref":"/bootware/zbcli/update/","tags":"","title":"zbcli update"},{"body":" ","categories":"","description":"","excerpt":" ","ref":"/bootware/archive/bootware-one-zero-general/features/","tags":"","title":"Features and Implementation"},{"body":"","categories":"","description":"Additional information on Bootware features and implementation","excerpt":"Additional information on Bootware features and implementation","ref":"/bootware/features/","tags":"","title":"Features and Implementation"},{"body":" zb-update Description Requires superuser privilege.\nUtility to perform Bootware Updates; re-partitions and loads images into the Active, Backup or Both partitions\nUsage zb-update [ [-k \u003ckey-slot\u003e] [--key-file=\u003cfilepath\u003e] [-w] | [-y] [-r] ] Flags Description --------------------------------------------------------------------------------------------------------------------- -k, --key-slot [int] Key-slot of HSM for verifying the update. Uses HSM. -w, --not-foreign Key slot is not a foreign key slot -f, --key-file [str] Public pem file verifying the update. Uses software. -y Say yes to all prompts -r Perform rollback swap between active and non-active root partitions --------------------------------------------------------------------------------------------------------------------- Examples sudo zb-update The script will show your configuration for review and confirmation, or give you the option to change the configuration. This method can be used as an alternative to using the Wizard.\nAfter correction and confirmation of the config partameters, the script will prompt for a reboot to complete the process.\nBootware Update Process The Bootware Update process will now take place.\nWarning The initial configuration process can take over an hour to complete, depending on partitioning and the size of the image(s). The process can be completed via ssh, but an HDMI console is helpful to follow the process. During the process, the blue LED will be OFF. On the console, you will see:\n“Loading: Encrypted zboot please wait…” message, which takes around 4-5min. The A/B partitions will be configured and setup for LUKS encryption protected by the Zymbit SCM It will then take a few minutes to get/unpack tarballs from the image. It will take some time to unpack the image into the A/B root partitions depending on the size of the image. Once it’s done unpacking the image to the A and B partitions, it will boot into the updated ACTIVE partition. You can use lsblk to examine the partitions. Force Failover (Change Active/Backup partitions) A failover from Active to Backup is done with the -r option to zb-update\nsudo zb-update -r See Also zb-wizard\n","categories":"","description":"","excerpt":" zb-update Description Requires superuser privilege.\nUtility to …","ref":"/bootware/archive/bootware-one-zero-general/utilities/zbupdate/","tags":"","title":"Zymbit Bootware Update Utility"},{"body":"3D Step Model SCM 3D model\n2D Drawing SCM Rev B1 Mechanical/Connectors ","categories":"","description":"","excerpt":"3D Step Model SCM 3D model\n2D Drawing SCM Rev B1 Mechanical/Connectors …","ref":"/reference/cad/scm/","tags":"","title":"Secure Compute Module (SCM)"},{"body":"","categories":"","description":"","excerpt":"","ref":"/getting-started/hsm6/","tags":"","title":"HSM6"},{"body":" Troubleshooting Troubleshooting Checklist Before contacting Zymbit with troubleshooting related questions, please read through the following troubleshooting checklist.\nPower supply. Most of the problems we see are from a poor power source. Start with a good power supply from the PI foundation or Canakit, not a phone charger. The recommended power for the PI4 is 5V and 3 amps. For a PI5, the recommended power supply should provide 5V, 5 amps. I2C enabled. Double check that you have enabled the I2C bus. An easy way to check is “ls -l /dev/i2c-1”. If /dev/i2c-1 exists, the I2C bus is enabled. apt update and upgrade. Be sure that your software is up to date. Installation. The curl script will reboot your system once completed. After the reboot, the blue LED on your Zymbit device should blink once every 3 seconds. You must get to this step before proceeding to encryption, etc. If your issue is not related to any of the above list, read through the FAQ below to see if your issue is answered. If you still do not see a solution to your problem, reach out on our Community Forum. Thank you!\nQ: Why does the LED continue to blink rapidly? It never blinks with the described pattern of once (in Development mode) or three times (in Production mode) every three seconds. Expand for Answer A: Check the following:\nCheck that the Raspberry Pi power is sufficient. The red LED on most Raspberry Pi models indicates if the Pi is being powered adequately. If it is not lit at all or flashes intermittently, try a different power supply or a different USB cable.\nMake sure that you have enabled i2c support using raspi-config BEFORE your install the software. Also, when you enable i2c communications be sure to follow the enable-disable-enable sequence.\nIf i2c support has been enabled correctly and the HSM6 LED is still rapidly blinking, check proper physical installation of the HSM6 as detailed in this “Getting Started” guide.\nHSM6 uses GPIO header pins 3 and 5 for i2c communications and pin 7 as an interrupt signal to the Pi. Pin 7 should preferably be dedicated exclusively to HSM6. Other devices may share the i2c bus with HSM6, but there may still be address conflicts. By default, HSM6 uses slave address 0x30. If the address conflict cannot be resolved on the other i2c devices, there is a way of changing the i2c address through an API call. Using this application, the HSM6 address can be changed anywhere in the ranges of 0x30-0x37 or 0x60-0x67.\nExpand for API information to change i2c address Python: set_i2c_address\nC: int zkSetI2CAddr ( zkCTX ctx, int addr)\nSee API Documentation\nOftentimes the 1-Wire interface relies on pin 7 (GPIO 4) for communication. If the 1-Wire interface is enabled, try disabling through raspi-config. If that resolves the problem take steps to either move the HSM6 interrupt signal from GPIO 4 or the 1-Wire interface from GPIO 4.\nif the directory at /var/lib/zymbit or any of the files and/or subdirectories are corrupted or deleted, the HSM6 will fail to work. IMPORTANT: if this happens when the HSM6 is locked (i.e. Production Mode), the HSM6 can never be used again.\nQ: The LED blinks rapidly when booting, but eventually turns off. It doesn’t blink once or three times every 3 seconds as described. Expand for Answer A: This issue could be caused by the same issues described in the first question (Why does the LED continue to blink rapidly?). Additionally, this can be caused if a locked (Production Mode) HSM6 is moved to another Pi.\nQ: What do the different LED blinking patterns mean? Expand for Answer 1 second very rapid flash, 1 second off, 8 slow blinks This indicates interrupted communications. 1 second very rapid flash, 1 second off, 5 slow blinks This indicates a failure to communicate with ATECC. The most likely cause is the HSM6 is in Production Mode, tamper detect was set to self-destruct, and a tamper detect event caused the HSM6 to self-destruct. If tamper detect is not armed, this indicates a hardware problem. Constant rapid blinking (waiting for host to connect) This indicates that you HSM6 is operational but has not bound to the host. If the HSM6 continues to blink this pattern, it could mean that there is a problem with the host Pi or that the i2c is not configured or that the i2c and wake pins are not making contact. Once every 3 seconds This indicates that your HSM6 is working and running. Three rapid blinks every 3 seconds This indicates the HSM6 is in Production Mode and is working and running. Rapid blinking then LED off permanently This indicates the HSM6 is in Production Mode but cannot bind with the RPi / SD card pair. In Production Mode the binding with a particular Pi and SD card becomes permanent. Most likely cause for this is that the HSM6, the SD card, or the PI has been swapped out. Q: How do I set an alternative I2C address? Expand for Answer A: You can change the I2C address through our standard APIs:\nC: int zkSetI2CAddr ( zkCTX ctx, int addr) Python: set_i2c_address The I2C communication between the Zymkey and the Host is encrypted, but will not interfere with other devices on the same bus (assuming there is no address conflict).\nSee API Documentation\nQ: Why does my HSM6 fail to restart after cycling power? Expand for Answer A: HSM6 monitors the quality of 5V power coming into the host computer. If the voltage drops below a specified limit, even momentarily, then HSM6 will disable all security services to the host. This is a security feature to prevent power cycle and brown-own attacks. If you are powering a display, modem, or other power-hungry device from your Pi, then check the capacity and quality of your power supply. Learn more \u003e\nQ: Why is my HSM6 “invisible” to the i2c-tools suite? Expand for Answer A: Some people have become accustomed to using i2c-detect to do a first level check for correct installation and baseline functionality of i2c devices. However, these tools only really work if the i2c device communicates via a protocol that sits on top of i2c called SMBus or SMB (System Management Bus). Instead, HSM6 communicates to the host at a much more fundamental level, in part because the HSM6 protocol traffic is encrypted.\nYou can tell if you successfully installed it by observing the blue LED. If it is flashing once every 3 seconds, then binding completed. You can also use the systemctl command. It should say “active (running)”:\nsystemctl status zkifc\nQ: If the install fails, can I run it more than once? Expand for Answer A: Yes, you should have no problem running it multiple times if it were to fail.\nEncrypting Root File System Summary of steps Start with a blank USB device. USB storage should be twice the size of the SD card. The process for encrypting the SD card stops zkifc. The blue LED will flash rapidly during the encryption process. It will return to blinking once every 3 seconds when complete. The process will automatically do two reboots. Be patient. If the encryption process does not complete, it’s best to start fresh and try again. Q: How can I check if the system matches the default parameters? Expand for Answer A: lsblk will show you the partitions. Look for the name of your / partition (default is mmcblk0p2) and the USB device (default is sda). Example output:\nNAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT mmcblk0 179:0 0 14.9G 0 disk |-mmcblk0p1 179:1 0 256M 0 part /boot `-mmcblk0p2 179:2 0 14.6G 0 part / sda 8:0 0 32.0G 0 disk |_sda1 8:1 0 32.0G 0 part Q: How can I monitor the status after phase 1 reboot? Expand for Answer A: Once you get to the second phase and login, you can monitor progress with\njournalctl -fu cfg_SD_crfs\nThat will show you progress of the second half of the encryption process.\nQ: Can I re-run encryption with the same USB stick? Expand for Answer A: The script is designed to re-use information on the USB stick to encrypt a “golden” image in production on more than one device. If the file original_zk_root.tgz exists on the USB stick, it will use that file and skip the step of creating a whole new tarball of the rootfs. If you truly want to start over, start by reformatting/erasing your USB stick.\nQ: If my PI automounts the USB device, will that interfere with the process? Expand for Answer A: The script attempts to unmount the external device, but in some cricumstances the device may stay mounted and the process will fail. You will get a message either on your screen or in journalctl -fu cfg_SD_crfs during the second phase indicating the drive was already mounted. Unmount the drive and try again.\n# Check /dev/sda* mount points for devices mounted to /media/* lsblk # if mounted, unmount sudo umount /media* # re-run service sudo systemctl restart # monitor progress journalctl -fu cfg_SD_crfs Q: How can I confirm my file system is encrypted and protected? Expand for Answer A: Since zkifc is stopped during the process, the blue LED will flash rapidly until the whole process completes. Once both of the automautic reboots are completed, the blue LED will return to flashing once every 3 seconds.\nlsblk will show you that you now have a “cryptrfs” partition under your mmcblk0p2 (default)\ndf -h will also show “/dev/mapper/cryptrfs” for the “/” file system.\nIf your system reboots twice, the LED returns to flashing once every 3 seconds, and lsblk displays a “cryptrfs” partition, you can be confident your system is encrypted and protected.\nFor more help, see Zymbit’s Community Forum. Features Q: What curves are supported for Zymbit products? Expand for Answer Zymkey and HSM4: NIST P-256 and secp256r1\nHSM6: NIST P-256, secp256r1, secp256k1, X25519, ED25519\nQ: How do I use HSM6’s store_foreign_public_key function to store a Zymkey or HSM4 public key on HSM6? Expand for Answer A: The easiest way is to save the HSM4 key directly to a binary file, copy that file to the HSM6 and read in the binary file.\nHSM4 side:\n#!/usr/bin/python3 import zymkey # Get the public key from slot 0 and save it in a file pub_key_file = '/tmp/pub_key_slot0' slot = 0 key = zymkey.client.get_public_key(slot) with open(pub_key_file, \"wb\") as f: f.write(key) copy /tmp/pub_key_slot0 over to the HSM6 PI\nHSM6 side:\n#!/usr/bin/python3 import zymkey key_file = \"/tmp/pub_key_slot0\" key = open(key_file, \"rb\").read() # Store the key in the foreign key store foreign_slot = zymkey.client.store_foreign_public_key('secp256r1', key) Q: How can I reset the clock to the current timestamp? Expand for Answer A: The clock will sync to the current timestamp once the Pi has achieved NTP sync. This requires you to have access to the Internet.\nQ: How do I access the devices (RTC, accelerometer, crypto) on HSM6? Expand for Answer A: For Zymkey and HSMs, kernel drivers and libraries for all of the devices are included in the Zymkey software package via the APIs.\nQ: My GPG Key expired and I cannot access the Zymkey Repository. How do I update the Key? Expand for Answer A: You can update your existing key with the following command:\ncurl -L https://zk-sw-repo.s3.amazonaws.com/apt-zymkey-pubkey.gpg | sudo gpg --dearmor --yes -o /usr/share/keyrings/zymbit.gpg Q: Can the HSM6 detect if the SD card has been removed? Expand for Answer A: No, but perimeter detect can be configured to prevent access to the SD card. When a tamper event is detected, the HSM6 will, when properly configured via the API, destroy all critical key material and the root fs will fail to be decrypted upon boot.\nBattery \u0026 Power Questions Q: Should I use an external battery on my Zymkey or HSM? Expand for Answer A: The following table compares Zymkey and HSM operational modes while connected to Main Power, Battery Power, and No Power.\nThe battery is required to maintain the Real Time Clock and the perimeter detect circuits when the host power is removed. Without the battery, these two functions will not be active when the host power is removed.\nQ: What happens when the battery dies? How can I change the battery when it dies, without self-destructing my device? Expand for Answer A: If the battery dies and the host is not connected to power, some features will go out, such as Perimeter Detect and Real Time Clock. See the table below for more information.\nWith Zymkey and HSM4, if tamper detect is enabled and the battery dies or is removed, the device will self-destruct. This is an intentional security feature. If tamper detect is NOT enabled, you should connect the host device to power to change the battery.\nHSM6 has a battery monitoring feature to help the user prevent the battery from dying. If the battery dies, HSM6 users have the ability to choose whether the device should self-destruct or hold in reset mode until the battery is changed.\nKernel \u0026 Kernel Boot Questions Q: Can you tell the kernel not to run a shell? Expand for Answer A: Someone could easily replace the kernel and, while it is possible to configure initramfs to not permit the busybox shell to, that can be sidestepped as well. Even if you hack your own changes to the kernel to ignore the init option, someone could replace your kernel. Also, kernel updates would have to be done manually and the updates from the apt repo would have to be blacklisted.\nQ: Can you tell the kernel to ignore cmdline.txt? Expand for Answer A: There are many reasons why this is infeasible, but the main one is that, since the GPU initially functions as a bootloader processor during boot and since Broadcom has not made the GPU compiler publicly available as well as the source code for the bootloader, one cannot simply compile their own code that would ignore cmdline.txt.\nQ: Is it possible to encrypt the boot partition? Expand for Answer A: No because the GPU bootloader does not have encryption features implemented and, even in lieu of that, it does not know how to communicate with HSM6. The best solution, then, would be to implement an independent secure boot procedure. As mentioned above, we are currently working on adding this feature in a future product.\nProduction (“self-destruct”) Mode Questions Q: When using the perimeter-detect feature, does the “self-destruct” mode work (destroy all of its key material) even when the Lock Tab hasn’t been cut? Expand for Answer A: Self-destruct mode works only after the Lock Tab has been cut.\nQ: Is there a way to turn off “self-destruct” mode? Expand for Answer A: No, once turned on, “self-destruct” mode is permanent.\nQ: If my HSM6 does “self-destruct,” can I create new keys and reuse the hardware? Expand for Answer The SBC and SD card hardware will be reusable. Because the SD card contents are encrypted and the decryption key was destroyed, the data is lost. The HSM6 will not be reusable because the key slots will be destroyed. Q: If I cut the Lock-Tab on a HSM6, can I move that HSM6 to another Pi or change the SD card? Expand for Answer A: No. Cutting the Lock-Tab permanently binds that instance of HSM6 to the specific instances of host computer and SD card. This is a security feature to prevent credentials being moved from one host to another. DO NOT cut the Lock-Tab if you are still in development and expect to change the host or SD cards.\nQ: Will HSM6 still self-destruct, even when my SBC is powered off? Expand for Answer A: Yes, because HSM6 is battery powered. As long as the battery is sufficiently charged, it will still self-destruct.\nOther Q: Where can I learn about and/or pre-order future products? Expand for Answer A: Sign up for our new product email updates at the bottom of Zymbit’s homepage.\nQ: Which SBCs are compatible with HSM6? Expand for Answer Electrically, the Zymkey-I2C will interface to any single board computer using I2C. Check compatibility with your particular Linux distribution. Raspberry Pi 3, 3B+, 4, Zero RPi Compute Module 3, 4 Q: Does HSM6 work with Arduino? Expand for Answer A: We have no plans to release an Arduino shield version. While we love Arduinos and use them all the time, they generally don’t have enough resources to handle cryptographic operations at this level.\nQ: Does HSM6 work with BeagleBone? Expand for Answer A: Zymbit does not officially support the BeagleBoard platform at this time.\nQ: Which operating systems does HSM6 support? Expand for Answer Q: How much power does HSM6 consume? Expand for Answer HSM6-RPi (3.3V): idle approx. 1mA; max active \u003c 25mA with LED off, \u003c 35mA with LED on. HSM6-USB (5V): idle approx. 1.5mA; max active \u003c 40mA with LEDs off, \u003c 60mA with LEDs on. See Power Quality for more information.\n","categories":"","description":"","excerpt":" Troubleshooting Troubleshooting Checklist Before contacting Zymbit …","ref":"/troubleshooting/hsm6/","tags":"","title":"HSM6 FAQ \u0026 Troubleshooting"},{"body":"","categories":"","description":"","excerpt":"","ref":"/reference/product-briefs/mfg-app/","tags":"","title":"Manufacturing Appliance"},{"body":"Applicable Products The information included in this post applies to all Zymbit security modules.\nPower \u0026 Security Poor power quality can result in unstable and potentially insecure operation of your single board computer (SBC), depending upon it’s design, operating conditions and related system and power components. In this post we will outline the important factors of power quality management and explain how Zymkey manages the security of your device when power quality is poor.\nPower Quality Management Unlike software which is digital, deterministic and repeatable, power is analog and subject to the laws of physics and electrical engineering. Fortunately, with good design and a basic understanding, power quality can also be deterministic and repeatable. We’ll use the Raspberry Pi 3 to explain the basic concepts.\nSafe operating zone The Raspberry Pi 3 is designed to operate of a 5V (nominal) power supply, delivering 2A or more. (more on current rating later). This voltage is widely used in USB and mobile devices, making it easy to buy a power supply (and more on that later). In reality, power supplies have a tolerance on the output voltage, typically ±5%, which means the output voltage can range from a low of 4.75V to a high of 5.25V. The Raspberry Pi is designed to operate reliably in this Safe Operating Zone.\nBrown out zone - symptoms If the supply voltage dips below the safe operating zone then this can put the SBC into a less determinstic state - commonly known as “brown out” zone. Symptoms of brown outs range from irritating to catostrophic, depending upon where in the brown zone your SBC is operating:\nApparently Benign BUT Significant\nRED PWR LED on RPI 3 is off or flickering Power Warning - thunderbolt on console GUI IMPORTANT: The low voltage warning system is designed to protect your application. Use it ! It will save you time and money in debugging erratic system behavior and potentially expensive field failures and recalls.\nErratic Behavior\nGPIO digital and serial bus signals behave inconsistently USB peripherals behave inconsistently Catostrophic Failures\nIrregular cycling through reset and reboot, at which time vulnerabilites in the boot sequence or memory write cycles might be exposed (more in a later post).\nRegular cycling through reset and reboot - this can happen when your application program calls up more resources that consume more power at regular times. For example turning on additional cores for intense image processing, or turning on a USB peripheral or LCD display.\nSD card failures, corrupted SD card contents\nWhy Good Power Design Matters A well designed SBC will include elements of power management that monitor what is happening to the input power supply using a layer of hardware protection and supervision. In the case of the Raspberry Pi 3, there is a voltage monitor circuit that triggers a ‘Low Voltage Warning’ event when the supply voltage dips below 4.63V ±0.07V. This Low Voltage event is used to warn your software application of a potential loss of power and perhaps initiate an orderly shutdown sequence before a hard reset of the CPU occurs. If a hard reset does occur it will literally force the hardware to reset giving no time to store data or program cached in memory. In the case of the Pi, a hardware reset occurs at ~3.2V.\nSecure Power Zone - Zymkey Power Quality Monitor Zymkey includes a similar power monitoring system although it’s purpose is slightly different: it’s purpose is to prevent access to cryptographic keys during unstable power conditions (resulting from an intentional power vector attack, or unintentional system failure).\nIn the event of poor power quality the Zymkey instantaneosly shuts down access to the security API and communication channels and retreats into sleep mode (no sleep mode on Zymkey 4i lite). In sleep mode the Zymkey continues to monitor the quality of the 5V power rail and when conditions have stabilized it reactivates the security API and communicaiton channels.\nOther Considerations Static \u0026 Dynamic Power Loads Most power supplies are simply specified in terms of Voltage and Current Ratings. Better ones will specify the output voltage at different current outputs. The ratings are helpful, but not enough to determine if you have a suitable power supply that will operate reliably over the long term under different system load conditions.\nReal systems include devices that turn on and off, sometimes quickly (eg LCD switched from black to white, or multiple I/O’s turning on simultaneously, or USB powered HDD spining up). In these situations, a device switching on will create a dynamic (quickly changing) load on the power supply which can cause a momentary dip in the voltage as it trys to deliver the required surge current.\nAverage power supplies often don’t have good dynamic load response and can dip momentarilly or intermittently below a recommended operating voltage (4.63V in the case of the RPi). Good quality power supplies have a better dynamic performance and can respond very quickly to changes in loads.\nQUESTIONS? Is my power supply good enough ? Don’t be in denial. Developers unfamiliar with embedded hardware may not have the necessary test equipment or experience to determine the quality of their power supply. But denying there might be a problem does not make it go away! So here are a few tips when checking power quality:\nA standard multimeter will NOT give you a good indication of power quality: most take average readings that filter out (not see) any potentially harmful transients or AC components.\nMonitor the power rail with an oscilloscope, during static and dynamic loads that you would expect to see when your product is deployed.\nThankfully the designers of Raspberry Pi have provided two very helpful diagnostic tools: A Red Power LED and a Low_Pwr warning symbol (thunderbolt icon) on the user display.\nIf the Red Power LED is not illuminated this means the supply voltage is inadequate, falling below 4.63V. (The newer Pi(s) have a well engineered power circuit, and may continue to function even if the input voltage is below spec; the same may not be true of peripherals). The GUI had an rainbow indicator (replaced by a lightning bolt) which comes up in the top right if the voltage is inadequate. This has a 3 second timer, and may display even if the LED appears to be lit. Check out the Raspberry Pi Stack Exchange for a more complete description of the Pi power system.\nCan I disable Zymkey power quality monitor? No, not for standard products. This is an intentional design feature that protects the security of your critical keys and intraboard communications. If your system requires a different behaviour then please Contact Zymbit engineering services.\nUseful References Raspberry Pi 3 schematic with power supply details ","categories":"","description":"","excerpt":"Applicable Products The information included in this post applies to …","ref":"/reference/power-quality/","tags":"","title":"Power Quality Considerations"},{"body":" Troubleshooting tips and FAQ Modifications to SCM image from Standard Raspberry Pi OS Lite The SCM ships with a pre-installed with the following options for Operating System:\nRaspberry Pi OS Lite (bookworm 64bit) Raspberry Pi OS Lite (bullseye 64bit) Ubuntu Server LTS 22.04 (jammy 64bit) Notice The pre-installed image is encrypted and cannot be replaced via rpiboot. Once Bootware is installed, Bootware can install new images based off Bookworm, Bullseye or Jammy in the Zymbit zi image format. See the Getting Started section and the zbcli update tool.\nImportant: The CM4/SCM firmware must include bootloader version 2023/01/11 or later in order to work with Ubuntu 22.04. The version can be verified with the vcgencmd bootloader_version command. The firmware is not field upgradeable. If you have a CM4/SCM with an earlier version of the bootloader and need to run Ubuntu 22.04, please contact support@zymbit.com.\nPrecautions HTTPS endpoints are limited to a zi image of approximately 6GB. The zi images are compressed, so this is not normally a limitation with A/B configurations. If you have zi imagest larger tha 6MB, download the image to a local device with 3x the image size space and use the local device endpoint.\nImportant boot files to not delete.\nBoot.scr zboot.enc u-boot.bin config.txt [After bootware update] usr-kernel.enc [Before bootware] cmdline.txt [Before bootware] kernel8.img for rpiOS and vmlinuz for ubuntu The /boot filesystem should be partitioned for 512MB of space or more. Our default configuration as shipped uses a /boot partition of 512MB. Ubuntu in particular creates backups of all files on updates that may exceed free space with Bootware.\nIn config.txt, otg_mode=1 cannot be set. DWC2 needs to be enabled. This is set at our factory and by bootware (and is the default with ubuntu), but if changed, the system will not boot.\nNon Bootware: Ubuntu requires the initrd.img on the system to boot up. Be wary of replacing this file or removing it.\nBe cautious around the policies set in the supervised boot and the files put in the manifest. This follows hardware not images. This also applies to the other tamper policies.\nIssues Fixed Issue #145: Fixed in Bootware 1.2: Switching OS with Zymkey does not properly set GPIO WAKE PIN. For instance, if you install on Bookworm, the WAKE PIN is set at installation time to 516. If you then load a bullseye zi, bullseye with older kernels wants the WAKE PIN at 4. Bootware needs to take this into account. Workaround is to setup your Zymkey with the operating system you intend to use and create your Bootware zi image within that OS.\nIssue #147: Bootware: Needs to identify the kernel file to be loaded for custom kernels named something other than kernel8.img or vmlinuz. Needed for supporting custom kernel versions. Workaround is to copy or link your custom kernel to either kernel8.img for Raspberry Pi based OS, or vmlinuz for Ubuntu based OS.\nChanges to our standard images The table below summarizes changes made to the standard image coinciding with the release of Bootware 1.2.\nDefault As Shipped Boot partition of 256MB 2x Boot partition size - 512MB SSH optionally enabled SSH with password allowed Hostname is raspberrypi Hostname changed to zymbit-dev Default user of pi Default user is zymbit. User pi removed. Password is set to zymbit ","categories":"","description":"Collection of Bootware troubleshooting tips and FAQ items","excerpt":"Collection of Bootware troubleshooting tips and FAQ items","ref":"/bootware/troubleshooting/","tags":"","title":"Troubleshooting and FAQ"},{"body":" zbcli rollback-swap Description Requires superuser privilege.\nPerforms rollback swap between active and non-active root partitions.\nUsage zbcli rollback-swap Options: -h, --help Print help zbcli rollback-swap provides a convenient method to manually swap between the active and non-active root partitions.\nExamples Use lsblk to see that the ACTIVE root partition (/) is mounted at /dev/mmcblk0p2 -\u003e cryptrfs_A. Only the ACTIVE partition mount point will show up.\nlsblk NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINTS sda 8:0 1 57.3G 0 disk └─sda1 8:1 1 57.3G 0 part mmcblk0 179:0 0 29.7G 0 disk ├─mmcblk0p1 179:1 0 512M 0 part /boot/firmware ├─mmcblk0p2 179:2 0 14.4G 0 part │ └─cryptrfs_A 254:0 0 14.3G 0 crypt / ├─mmcblk0p3 179:3 0 14.4G 0 part └─mmcblk0p4 179:4 0 512M 0 part └─cryptrfs_DATA 254:1 0 496M 0 crypt Now run zbcli rollback-swap. Confirm reboot.\nsudo zbcli rollback-swap Validated bootware installation --------- Pi Module: Raspberry Pi 5 Operating System: Rpi-Bookworm Zymbit module: Zymkey Kernel: kernel_2712.img --------- ? Confirm swap active and non-active root partitions? This will reboot the device. (y/n) › yes During the boot, Bootware will display an INFO message that it is Executing a Rollback. After the reboot completes, look at the new mount points. The ACTIVE root (/) partition should now be mounted at /dev/mmcblk0p3 -\u003e cryptrfs_B.\nlsblk NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINTS sda 8:0 1 57.3G 0 disk └─sda1 8:1 1 57.3G 0 part mmcblk0 179:0 0 29.7G 0 disk ├─mmcblk0p1 179:1 0 512M 0 part /boot/firmware ├─mmcblk0p2 179:2 0 14.4G 0 part ├─mmcblk0p3 179:3 0 14.4G 0 part │ └─cryptrfs_B 254:0 0 14.3G 0 crypt / └─mmcblk0p4 179:4 0 512M 0 part └─cryptrfs_DATA 254:1 0 496M 0 crypt See Also zbcli update\n","categories":"","description":"Performs rollback swap between active and backup root partitions","excerpt":"Performs rollback swap between active and backup root partitions","ref":"/bootware/zbcli/rollback-swap/","tags":"","title":"zbcli rollback-swap"},{"body":" Troubleshooting tips and FAQ Modifications from Standard Raspberry Pi OS Lite The SCM ships with a pre-installed with the following options for Operating System:\nRaspberry Pi OS Lite (bookworm 64bit) Raspberry Pi OS Lite (bullseye 64bit) Ubuntu Server LTS 22.04 (jammy 64bit) Notice The pre-installed image is encrypted and cannot be replaced via rpiboot. Once Bootware is installed, Bootware can install new images based off Bullseye or Jammy in the Zymbit zi image format. See the Getting Started section and the zb-update tool.\nImportant: The CM4/SCM firmware must include bootloader version 2023/01/11 or later in order to work with Ubuntu 22.04. The version can be verified with the vcgencmd bootloader_version command. The firmware is not field upgradeable. If you have a CM4/SCM with an earlier version of the bootloader and need to run Ubuntu 22.04, please contact support@zymbit.com.\nPrecautions HTTPS endpoints are limited to a zi image of approximately 6GB. The zi images are compressed, so this is not normally a limitation with A/B configurations. If you have zi imagest larger tha 6MB, download the image to a local device with 3x the image size space and use the local device endpoint.\nImportant boot files to not delete.\nBoot.scr zboot.enc u-boot.bin config.txt [After bootware update] usr-kernel.enc [Before bootware] cmdline.txt [Before bootware] kernel8.img for rpiOS and vmlinuz for ubuntu The /boot filesystem should be partitioned for 512MB of space or more. Our default configuration as shipped uses a /boot partition of 512MB. Ubuntu in particular creates backups of all files on updates that may exceed free space with Bootware.\nIn config.txt, otg_mode=1 can’t be set. DWC2 needs to be enabled. This is set at our factory and by bootware (and is the default with ubuntu), but if changed, the system will not boot.\nNon Bootware: Ubuntu requires the initrd.img on their system to boot up. Be wary of replacing this file or removing it\nBe cautious around the policies set in the supervised boot and the files put in the manifest. This follows hardware not images. This also applies to the other tamper policies.\nKnown Issues Issue #145: Bootware 1.1: Switching OS with Zymkey does not properly set GPIO WAKE PIN. For instance, if you install on Bookworm, the WAKE PIN is set at installation time to 516. If you then load a bullseye zi, bullseye with older kernels wants the WAKE PIN at 4. Bootware needs to take this into account. Workaround is to setup your Zymkey with the operating system you intend to use and create your Bootware zi image within that OS.\nIssue #147: Bootware: Needs to identify the kernel file to be loaded for custom kernels named something other than kernel8.img or vmlinuz. Needed for supporting custom kernel versions. Workaround is to copy or link your custom kernel to either kernel8.img for Raspberry Pi based OS, or vmlinuz for Ubuntu based OS.\nChanges to our standard images The table below summarizes changes made to the standard image.\nDefault As Shipped Boot partition of 256MB 2x Boot partition size - 512MB Console login allowed Disabled SSH optionally enabled SSH with password allowed Hostname is raspberrypi Hostname changed to zymbit-dev Default user of pi Default user is zymbit. User pi removed. Passwd set to zymbit ","categories":"","description":"","excerpt":" Troubleshooting tips and FAQ Modifications from Standard Raspberry Pi …","ref":"/bootware/archive/bootware-one-zero-general/troubleshooting/","tags":"","title":"Troubleshooting and FAQ"},{"body":" zb-manifest Description Requires superuser privilege.\nUtility to perform Bootware Overlay Manifest Updates. Overlay images provide a way to selectively add and delete files or directories from your deployed images.\nUsage zb-manifest [-a \u003cfile_path\u003e ] | [-r \u003cfile_path\u003e ] | [-d \u003cfile_path\u003e ] | [-p] [-c] Flags Description -------------------------------------------------------------------------------------------------------- -a, --add Add file or directory to update manifest -r, --remove Remove file or directory from update manifest and deletion list -d, --delete Add file or directory to update deletion list -c, --clear Clear all entries in the manifest and deletions list -p, --print Print out the file manifest for additions and deletions -------------------------------------------------------------------------------------------------------- More information See Overlay updates for more information. zb-manifest will need a key. The key can either be software-based or hardware-based. See Signing/Verifying Images for more information on keys.\n","categories":"","description":"","excerpt":" zb-manifest Description Requires superuser privilege.\nUtility to …","ref":"/bootware/archive/bootware-one-zero-general/utilities/zbmanifest/","tags":"","title":"Zymbit Bootware Overlay Manifest Utility"},{"body":"3D Step Model Developer Kit 2 Assembly 3D model\n","categories":"","description":"","excerpt":"3D Step Model Developer Kit 2 Assembly 3D model\n","ref":"/reference/cad/developerkit2/","tags":"","title":"SCM Developer Kit 2 Assembly"},{"body":"Good security begins with assigning each device a unique and unalterable identity (Device ID), that is used to authenticate subsequent interactions with the device.\nZYMKEY generates a unique Device ID by measuring certain attributes of the specific host (Measurement), and then combining that Measurement with the unique ID of that specific ZYMKEY. The process of combing these identifiers uses a cryptographic function, and this process is generally termed binding.\nOn completion of the binding process, the ZYMKEY is said to be bound to the Pi.\nZYMKEY supports two operating modes: Developer Mode : Binding is temporary and the ZYMKEY can be used with a different host SBC and SD card in the future.\nProduction Mode : Binding in production mode is permanent! The ZYMKEY can NOT be moved to different host SBC or used with a different SD card.\nThe tables below summarize the actions in Development Mode vs Production Mode with an encrypted root filesystem.\nDeveloper vs Production Mode SD Card A′ - image copy of original, encrypted SD Card A\nDeveloper Mode\nSD Card ZYMKEY PI4 Locks/Unlocks A A A Unlocks A′ A A Unlocks A B A Locked A′ B A Locked A A B Unlocks A′ A B Unlocks A B B Locked A′ B B Locked Summary: Developer Mode is lenient and will accommodate an SD card change, or a PI4 change (or both). You cannot use a different ZYMKEY.\nYou also can always start over and re-use the ZYMKEY in a new setup\nProduction Mode\nSD Card ZYMKEY PI4 Locks/Unlocks A A A Unlocks A′ A A Locked A B A Locked A′ B A Locked A A B Locked A′ A B Locked A B B Locked A′ B B Locked Summary: Production Mode is strict and will not unlock an encrypted rootfs without the original SD card, original ZYMKEY and original PI. You cannot re-use that ZYMKEY in a different setup.\n","categories":"","description":"","excerpt":"Good security begins with assigning each device a unique and …","ref":"/reference/binding/","tags":"","title":"Binding, Device ID, and Authentication"},{"body":"","categories":"","description":"","excerpt":"","ref":"/reference/","tags":"","title":"Reference"},{"body":"The following is a list of reserved pins \u0026 services that cannot be used or are not available to the user (they are reserved for Zymbit SCM operation).\nPins that can be used but SCM has control USB2_N USB2_P Pins that can be used but SCM can monitor nEXTRST GPIO17 GPIO22 GPIO27 Pins that currently cannot be used, SCM has control (possible future use with firmware changes) RUN_PG nRPIBOOT USB_OTG_ID Not connected GPIO_VREF ","categories":"","description":"","excerpt":"The following is a list of reserved pins \u0026 services that cannot be …","ref":"/reference/reserved-pins/","tags":"","title":"SCM Reserved Pins"},{"body":"Issue: Cpu Scaling Governor We have seen some issues with the scaling cpu governor on the Raspberry PI interfere with the i2c bus. This sometimes causes the ZYMKEY to be put into a odd state or return failures from operations that get optimized out by the governor.\nWorkaround Solution We Recommend: The PI sets the scaling governor to be ondemand by default. We recommend switching this mode to performance to get the best out of the ZYMKEY.\nNote: Switching to performance will use more battery power.\nSet to performance for current boot; not persistent on reboot: Run as root: sudo su echo performance \u003e /sys/devices/system/cpu/cpufreq/policy0/scaling_governor Set performance to be persistent on reboot with a systemd service: Create a .service file in /etc/systemd/system/. You can name it whatever you wish. We will use cpu-governor.service. Write this code to /etc/systemd/system/cpu-governor.service file: [Unit] Description=Set scaling governor to performance After=multi-user.target Before=zkbootrtc.service [Service] Type=oneshot ExecStart=/bin/sh -c \"echo performance \u003e /sys/devices/system/cpu/cpufreq/policy0/scaling_governor\" [Install] WantedBy=multi-user.target Enable the service: sudo systemctl enable cpu-governor Start the service: sudo systemctl start cpu-governor Verifying the setting You can use cat to verify the current setting. It should return performance. sudo cat /sys/devices/system/cpu/cpufreq/policy0/scaling_governor\n","categories":"","description":"","excerpt":"Issue: Cpu Scaling Governor We have seen some issues with the scaling …","ref":"/reference/cpu-scaling/","tags":"","title":"CPU Scaling Governor"},{"body":" zbcli manifest Description Requires superuser privileges.\nConfigures bootware overlay manifest updates. Overlay images provide a way to selectively add and delete files or directories from your deployed images.\nSelecting the “Overlay image from files added with zbcli manifest” option in the Imager will create an Overlay zi image using the contents of the file additions and deletions manifests.\nUsage zbcli manifest \u003cCOMMAND\u003e Commands: add Add file/directory to overlay update manifest. These files are added during an update delete Add file/directory to overlay deletions manifest. These files are deleted during an update remove-entry Remove file/directory from both manifests clear-all Clear all entries in the manifest and deletions list print Print the additions and deletions manifests help Print this message or the help of the given subcommand(s) Options: -h, --help Print help Additions manifest Entries in the additions manifest are absolute paths to files which reside on the current filesystem. When creating an overlay image via the Imager, these will be added to the resulting zi image and placed into the target filesystem during the update process.\nDeletions manifest Entries in the additions manifest are absolute paths to files which may or may not reside on the current filesystem. When creating an overlay image via the Imager, a list of these file names will be included in the resulting zi image, and removed (if present) from the target filesystem during the update process.\nMore information See Overlay updates for more information.\n","categories":"","description":"Configures Bootware overlay image update; edits manifest files","excerpt":"Configures Bootware overlay image update; edits manifest files","ref":"/bootware/zbcli/manifest/","tags":"","title":"zbcli manifest"},{"body":"Updated: 2022-02-14\nWhat is SLIP39 and Shamir’s Backup? An algorithm created by Adi Shamir coined Shamir’s Secret Sharing, provides a new way of backing up and recovering our private keys. This algorithm was proposed by SatoshiLabs to be accepted as new backup method for wallet keys and thus named SLIP39.\nWhy use SLIP39 recovery? If you are familiar with current wallets like MetaMask and Ledger, then you will notice that most of these wallets implement a backup strategy using BIP39. BIP39 is a 12 or 24 word unique sentence that can recreate private keys backed by this strategy . But this is only one shard, and puts responsibility on the owner to keep this one shard from falling into the wrong hands.\nSLIP39 allows the owner to backup their wallets with multiple shards using a committee-like approach. For example, we can generate 10 shards and require that 6 of these shards need to be present to recover a wallet. If the owner loses one shard to a thief then it becomes less of a concern as the thief would still need 5 other shards to get into the wallet. Furthermore the owner can store these 10 shards however he wants: give a shard to a friend, store a shard in safe, bury a shard in the backyard, etc.\nMaximum number of shards? SLIP39 generates groups and each of these groups can contain its own system of member shards.\nHSM6 supports up to 14 groups * 14 members per group = 196 shards total SCM supports up to 16 groups * 16 members per group = 256 shards total Useful Resources: SLIP39 Prerequisites Zymbit Modules that support this feature:\nHSM6 SCM Follow the Getting Started guide first, installing all baseline software.\nAll code snippets written in this article are written using python3. For more Zymbit API documentation (Python/C/C++) visit: API Documentation\nGenerating a master seed with SLIP39 recovery The next steps cover how to create a master seed and setup for recovery of the seed with SLIP39. The example python code is provided in its entirety at the end of the explaination of each portion of the code.\nOpening a master seed SLIP39 generating session Create the recovery strategy. The recovery strategy will detail the number of groups to track (group_count) and number of groups needed to recover the master seed (group_threshold).\niteration_exponent dictates how many hashes are done at cryptographic layer (takes integer 0-5). The higher this number is, the longer (exponentially) the module will take to churn out a shard.\nvariant is only for curve “ed25519”, we support the “cardano” variant for ed25519. Otherwise is empty string.\nSupported Curves Other supported variants Nistp256/Secp256r1 None Secp256k1 None Ed25519 Cardano passphrase is the password for generating/recovering the master generator key.\nuse_SLIP39_recovery = zymkey.RecoveryStrategySLIP39(group_count = 3, group_threshold = 2, iteration_exponent = 0, variant = \"\", passphrase = \"\") Next, start the shard generating SLIP39 session.\n# The master seed will not be generated until all groups are created. So the slot will not be returned until all shards are generated. # Opens a SLIP39 session successfully on return code 0 print(\"Starting SLIP39 shard generating session...\") return_code = zymkey.client.gen_wallet_master_seed(\"secp256k1\", \"\", \"MyExampleWallet\", use_SLIP39_recovery) print(\"Done! Return Code:%i\" % (return_code)) A return code of 0 means we successfully started an active SLIP39 session.\nWarning While a SLIP39 session is active for both generation or recovery, other wallet generation functions are locked up. This means we can’t generate other keys while a SLIP39 session. If anything ever goes wrong in the SLIP39 process, we can cancel an active SLIP39 session at any time.\n# cancel an active SLIP39 session (Generation/Recovery) zymkey.client.cancel_SLIP39_session() Setting up our Groups and their member shards Groups can also contain their own member shard system. We will need to set this configuration for each group we work on with set_gen_SLIP39_group_info. The group_index is the group id we will be working on. So if we asked for 3 groups in our recovery strategy, then the group indexes for these 3 groups are [0,1,2].\nThe member_count is the number of shards in the group.\nThe member_threshold is the number of member shards we required to reconstruct the group.\nadd_gen_SLIP39_member_pwd(string passphrase) will return a -1 and 33 word mnemonic sentence (shard). If we specified a member_count of three, then we will need to call this function 3 times to generate our 3 member shards. By default the function doesn’t attach a password to any of these shards. This function will return a -1 until all groups/members are generated.\nFor now, the first group will have 3 shards with a threshold of 2 shards required for reconstruction. These shards will also not have passwords attached to them.\n# First Group has been divided into three members. Will require two of these three members to reconstruct this group. # This group will have no passwords attached to the members # add_gen_SLIP39_member_pwd() will return a [-1, mnemonic_sentence]. -1 symbolizing that all shards haven't been generated yet. print(\"\\nSet our first example group configuration..\") zymkey.client.set_gen_SLIP39_group_info(group_index = 0, member_count = 3, member_threshold = 2) print(\"Generating 3 Shards for Group 0 (Shards required for recovering the group: 2)...\") group_0_shard_list = [] for i in range(3): ret, mnemonic_shard = zymkey.client.add_gen_SLIP39_member_pwd() group_0_shard_list.append(mnemonic_shard) print(\"Shard #%i , Mnemonic sentence:\\n%s\" % (i+1, group_0_shard_list[i])) For the second group, generate three total shards again, but this time with a threshold of 3 shards (all are required for reconstruction). These shards will have passwords attached to them this time.\n# Second Group has been divided into three members. Will require all three members to reconstruct this group. # This group will have passwords attached to the members print(\"\\nSet our second example group configuration..\") zymkey.client.set_gen_SLIP39_group_info(group_index = 1, member_count = 3, member_threshold = 3) print(\"Done!\") print(\"Generating 3 Shards for Group 1 (Shards required for recovering the group: 3)...\") group_1_shard_dict = {} group_1_pwd_list = [\"p@ssw0rd\", \"T3st\", \"h3LlO\"] for i in range(3): ret, mnemonic_shard = zymkey.client.add_gen_SLIP39_member_pwd(group_1_pwd_list[i]) group_1_shard_dict[group_1_pwd_list[i]] = mnemonic_shard print(\"Shard #%i , Mnemonic sentence(Password: %s):\\n%s\" % (i+1, group_1_pwd_list[i], group_1_shard_dict[group_1_pwd_list[i]])) For the third group we will have only one shard. To show that we do not have to always shard up our groups into multiple shards. Since this is the last group in the SLIP39 session, the master seed key’s slot number will be returned on the last shard generated by add_gen_SLIP39_member_pwd() instead of -1.\nWarning Although this shard may look like a BIP39 mnemonic sentence. They are NOT interchangeable. # Third Group has been divided into just one member (THIS IS NOT RECOMMENDED LEAST SECURE). Will require the only member to reconstruct this group. # This group will have no passwords attached to the members # This shard is not the same as a BIP39 shard! # Since this is the last group, on the very last shard the add_gen_SLIP39_member_pwd() will return the master seed slot it was generated in, instead of -1. print(\"\\nSet our third example group configuration..\") zymkey.client.set_gen_SLIP39_group_info(group_index = 2, member_count = 1, member_threshold = 1) print(\"Done!\") print(\"Generating 1 Shards for Group 2 (Shards required for recovering the group: 1)...\") master_seed_slot, last_shard = zymkey.client.add_gen_SLIP39_member_pwd() print(\"Shard #%i , Mnemonic sentence:\\n%s\" % (1, last_shard)) A master seed key pair has been generated with a SLIP39 backup strategy. For security, the master seed public key cannot be exported, but a child key can be generated and its public key can be exported.\nprint(\"\\nMaster Seed Slot: %i\" % (master_seed_slot)) child_slot = zymkey.client.gen_wallet_child_key(master_seed_slot, 0 , False) child_pub_key = zymkey.client.get_public_key(child_slot) print(\"Child Public Key: %s\" % (child_pub_key)) Next, recover this key pair with the SLIP39 shards just generated. Compare the children public keys to see if the correct master key pair was recovered.\nRecovering our master key with SLIP39 shards Delete the original master seed key pair. This will also delete any children keys generated from the master seed key pair.\n# Lets Remove that key we just generated and recover it. # Note! removing the master key will remove its children keys as well. print(\"\\nRemoving Master Key....\") zymkey.client.remove_key(master_seed_slot) print(\"Done!\") Opening a recovery SLIP39 session Start the SLIP39 recovery session. This must take in the same curve type, master key passphrase, wallet name, and recovery strategy. This session will return a -1, but this is not an error. A -1 is returned throughout the session to be ambiguous on how far along the recovery process we are. If there truly was an error, restore_wallet_master_seed() will return an exception instead.\n# Per Above example we need to restore two of the three groups in order to get our master seed back # Let's restore with group 0 and group 1 # Open a restore SLIP39 session, recovery_strategy will be the same as above # Return code will be -1, but this is due to security reasons. To not let users know how far along the recovery process is. # It will instead throw an exception if it fails. print(\"\\nStarting SLIP39 shard restoring session...\") return_code = zymkey.client.restore_wallet_master_seed(\"secp256k1\", \"\", \"MyExampleWallet\", use_SLIP39_recovery) print(\"Done! Return Code:%i\" % (return_code)) Remember from the earlier example we created three groups and require only two of these groups to be reconstructed to recover our key.\nGroup0 no passwords (3 members, threshold: 2) Group1 has passwords(3 members, threshold: 3) Group2 no password (1 member, threshold: 1) Since we only require two groups to recover our master key, the total number shards needed can differ.\nThese three ways will all recover the master key.\nGroup combination member thresholds Total shards needed Group0 + Group1 2 + 3 5 Group1 + Group2 3 + 1 4 Group2 + Group0 1 + 2 3 Now recover the master key using the group combination of Group0 + Group1. Shards are fed in one at a time and can be fed out of order as well. The module will auto reconstruct any groups as it gets more shards fed in. The module will return -1 until it successfully recreates all groups needed to generate the master key. If an incorrect shard is fed in, then it will still return -1. Remember we can always call cancel_SLIP39_session to stop our active SLIP39 session, if an incorrect shard is fed in.\n# Feed in the shards. The shards will be fed in one at a time, and can be fed in any order. # This function will keep returning -1, for security. To not let users know how far along the recovery process is. # The function will return the real slot number once all groups are reconstructed. # For this example we need to feed in a total of: group_0_threshold (2) + group_1_threshold (3) = 5 shards. # Feed group 0 shards, and for fun out of order. print(\"\\nFeeding Group 0 Shard#3 and Shard#1...\") zymkey.client.add_restore_SLIP39_mnemonic(mnemonic_sentence = group_0_shard_list[2]) zymkey.client.add_restore_SLIP39_mnemonic(mnemonic_sentence = group_0_shard_list[0]) print(\"Done!\") # group1 shards have passwords attached to them. So we need to feed in the correct passwords for these shards. print(\"\\nFeeding Group 1 Shards with their passwords...\") zymkey.client.add_restore_SLIP39_mnemonic(mnemonic_sentence = group_1_shard_dict.get(group_1_pwd_list[0]), passphrase = group_1_pwd_list[0]) zymkey.client.add_restore_SLIP39_mnemonic(mnemonic_sentence = group_1_shard_dict.get(group_1_pwd_list[2]), passphrase = group_1_pwd_list[2]) # Notice the last shard required for full master seed reconstruction will return the slot number instead of -1 master_seed_slot = zymkey.client.add_restore_SLIP39_mnemonic(mnemonic_sentence = group_1_shard_dict.get(group_1_pwd_list[1]), passphrase = group_1_pwd_list[1]) print(\"Done!\") The master key should now be sucessfully recovered. Verify that the master key is correctly recovered.\n# Check the public key and make sure its the same. # Checking if master_seed_pub_key = zymkey.client.get_public_key(master_seed_slot) print(\"\\nMaster Seed Slot: %i\" % (master_seed_slot)) child_slot = zymkey.client.gen_wallet_child_key(master_seed_slot, 0 , False) child_pub_key = zymkey.client.get_public_key(child_slot) print(\"Child Public Key: %s\" % (child_pub_key)) # Cleanup print(\"\\nRemoving Master Key....\") zymkey.client.remove_key(master_seed_slot) print(\"Done!\") The public key from the children key should match the public key we got before, proving the master key recovered matched the original master key.\nFull Code Example #!/usr/bin/python3 import zymkey wallet_name = \"MyExampleWallet\" # --------------------------------------Create a master seed using shamir's backup----------------------------------------------------------------------- # Use the SLIP39 recovery strategy to tell zymkey to open a SLIP39 shard generating session. # The recovery strategy will detail the number of Groups to track (group_count) and number of groups needed to recover the master seed (group_threshold) # iteration_exponent dictates how many hashes are done at cryptographic layer. # The master seed will not be generated until all groups are created. So the slot will not be returned until all shards are generated. # Opens a SLIP39 session successfully on return code 0 use_SLIP39_recovery = zymkey.RecoveryStrategySLIP39(group_count = 3, group_threshold = 2, iteration_exponent = 0, variant = \"\", passphrase = \"\") print(\"Starting SLIP39 shard generating session...\") return_code = zymkey.client.gen_wallet_master_seed(\"secp256k1\", \"\", wallet_name, use_SLIP39_recovery) print(\"Done! Return Code:%i\" % (return_code)) # First Group has been divided into three members. Will require two of these three members to reconstruct this group. # This group will have no passwords attached to the members # add_gen_SLIP39_member_pwd() will return a [-1, mnemonic_sentence]. -1 symbolizing that all shards haven't been generated yet. print(\"\\nSet our first example group configuration..\") zymkey.client.set_gen_SLIP39_group_info(group_index = 0, member_count = 3, member_threshold = 2) print(\"Generating 3 Shards for Group 0 (Shards required for recovering the group: 2)...\") group_0_shard_list = [] for i in range(3): ret, mnemonic_shard = zymkey.client.add_gen_SLIP39_member_pwd() group_0_shard_list.append(mnemonic_shard) print(\"Shard #%i , Mnemonic sentence:\\n%s\" % (i+1, group_0_shard_list[i])) # Second Group has been divided into three members. Will require all three members to reconstruct this group. # This group will have passwords attached to the members print(\"\\nSet our second example group configuration..\") zymkey.client.set_gen_SLIP39_group_info(group_index = 1, member_count = 3, member_threshold = 3) print(\"Done!\") print(\"Generating 3 Shards for Group 1 (Shards required for recovering the group: 3)...\") group_1_shard_dict = {} group_1_pwd_list = [\"p@ssw0rd\", \"T3st\", \"h3LlO\"] for i in range(3): ret, mnemonic_shard = zymkey.client.add_gen_SLIP39_member_pwd(group_1_pwd_list[i]) group_1_shard_dict[group_1_pwd_list[i]] = mnemonic_shard print(\"Shard #%i , Mnemonic sentence(Password: %s):\\n%s\" % (i+1, group_1_pwd_list[i], group_1_shard_dict[group_1_pwd_list[i]])) # Third Group has been divided into just one member (THIS IS NOT RECOMMENDED LEAST SECURE). Will require the only member to reconstruct this group. # This group will have no passwords attached to the members # This shard is not the same as a BIP39 shard! # Since this is the last group, on the very last shard the add_gen_SLIP39_member_pwd() will return the master seed slot it was generated in, instead of -1. print(\"\\nSet our third example group configuration..\") zymkey.client.set_gen_SLIP39_group_info(group_index = 2, member_count = 1, member_threshold = 1) print(\"Done!\") print(\"Generating 1 Shards for Group 2 (Shards required for recovering the group: 1)...\") master_seed_slot, last_shard = zymkey.client.add_gen_SLIP39_member_pwd() print(\"Shard #%i , Mnemonic sentence:\\n%s\" % (i+1, last_shard)) # master_seed_pub_key = zymkey.client.get_public_key(master_seed_slot) print(\"\\nMaster Seed Slot: %i\" % (master_seed_slot)) child_slot = zymkey.client.gen_wallet_child_key(master_seed_slot, 0 , False) child_pub_key = zymkey.client.get_public_key(child_slot) print(\"Child Public Key: %s\" % (child_pub_key)) # -------------------------------------------------------------------------------------------------------------------------------------------------------- # --------------------------------------Recover a master seed using shamir's backup----------------------------------------------------------------------- # Let's Remove that key we just generated and recover it. # Note! removing the master key will remove its children keys as well. print(\"\\nRemoving Master Key....\") zymkey.client.remove_key(master_seed_slot) print(\"Done!\") # Per Above example we need to restore two of the three groups in order to get our master seed back # Let's restore with group 0 and group 1 # Open a restore SLIP39 session, recovery_strategy will be the same as above # Return code will be -1, but this is due to security reasons. To not let users know how far along the recovery process is. # It will instead throw an exception if it fails. print(\"\\nStarting SLIP39 shard restoring session...\") return_code = zymkey.client.restore_wallet_master_seed(\"secp256k1\", \"\", wallet_name, use_SLIP39_recovery) print(\"Done! Return Code:%i\" % (return_code)) # Now we will feed in our shards. These will be fed in one at a time, and can be fed in any order. # This function will keep returning -1, for security. To not let users know how far along the recovery process is. # Will return the real slot number once all groups are reconstructed. # For this example we need to feed in a total of: group_0_threshold (2) + group_1_threshold (3) = 5 shards. #Feed group 0 shards, and for fun out of order. print(\"\\nFeeding Group 0 Shard#3 and Shard#1...\") zymkey.client.add_restore_SLIP39_mnemonic(mnemonic_sentence = group_0_shard_list[2]) zymkey.client.add_restore_SLIP39_mnemonic(mnemonic_sentence = group_0_shard_list[0]) print(\"Done!\") # group1 shards have passwords attached to them. So we need to feed in the correct passwords for these shards. print(\"\\nFeeding Group 1 Shards with their passwords...\") zymkey.client.add_restore_SLIP39_mnemonic(mnemonic_sentence = group_1_shard_dict.get(group_1_pwd_list[0]), passphrase = group_1_pwd_list[0]) zymkey.client.add_restore_SLIP39_mnemonic(mnemonic_sentence = group_1_shard_dict.get(group_1_pwd_list[2]), passphrase = group_1_pwd_list[2]) # Notice the last shard required for full master seed reconstruction will return the slot number instead of -1 master_seed_slot = zymkey.client.add_restore_SLIP39_mnemonic(mnemonic_sentence = group_1_shard_dict.get(group_1_pwd_list[1]), passphrase = group_1_pwd_list[1]) print(\"Done!\") # Let's Check the public key and make sure its the same. # master_seed_pub_key = zymkey.client.get_public_key(master_seed_slot) print(\"\\nMaster Seed Slot: %i\" % (master_seed_slot)) child_slot = zymkey.client.gen_wallet_child_key(master_seed_slot, 0 , False) child_pub_key = zymkey.client.get_public_key(child_slot) print(\"Child Public Key: %s\" % (child_pub_key)) print(\"\\nRemoving Master Key....\") zymkey.client.remove_key(master_seed_slot) print(\"Done!\") # ----------------------------------------------------------------------------------------------------------------------------------------------- ","categories":"","description":"","excerpt":"Updated: 2022-02-14\nWhat is SLIP39 and Shamir’s Backup? An algorithm …","ref":"/tutorials/digital-wallet/slip39-example/","tags":"","title":"SLIP39 and Shamir's Wallet Recovery Example"},{"body":"Applicable Products The information included in this post applies to ZYMKEY4, HSM4, and HSM6.\nStandard ZYMKEY4 and HSMs are supplied with a Real Time Clock (RTC). This capability can be useful for platforms which do not have a built-in RTC, such as Raspberry Pi, but rather depend on NTP for time-keeping.\nDependence on NTP may cause problems due to unscheduled power outages or unreliable WiFi connections. For example, if a deployed application that periodically collects sensor data experiences a power outage and is not able to restore a connection to any available networks upon boot up, the timestamps associated with any collected data would be incorrect. On Raspberry Pi, this will be approximate to the last valid timestamp when things were last running normally.\nWe can simulate this by disabling ntp.service comparing the system date to the time.nist.gov server. After only 12 hours, the system clock has drifted nearly 40 minutes!\nZymkey and HSM’s Real Time Clock is battery backed for reliable operation, which could be very valuable for significant power or network outages. Prior to starting NTP in the boot sequence, the Zymkey or HSM provides the current UTC timestamp to the host computer (e.g. Raspberry Pi). This means that, if access to a reliable network isn’t available, a reliable timestamp will be available for use by any running applications.\nWith a bound Zymbit Security Module installed and running zkbootrtc.service on the same system as above (ntp disabled), we can see the clock restored based on the Zymbit Security Module’s RTC. You will notice this message at boot:\nFeb 8 19:22:26 raspberrypi systemd[1]: Starting Restore System Clock from Zymkey… Feb 9 18:58:48 raspberrypi systemd[1]: Started Restore System Clock from Zymkey.\nAnd we can validate using the same test as above.\nThe time value is not settable directly by applications that are running on Pi. Instead RTC accuracy is monitored and maintained by the software suite.\nIn order for the RTC feature to be activated, the Zymkey/ HSM needs to have it’s clock checked and set occasionally, which is done by the HSM software, but this means that NTP must be running so that the Pi time is synchronized to an accurate clock source. To make sure that NTP is active, on later raspbian distributions, you’ll need to run sudo timedatectl set-ntp true and then reboot. In the case where a new coin cell has been installed, it may take a few minutes after the reboot for the HSM time to be synchronized.\nAccuracy of RTC ZYMKEY4 and HSMs with integrated RTC are supplied with Standard Accuracy calibration. This is generally suitable for commercial applications that are not exposed to extreme temperature ranges and not disconnected from NTP for months on end. (see specs below)\nAn optional High Accuracy RTC is available, providing additional stability over extended temperature ranges.\n","categories":"","description":"","excerpt":"Applicable Products The information included in this post applies to …","ref":"/reference/real-time-clock/","tags":"","title":"Real Time Clock Operation"},{"body":" Bootware 1.2 General Platform Support Image files available for download Item Size Description zymbit_bookworm64_1.2.zi 960 MB Base Bookworm 64bit zi image zymbit_bullseye64_1.2.zi 661 MB Base Bullseye 64bit zi image zymbit_ubuntu64_22.04_1.2.zi 2.1 GB Base Ubuntu 22.04 64bit zi image pub_key_1.2.pem Public Key - Common for all Bootware 1.2 zi images ","categories":"","description":"Links to pre-prepared download image files and keys","excerpt":"Links to pre-prepared download image files and keys","ref":"/bootware/image-files/","tags":"","title":"Image Files"},{"body":" zbcli uninstall Description Requires superuser privilege.\nUninstalls Bootware, returning to the standard linux boot process. The uninstall process will leave you in the current encrypted active partition and preserve the contents of that partion as well as the overall partition layout.\nUsage zbcli uninstall [OPTIONS] Options: -y, --yes Says `yes` to all prompts. This includes rebooting your system -h, --help Print help The script will confirm you would like to uninstall the bootware scripts and artifacts, as well as a required reboot.\nSee also zbcli install\n","categories":"","description":"Uninstalls Bootware tools and artifacts","excerpt":"Uninstalls Bootware tools and artifacts","ref":"/bootware/zbcli/uninstall/","tags":"","title":"zbcli uninstall"},{"body":" Bootware 1.1 General Platform Support Image files available for download Item Description bootware-1.1.tgz Bootware 1.1 Package zymbit_bookworm64_1.1.zi Base Bookworm 64bit zi image zymbit_bullseye64_1.1.zi Base Bullseye 64bit zi image zymbit_ubuntu64_22.04_1.1.zi Base Ubuntu 22.04 64bit zi image pub_key_1.1.pem Public Key - Common for all Bootware 1.1 zi images ","categories":"","description":"","excerpt":" Bootware 1.1 General Platform Support Image files available for …","ref":"/bootware/archive/bootware-one-zero-general/image-files/","tags":"","title":"Image Files"},{"body":" zb-uninstall.sh Description Requires superuser privilege. Resides in the original bootware untar directory.\nUninstalls Bootware, returning to the standard linux boot process. The uninstall process will leave you in the current encrypted active partition and preserve the contents of that partion as well as the overall partition layout.\nUsage Example cd ~/bootware-1.1 sudo ./zb-uninstall.sh The script will confirm you would like to uninstall the bootware scripts and artifacts, as well as a required reboot.\nSee also zb-install\n","categories":"","description":"","excerpt":" zb-uninstall.sh Description Requires superuser privilege. Resides in …","ref":"/bootware/archive/bootware-one-zero-general/utilities/zbuninstall/","tags":"","title":"Zymbit Bootware Uninstall Utility"},{"body":" ","categories":"","description":"Archive of previous Bootware releases","excerpt":"Archive of previous Bootware releases","ref":"/bootware/archive/","tags":"","title":"Previous Bootware Versions"},{"body":"Updated: 2022-02-22\nWhat is an oversight wallet? The zymbit oversight wallet is a read-only wallet. In the world of blockchain, accounts and the funds associated with them are public and able to be viewed. This is done by looking up the blockchain address associated with public keys. Read-only or receive-only wallets can’t send funds/assets out of the account. To send funds an account must be able to sign a fund transaction with a private key. So the oversight wallet is a wallet that doesn’t contain private keys, just the public key counterparts.\nWhy use oversight wallet? This can be useful for handing a copy of a wallet to a financial advisor or someone of a similar role. They would be able to track the history of that wallet, but wouldn’t have any power in changing the wallet in any kind of way.\nPrerequisites Zymbit Modules that support this feature:\nHSM6 SCM Follow the Getting Started guide first, installing all baseline software.\nAll code snippets written in this article are written using Python3. For more Zymbit API documentation (Python/C/C++) visit: API Documentation\nCreating an oversight wallet on the Zymbit module First create an example BIP32 master seed wallet as a reference for our oversight wallet.\n# Create our BIP32 master seed print(\"Create our normal wallet...\") master_seed_slot = zymkey.client.gen_wallet_master_seed(key_type = \"secp256k1\", master_gen_key = \"\", wallet_name = MyExampleWallet) print(\"Done! Master seed slot:%i\" % (master_seed_slot)) Next for this example, we create children keys and derive a wallet address “m/44/60/0/0’”. An oversight wallet is created by referencing the public key and chain code of the last hardened node of a wallet address. So in this example, grab the public key and chain code from the slot of the \" 0’ \" index.\n# Oversight wallet requires the public key and chain code of the last hardened node in a wallet address. # So for this example will use m/44/60/0/0' where the 0' is the last hardened node for our oversight wallet to start from. print(\"\\nCreate a wallet derivation path m/44/60/0/0' ..\") child_slot = zymkey.client.gen_wallet_child_key(parent_key_slot = master_seed_slot, index = 44, hardened = False) child_slot = zymkey.client.gen_wallet_child_key(parent_key_slot = child_slot, index = 60, hardened = False) child_slot = zymkey.client.gen_wallet_child_key(parent_key_slot = child_slot, index = 0, hardened = False) # Let's return the chain code of this hardened node to generate our oversight wallet later child_slot, chain_code = zymkey.client.gen_wallet_child_key(parent_key_slot = child_slot, index = 0, hardened = True, return_chain_code = True) hardened_node_pub_key = zymkey.client.get_public_key(child_slot) print(\"Done! m/44/60/0/0' slot:%i\" % (child_slot)) Now generate an oversight wallet from the public key and chain code:\n# Using the public key and chain code, create the oversight wallet. # Note that the oversight wallet can exist at the same time as our BIP32 wallet, but needs a different wallet name, as wallet names are unique. print(\"Create our oversight wallet...\") oversight_slot = zymkey.client.gen_oversight_wallet(key_type = \"secp256k1\", pub_key = hardened_node_pub_key, chain_code = chain_code, node_addr = \"m/44/60/0/0'\", wallet_name = \"Oversight_wallet\") print(\"Done! oversight_slot slot:%i\" % (oversight_slot)) The oversight wallet can generate child keys the same way as a normal BIP32 wallet. However this wallet contains no private keys, so no transaction will be able to be signed properly.\nAlso note that this oversight wallet starts from the \" 0’ \" index of the previous wallet. It has no insight about the “m/44/60/0” key pairs that came before it.\nFull Code Example #!/usr/bin/python3 import zymkey # -----------------------------Create a oversight wallet example------------------------------------------------------------- wallet_name = \"MyExampleWallet\" # Create our BIP32 master seed print(\"Create our normal wallet...\") master_seed_slot = zymkey.client.gen_wallet_master_seed(key_type = \"secp256k1\", master_gen_key = \"\", wallet_name=wallet_name) print(\"Done! Master seed slot:%i\" % (master_seed_slot)) # Oversight wallet requires the public key and chain code of the last hardened node in a wallet address. # So for this example will use m/44/60/0/0' where the 0' is the last hardened node for our oversight wallet to start from. print(\"\\nCreate a wallet derivation path m/44/60/0/0' ..\") child_slot = zymkey.client.gen_wallet_child_key(parent_key_slot = master_seed_slot, index = 44, hardened = False) child_slot = zymkey.client.gen_wallet_child_key(parent_key_slot = child_slot, index = 60, hardened = False) child_slot = zymkey.client.gen_wallet_child_key(parent_key_slot = child_slot, index = 0, hardened = False) # Let's return the chain code of this hardened node to generate our oversight wallet later child_slot, chain_code = zymkey.client.gen_wallet_child_key(parent_key_slot = child_slot, index = 0, hardened = True, return_chain_code = True) hardened_node_pub_key = zymkey.client.get_public_key(child_slot) print(\"Done! m/44/60/0/0' slot:%i\" % (child_slot)) # Now that we have the public key and chain code, can create the oversight wallet. # Note that the oversight wallet can exist at the same time as our BIP32 wallet. But needs a different wallet name, as wallet names are unique. print(\"Create our oversight wallet...\") oversight_slot = zymkey.client.gen_oversight_wallet(key_type = \"secp256k1\", pub_key = hardened_node_pub_key, chain_code = chain_code, node_addr = \"m/44/60/0/0'\", wallet_name = \"Oversight_wallet\") print(\"Done! oversight_slot slot:%i\" % (oversight_slot)) # ----------------------------------------------------------------------------------------------------------------------------- ","categories":"","description":"","excerpt":"Updated: 2022-02-22\nWhat is an oversight wallet? The zymbit oversight …","ref":"/tutorials/digital-wallet/oversight-example/","tags":"","title":"Creating an Oversight (Read Only) Wallet"},{"body":"","categories":"","description":"","excerpt":"","ref":"/reference/engineering-notes/en-20230721-scm-mobo/","tags":"","title":"Engineering Note 20230721 SCM Motherboard - USB Power"},{"body":"","categories":"","description":"","excerpt":"","ref":"/reference/product-briefs/scm/","tags":"","title":"Secure Compute Modules"},{"body":"","categories":"","description":"","excerpt":"","ref":"/reference/engineering-notes/en-2022.10.11-hsm-perim/","tags":"","title":"Engineering Note 20221011 HSM4/HSM6 - Using Perimeter Detect"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tutorials/","tags":"","title":"Tutorials"},{"body":"If left in Development Mode, self-destruct events are simulated with LED flash sequences and recovery rather than destruction to allow for experimentation with the security functions. The LED sequence will repeat three times and then the system will recover.\nDESTRUCTIVE ACTION THE BINDING PROCESS IS PERMANENT AND CANNOT BE REVERSED. PAY ATTENTION TO THE FOLLOWING:\nIf you are using the Perimeter Detect features, then the sequence in which you arm and disarm this feature is very important. Be sure to carefully follow the process steps below. If you decide that you are not ready for permanent binding, leave the SCM in developer mode.\nDESTRUCTIVE ACTION The table below summarizes the differences between Development Mode (no Bind Lock) and Production Mode (Bind Locked)\nEvent Development Mode Production Mode Triggers Tamper Event 6 flash + channel sub-flash Destroy all keys Immediately Low Temp Threshold 20 flash + 1 sub-flash Do Not Boot Immediately High Temp Threshold 20 flash + 2 sub-flash Do Not Boot Immediately Low Battery Voltage Threshold 6 flash Two Policies: Prevent Boot or Destroy all keys Power Off Supervised Boot Failure 4 flash + 2 sub-flash Two Policies: Prevent Boot or Destroy all keys On Boot Once locked, setting the Event Action modes are limited in the following way:\nEvent Setting Tamper One time after locked Low Temp Threshold Must be set prior to locking High Temp Threshold Must be set prior to locking Low Battery Voltage Threshold Must be set prior to locking Supervised Boot Failure No limit When you have completed your development work with the SCM and are ready to deploy your system into the field, we recommend that you permanently bind your SCM to a specific host device.\nSummary of Steps Develop your application\n[ ] Ensure your host has all the necessary prerequisites in place to interface with the SCM and that it will be able to run your software application.\nActivate Production Mode\n[ ] Permanently bind your SCM to the host device.\nDevelop your application The following steps should be complete:\n[ ] Install a battery on the Zymbit SCM I/O board.\n[ ] Install all necessary software for your application on the host and establish temporary binding in development mode.\nAfter these steps have been completed, you are ready to prepare your device for permanent binding.\nPrepare Perimeter Detect The Perimeter Event Actions for your SCM should be set to none or notify only. If your SCM’s action mode is set to self_destruct, you might render your unit /c/Users/bobgu/OneDrive/Desktop/Atom.lnkuseless while attempting to activate Production Mode.\nResources Perimeter Detect: SCM Understand how to use the SCM’s perimeter detect features. Read article To do this quickly, with the SCM client libraries installed, you can run the following shell command to use the Python API to communicate with the SCM and set the Perimeter Event Actions to only Notify when triggered:\npython3 -c \"import zymkey; for ch in (0, 1): zymkey.client.set_perimeter_event_actions(ch, action_notify=True, action_self_destruct=False) zymkey.client.clear_perimeter_detect_info()\" Prepare your application You should then install your application on your host SBC. The SCM root partition is pre-encrypted and is secured by the SCM itself.\nTest, debug, and test again Danger DO NOT skip this step. If you encounter a major issue with your application after your SCM has been permanently bound to your device and armed, you may not be able to fix it. Test the functionality of your application thoroughly to ensure it is free of major defects that will prevent it from functioning properly. In Production Mode when Perimeter Detect features are in use, it may be difficult to make significant changes to your configuration without locking youself out of the SCM, depending on the nature of your application and its configuration.\nActivate Production Mode To put the SCM into Production Mode only requires a function call followed by a power cycle.\nThe API function lock_binding puts the SCM into Production Mode. Below are three examples which check the current binding info, lock the SCM binding, then check the current binding info again. Remove the comments around the lock binding function to move to Production Mode.\nC - zkLockBinding // gcc example_binding.c -I /usr/include/zymkey -l zk_app_utils -o example_binding #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \"zk_app_utils.h\" #include \"zk_b64.h\" void check_code(int code, char* location){ if (code \u003c 0) { fprintf(stderr, \"FAILURE: %s - %s\\n\", location, strerror(code)); } else if (code \u003e= 0) { fprintf(stdout, \"SUCCESS: %s - %d\\n\", location, code); } } void HSM_soft_bind(zkCTX zk_ctx) { bool binding_is_locked = false; bool is_bound = false; int ret = zkGetCurrentBindingInfo(zk_ctx, \u0026binding_is_locked, \u0026is_bound); check_code(ret, \"zkGetCurrentBindingInfo\"); printf(\"Binding is locked: \"); printf(binding_is_locked ? \"true\" : \"false\"); printf(\"\\n\"); printf(\"SCM is bound: \"); printf(is_bound ? \"true\" : \"false\"); printf(\"\\n\\n\"); //ret = zkLockBinding(zk_ctx); //if(binding_is_locked \u0026\u0026 is_bound) //{ // check_code(ret, \"zkLockBinding - Already Bound\"); //} //else //{ // check_code(ret, \"zkLockBinding\"); //} //printf(\"\\n\"); ret = zkGetCurrentBindingInfo(zk_ctx, \u0026binding_is_locked, \u0026is_bound); check_code(ret, \"zkGetCurrentBindingInfo\"); printf(\"Binding is locked: \"); printf(binding_is_locked ? \"true\" : \"false\"); printf(\"\\n\"); printf(\"SCM is bound: \"); printf(is_bound ? \"true\" : \"false\"); printf(\"\\n\\n\"); } int main() { zkCTX zk_ctx; int status = zkOpen(\u0026zk_ctx); check_code(status, \"zkOpen\"); printf(\"\\n\\n\"); HSM_soft_bind(zk_ctx); status = zkClose(zk_ctx); check_code(status, \"zkClose\"); printf(\"\\n\"); return 0; } C++ - lockBinding #include \u003cstdio.h\u003e #include \u003czkAppUtilsClass.h\u003e using namespace std; using namespace zkAppUtils; void HSM_soft_bind(zkClass* zk_inst) { bool binding_is_locked = false; bool is_bound = false; zk_inst-\u003egetCurrentBindingInfo(binding_is_locked, is_bound); printf(\"Binding is locked: \"); printf(binding_is_locked ? \"true\" : \"false\"); printf(\"\\n\"); printf(\"SCM is bound: \"); printf(is_bound ? \"true\" : \"false\"); printf(\"\\n\"); //zk_inst-\u003elockBinding(); //printf(\"lockBinding successful\\n\"); zk_inst-\u003egetCurrentBindingInfo(binding_is_locked, is_bound); printf(\"Binding is locked: \"); printf(binding_is_locked ? \"true\" : \"false\"); printf(\"\\n\"); printf(\"SCM is bound: \"); printf(is_bound ? \"true\" : \"false\"); printf(\"\\n\"); } int main() { zkClass* zk_inst; zk_inst = new zkClass(); HSM_soft_bind(zk_inst); delete zk_inst; return 0; } Python - lock_binding import zymkey tup = zymkey.client.get_current_binding_info() print(\"SCM is bound: \" + str(tup[1])) print(\"Binding is locked: \" + str(tup[0])) #zymkey.client.lock_binding() tup = zymkey.client.get_current_binding_info() print(\"SCM is bound: \" + str(tup[1])) print(\"Binding is locked: \" + str(tup[0])) Warning Do not proceed without completing the steps outlined above, including setting the Perimeter Event Actions to none or notify. Prior to setting the Bind Lock. Finalize your device for deployment After using the APIs to lock binding, reboot. The blink pattern on the SCM will change to 3 rapid blinks once every 3 seconds to indicate that SCM has bound to the host in Production Mode.\nIf you are using the Perimeter Detect features, close your perimeter circuits (for example, by closing the enclosure’s lid), and then clear any Perimeter Detect Events using the API:\npython3 -c \"import zymkey; idx = 0; zymkey.client.clear_perimeter_detect_info() for p in zymkey.client.get_perimeter_detect_info(): if p: print(f'Channel {idx} has a detected breach event. Clear the Perimeter Detect Events again.') idx += 1 else: print('No perimeter breach detected.')\" If you get a message that a breach event was detected from the above command, run it again to ensure all events have been cleared.\nWarning You only get one chance to set Perimeter Event Actions once you are in Production Mode! When it confirms that no breach events have been detected, it is then safe to arm the system by setting the Perimeter Event Actions to notify or selfdestruct, if desired.\nYour system is now armed and ready to be used in the field!\n","categories":"","description":"","excerpt":"If left in Development Mode, self-destruct events are simulated with …","ref":"/getting-started/scm-dev-kit2/production-mode/","tags":"","title":"Enabling Production Mode - SCM"},{"body":"If left in Development Mode, self-destruct events are simulated with LED flash sequences and recovery rather than destruction to allow for experimentation with the security functions. The LED sequence will repeat three times and then the system will recover.\nDESTRUCTIVE ACTION THE BINDING PROCESS IS PERMANENT AND CANNOT BE REVERSED. PAY ATTENTION TO THE FOLLOWING:\nIf you are using the Perimeter Detect features, then the sequence in which you arm and disarm this feature is very important. Be sure to carefully follow the process steps below. If you decide that you are not ready for permanent binding, leave the SCM in developer mode.\nDESTRUCTIVE ACTION The table below summarizes the differences between Development Mode (no Bind Lock) and Production Mode (Bind Locked)\nEvent Development Mode Production Mode Triggers Tamper Event 6 flash + channel sub-flash Destroy all keys Immediately Low Temp Threshold 20 flash + 1 sub-flash Do Not Boot Immediately High Temp Threshold 20 flash + 2 sub-flash Do Not Boot Immediately Low Battery Voltage Threshold 6 flash Two Policies: Prevent Boot or Destroy all keys Power Off Supervised Boot Failure 4 flash + 2 sub-flash Two Policies: Prevent Boot or Destroy all keys On Boot Once locked, setting the Event Action modes are limited in the following way:\nEvent Setting Tamper One time after locked Low Temp Threshold Must be set prior to locking High Temp Threshold Must be set prior to locking Low Battery Voltage Threshold Must be set prior to locking Supervised Boot Failure No limit When you have completed your development work with the SCM and are ready to deploy your system into the field, we recommend that you permanently bind your SCM to a specific host device.\nSummary of Steps Develop your application\n[ ] Ensure your host has all the necessary prerequisites in place to interface with the SCM and that it will be able to run your software application.\nActivate Production Mode\n[ ] Permanently bind your SCM to the host device.\nDevelop your application The following steps should be complete:\n[ ] Install a battery on the Zymbit SCM I/O board.\n[ ] Install all necessary software for your application on the host and establish temporary binding in development mode.\nAfter these steps have been completed, you are ready to prepare your device for permanent binding.\nPrepare Perimeter Detect The Perimeter Event Actions for your SCM should be set to none or notify only. If your SCM’s action mode is set to self_destruct, you might render your unit /c/Users/bobgu/OneDrive/Desktop/Atom.lnkuseless while attempting to activate Production Mode.\nResources Perimeter Detect: SCM Understand how to use the SCM’s perimeter detect features. Read article To do this quickly, with the SCM client libraries installed, you can run the following shell command to use the Python API to communicate with the SCM and set the Perimeter Event Actions to only Notify when triggered:\npython3 -c \"import zymkey; for ch in (0, 1): zymkey.client.set_perimeter_event_actions(ch, action_notify=True, action_self_destruct=False) zymkey.client.clear_perimeter_detect_info()\" Prepare your application You should then install your application on your host SBC. The SCM root partition is pre-encrypted and is secured by the SCM itself.\nTest, debug, and test again Danger DO NOT skip this step. If you encounter a major issue with your application after your SCM has been permanently bound to your device and armed, you may not be able to fix it. Test the functionality of your application thoroughly to ensure it is free of major defects that will prevent it from functioning properly. In Production Mode when Perimeter Detect features are in use, it may be difficult to make significant changes to your configuration without locking youself out of the SCM, depending on the nature of your application and its configuration.\nActivate Production Mode To put the SCM into Production Mode only requires a function call followed by a power cycle.\nThe API function lock_binding puts the SCM into Production Mode. Below are three examples which check the current binding info, lock the SCM binding, then check the current binding info again. Remove the comments around the lock binding function to move to Production Mode.\nC - zkLockBinding // gcc example_binding.c -I /usr/include/zymkey -l zk_app_utils -o example_binding #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \"zk_app_utils.h\" #include \"zk_b64.h\" void check_code(int code, char* location){ if (code \u003c 0) { fprintf(stderr, \"FAILURE: %s - %s\\n\", location, strerror(code)); } else if (code \u003e= 0) { fprintf(stdout, \"SUCCESS: %s - %d\\n\", location, code); } } void HSM_soft_bind(zkCTX zk_ctx) { bool binding_is_locked = false; bool is_bound = false; int ret = zkGetCurrentBindingInfo(zk_ctx, \u0026binding_is_locked, \u0026is_bound); check_code(ret, \"zkGetCurrentBindingInfo\"); printf(\"Binding is locked: \"); printf(binding_is_locked ? \"true\" : \"false\"); printf(\"\\n\"); printf(\"SCM is bound: \"); printf(is_bound ? \"true\" : \"false\"); printf(\"\\n\\n\"); //ret = zkLockBinding(zk_ctx); //if(binding_is_locked \u0026\u0026 is_bound) //{ // check_code(ret, \"zkLockBinding - Already Bound\"); //} //else //{ // check_code(ret, \"zkLockBinding\"); //} //printf(\"\\n\"); ret = zkGetCurrentBindingInfo(zk_ctx, \u0026binding_is_locked, \u0026is_bound); check_code(ret, \"zkGetCurrentBindingInfo\"); printf(\"Binding is locked: \"); printf(binding_is_locked ? \"true\" : \"false\"); printf(\"\\n\"); printf(\"SCM is bound: \"); printf(is_bound ? \"true\" : \"false\"); printf(\"\\n\\n\"); } int main() { zkCTX zk_ctx; int status = zkOpen(\u0026zk_ctx); check_code(status, \"zkOpen\"); printf(\"\\n\\n\"); HSM_soft_bind(zk_ctx); status = zkClose(zk_ctx); check_code(status, \"zkClose\"); printf(\"\\n\"); return 0; } C++ - lockBinding #include \u003cstdio.h\u003e #include \u003czkAppUtilsClass.h\u003e using namespace std; using namespace zkAppUtils; void HSM_soft_bind(zkClass* zk_inst) { bool binding_is_locked = false; bool is_bound = false; zk_inst-\u003egetCurrentBindingInfo(binding_is_locked, is_bound); printf(\"Binding is locked: \"); printf(binding_is_locked ? \"true\" : \"false\"); printf(\"\\n\"); printf(\"SCM is bound: \"); printf(is_bound ? \"true\" : \"false\"); printf(\"\\n\"); //zk_inst-\u003elockBinding(); //printf(\"lockBinding successful\\n\"); zk_inst-\u003egetCurrentBindingInfo(binding_is_locked, is_bound); printf(\"Binding is locked: \"); printf(binding_is_locked ? \"true\" : \"false\"); printf(\"\\n\"); printf(\"SCM is bound: \"); printf(is_bound ? \"true\" : \"false\"); printf(\"\\n\"); } int main() { zkClass* zk_inst; zk_inst = new zkClass(); HSM_soft_bind(zk_inst); delete zk_inst; return 0; } Python - lock_binding import zymkey tup = zymkey.client.get_current_binding_info() print(\"SCM is bound: \" + str(tup[1])) print(\"Binding is locked: \" + str(tup[0])) #zymkey.client.lock_binding() tup = zymkey.client.get_current_binding_info() print(\"SCM is bound: \" + str(tup[1])) print(\"Binding is locked: \" + str(tup[0])) Warning Do not proceed without completing the steps outlined above, including setting the Perimeter Event Actions to none or notify. Prior to setting the Bind Lock. Finalize your device for deployment After using the APIs to lock binding, reboot. The blink pattern on the SCM will change to 3 rapid blinks once every 3 seconds to indicate that SCM has bound to the host in Production Mode.\nIf you are using the Perimeter Detect features, close your perimeter circuits (for example, by closing the enclosure’s lid), and then clear any Perimeter Detect Events using the API:\npython3 -c \"import zymkey; idx = 0; zymkey.client.clear_perimeter_detect_info() for p in zymkey.client.get_perimeter_detect_info(): if p: print(f'Channel {idx} has a detected breach event. Clear the Perimeter Detect Events again.') idx += 1 else: print('No perimeter breach detected.')\" If you get a message that a breach event was detected from the above command, run it again to ensure all events have been cleared.\nWarning You only get one chance to set Perimeter Event Actions once you are in Production Mode! When it confirms that no breach events have been detected, it is then safe to arm the system by setting the Perimeter Event Actions to notify or selfdestruct, if desired.\nYour system is now armed and ready to be used in the field!\n","categories":"","description":"","excerpt":"If left in Development Mode, self-destruct events are simulated with …","ref":"/getting-started/scm-dev-kit3/production-mode/","tags":"","title":"Enabling Production Mode - SCM"},{"body":"If left in Development Mode, self-destruct events are simulated with LED flash sequences and recovery rather than destruction to allow for experimentation with the security functions. The LED sequence will repeat three times and then the system will recover.\nDESTRUCTIVE ACTION THE BINDING PROCESS IS PERMANENT AND CANNOT BE REVERSED. PAY ATTENTION TO THE FOLLOWING:\nIf you are using the Perimeter Detect features, then the sequence in which you arm and disarm this feature is very important. Be sure to carefully follow the process steps below. If you decide that you are not ready for permanent binding, leave the SCM in developer mode.\nDESTRUCTIVE ACTION The table below summarizes the differences between Development Mode (no Bind Lock) and Production Mode (Bind Locked)\nEvent Development Mode Production Mode Triggers Tamper Event 6 flash + channel sub-flash Destroy all keys Immediately Low Temp Threshold 20 flash + 1 sub-flash Do Not Boot Immediately High Temp Threshold 20 flash + 2 sub-flash Do Not Boot Immediately Low Battery Voltage Threshold 6 flash Two Policies: Prevent Boot or Destroy all keys Power Off Supervised Boot Failure 4 flash + 2 sub-flash Two Policies: Prevent Boot or Destroy all keys On Boot Once locked, setting the Event Action modes are limited in the following way:\nEvent Setting Tamper One time after locked Low Temp Threshold Must be set prior to locking High Temp Threshold Must be set prior to locking Low Battery Voltage Threshold Must be set prior to locking Supervised Boot Failure No limit When you have completed your development work with the SCM and are ready to deploy your system into the field, we recommend that you permanently bind your SCM to a specific host device.\nSummary of Steps Develop your application\n[ ] Ensure your host has all the necessary prerequisites in place to interface with the SCM and that it will be able to run your software application.\nActivate Production Mode\n[ ] Permanently bind your SCM to the host device.\nDevelop your application The following steps should be complete:\n[ ] Install a battery on the Zymbit SCM I/O board.\n[ ] Install all necessary software for your application on the host and establish temporary binding in development mode.\nAfter these steps have been completed, you are ready to prepare your device for permanent binding.\nPrepare Perimeter Detect The Perimeter Event Actions for your SCM should be set to none or notify only. If your SCM’s action mode is set to self_destruct, you might render your unit /c/Users/bobgu/OneDrive/Desktop/Atom.lnkuseless while attempting to activate Production Mode.\nResources Perimeter Detect: SCM Understand how to use the SCM’s perimeter detect features. Read article To do this quickly, with the SCM client libraries installed, you can run the following shell command to use the Python API to communicate with the SCM and set the Perimeter Event Actions to only Notify when triggered:\npython3 -c \"import zymkey; for ch in (0, 1): zymkey.client.set_perimeter_event_actions(ch, action_notify=True, action_self_destruct=False) zymkey.client.clear_perimeter_detect_info()\" Prepare your application You should then install your application on your host SBC. The SCM root partition is pre-encrypted and is secured by the SCM itself.\nTest, debug, and test again Danger DO NOT skip this step. If you encounter a major issue with your application after your SCM has been permanently bound to your device and armed, you may not be able to fix it. Test the functionality of your application thoroughly to ensure it is free of major defects that will prevent it from functioning properly. In Production Mode when Perimeter Detect features are in use, it may be difficult to make significant changes to your configuration without locking youself out of the SCM, depending on the nature of your application and its configuration.\nActivate Production Mode To put the SCM into Production Mode only requires a function call followed by a power cycle.\nThe API function lock_binding puts the SCM into Production Mode. Below are three examples which check the current binding info, lock the SCM binding, then check the current binding info again. Remove the comments around the lock binding function to move to Production Mode.\nC - zkLockBinding // gcc example_binding.c -I /usr/include/zymkey -l zk_app_utils -o example_binding #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \"zk_app_utils.h\" #include \"zk_b64.h\" void check_code(int code, char* location){ if (code \u003c 0) { fprintf(stderr, \"FAILURE: %s - %s\\n\", location, strerror(code)); } else if (code \u003e= 0) { fprintf(stdout, \"SUCCESS: %s - %d\\n\", location, code); } } void HSM_soft_bind(zkCTX zk_ctx) { bool binding_is_locked = false; bool is_bound = false; int ret = zkGetCurrentBindingInfo(zk_ctx, \u0026binding_is_locked, \u0026is_bound); check_code(ret, \"zkGetCurrentBindingInfo\"); printf(\"Binding is locked: \"); printf(binding_is_locked ? \"true\" : \"false\"); printf(\"\\n\"); printf(\"SCM is bound: \"); printf(is_bound ? \"true\" : \"false\"); printf(\"\\n\\n\"); //ret = zkLockBinding(zk_ctx); //if(binding_is_locked \u0026\u0026 is_bound) //{ // check_code(ret, \"zkLockBinding - Already Bound\"); //} //else //{ // check_code(ret, \"zkLockBinding\"); //} //printf(\"\\n\"); ret = zkGetCurrentBindingInfo(zk_ctx, \u0026binding_is_locked, \u0026is_bound); check_code(ret, \"zkGetCurrentBindingInfo\"); printf(\"Binding is locked: \"); printf(binding_is_locked ? \"true\" : \"false\"); printf(\"\\n\"); printf(\"SCM is bound: \"); printf(is_bound ? \"true\" : \"false\"); printf(\"\\n\\n\"); } int main() { zkCTX zk_ctx; int status = zkOpen(\u0026zk_ctx); check_code(status, \"zkOpen\"); printf(\"\\n\\n\"); HSM_soft_bind(zk_ctx); status = zkClose(zk_ctx); check_code(status, \"zkClose\"); printf(\"\\n\"); return 0; } C++ - lockBinding #include \u003cstdio.h\u003e #include \u003czkAppUtilsClass.h\u003e using namespace std; using namespace zkAppUtils; void HSM_soft_bind(zkClass* zk_inst) { bool binding_is_locked = false; bool is_bound = false; zk_inst-\u003egetCurrentBindingInfo(binding_is_locked, is_bound); printf(\"Binding is locked: \"); printf(binding_is_locked ? \"true\" : \"false\"); printf(\"\\n\"); printf(\"SCM is bound: \"); printf(is_bound ? \"true\" : \"false\"); printf(\"\\n\"); //zk_inst-\u003elockBinding(); //printf(\"lockBinding successful\\n\"); zk_inst-\u003egetCurrentBindingInfo(binding_is_locked, is_bound); printf(\"Binding is locked: \"); printf(binding_is_locked ? \"true\" : \"false\"); printf(\"\\n\"); printf(\"SCM is bound: \"); printf(is_bound ? \"true\" : \"false\"); printf(\"\\n\"); } int main() { zkClass* zk_inst; zk_inst = new zkClass(); HSM_soft_bind(zk_inst); delete zk_inst; return 0; } Python - lock_binding import zymkey tup = zymkey.client.get_current_binding_info() print(\"SCM is bound: \" + str(tup[1])) print(\"Binding is locked: \" + str(tup[0])) #zymkey.client.lock_binding() tup = zymkey.client.get_current_binding_info() print(\"SCM is bound: \" + str(tup[1])) print(\"Binding is locked: \" + str(tup[0])) Warning Do not proceed without completing the steps outlined above, including setting the `Perimeter Event Actions` to `none` or `notify`. Prior to setting the Bind Lock. Finalize your device for deployment After using the APIs to lock binding, reboot. The blink pattern on the SCM will change to 3 rapid blinks once every 3 seconds to indicate that SCM has bound to the host in Production Mode.\nIf you are using the Perimeter Detect features, close your perimeter circuits (for example, by closing the enclosure’s lid), and then clear any Perimeter Detect Events using the API:\npython3 -c \"import zymkey; idx = 0; zymkey.client.clear_perimeter_detect_info() for p in zymkey.client.get_perimeter_detect_info(): if p: print(f'Channel {idx} has a detected breach event. Clear the Perimeter Detect Events again.') idx += 1 else: print('No perimeter breach detected.')\" If you get a message that a breach event was detected from the above command, run it again to ensure all events have been cleared.\nWarning You only get one chance to set Perimeter Event Actions once you are in Production Mode! When it confirms that no breach events have been detected, it is then safe to arm the system by setting the Perimeter Event Actions to notify or selfdestruct, if desired.\nYour system is now armed and ready to be used in the field!\n","categories":"","description":"","excerpt":"If left in Development Mode, self-destruct events are simulated with …","ref":"/getting-started/scm/production-mode/","tags":"","title":"Enabling Production Mode - SCM"},{"body":"If left in Development Mode, self-destruct events are simulated with LED flash sequences and recovery rather than destruction to allow for experimentation with the security functions. The LED sequence will repeat three times and then the system will recover.\nDESTRUCTIVE ACTION THE BINDING PROCESS IS PERMANENT AND CANNOT BE REVERSED. PAY ATTENTION TO THE FOLLOWING:\nIf you are using the Perimeter Detect features, then the sequence in which you arm and disarm this feature is very important. Be sure to carefully follow the process steps below. If you decide that you are not ready for permanent binding, leave the SEN in developer mode.\nDESTRUCTIVE ACTION The table below summarizes the differences between Development Mode (no Bind Lock) and Production Mode (Bind Locked)\nEvent Development Mode Production Mode Triggers Tamper Event 6 flash + channel sub-flash Destroy all keys Immediately Low Temp Threshold 20 flash + 1 sub-flash Do Not Boot Immediately High Temp Threshold 20 flash + 2 sub-flash Do Not Boot Immediately Low Battery Voltage Threshold 6 flash Two Policies: Prevent Boot or Destroy all keys Power Off Supervised Boot Failure 4 flash + 2 sub-flash Two Policies: Prevent Boot or Destroy all keys On Boot Once locked, setting the Event Action modes are limited in the following way:\nEvent Setting Tamper One time after locked Low Temp Threshold Must be set prior to locking High Temp Threshold Must be set prior to locking Low Battery Voltage Threshold Must be set prior to locking Supervised Boot Failure No limit When you have completed your development work with the SEN and are ready to deploy your system into the field, we recommend that you permanently bind your SEN to a specific host device.\nSummary of Steps Develop your application\n[ ] Ensure your host has all the necessary prerequisites in place to interface with the SEN and that it will be able to run your software application.\nActivate Production Mode\n[ ] Permanently bind your SEN.\nDevelop your application The following steps should be complete:\n[ ] Install a battery on the Zymbit SEN I/O board.\n[ ] Install all necessary software for your application on the host and establish temporary binding in development mode.\nAfter these steps have been completed, you are ready to prepare your device for permanent binding.\nPrepare Perimeter Detect The Perimeter Event Actions for your SEN should be set to none or notify only. If your SEN’s action mode is set to self_destruct, you might render your unit useless while attempting to activate Production Mode.\nResources Perimeter Detect: Secure Edge Node Understand how to use the SEN’s perimeter detect features. Read article To do this quickly, with the SEN client libraries installed, you can run the following shell command to use the Python API to communicate with the SEN and set the Perimeter Event Actions to only Notify when triggered:\npython3 -c \"import zymkey; for ch in (0, 1): zymkey.client.set_perimeter_event_actions(ch, action_notify=True, action_self_destruct=False) zymkey.client.clear_perimeter_detect_info()\" Prepare your application You should then install your application on your host SBC. The SEN root partition is pre-encrypted and is secured by the SEN itself.\nTest, debug, and test again Danger DO NOT skip this step. If you encounter a major issue with your application after your SEN has been permanently bound to your device and armed, you may not be able to fix it. Test the functionality of your application thoroughly to ensure it is free of major defects that will prevent it from functioning properly. In Production Mode when Perimeter Detect features are in use, it may be difficult to make significant changes to your configuration without locking youself out of the SEN, depending on the nature of your application and its configuration.\nActivate Production Mode To put the SEN into Production Mode only requires a function call followed by a power cycle.\nThe API function lock_binding puts the SEN into Production Mode. Below are three examples which check the current binding info, lock the SEN binding, then check the current binding info again. Remove the comments around the lock binding function to move to Production Mode.\nC - zkLockBinding // gcc example_binding.c -I /usr/include/zymkey -l zk_app_utils -o example_binding #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \"zk_app_utils.h\" #include \"zk_b64.h\" void check_code(int code, char* location){ if (code \u003c 0) { fprintf(stderr, \"FAILURE: %s - %s\\n\", location, strerror(code)); } else if (code \u003e= 0) { fprintf(stdout, \"SUCCESS: %s - %d\\n\", location, code); } } void HSM_soft_bind(zkCTX zk_ctx) { bool binding_is_locked = false; bool is_bound = false; int ret = zkGetCurrentBindingInfo(zk_ctx, \u0026binding_is_locked, \u0026is_bound); check_code(ret, \"zkGetCurrentBindingInfo\"); printf(\"Binding is locked: \"); printf(binding_is_locked ? \"true\" : \"false\"); printf(\"\\n\"); printf(\"SEN is bound: \"); printf(is_bound ? \"true\" : \"false\"); printf(\"\\n\\n\"); //ret = zkLockBinding(zk_ctx); //if(binding_is_locked \u0026\u0026 is_bound) //{ // check_code(ret, \"zkLockBinding - Already Bound\"); //} //else //{ // check_code(ret, \"zkLockBinding\"); //} //printf(\"\\n\"); ret = zkGetCurrentBindingInfo(zk_ctx, \u0026binding_is_locked, \u0026is_bound); check_code(ret, \"zkGetCurrentBindingInfo\"); printf(\"Binding is locked: \"); printf(binding_is_locked ? \"true\" : \"false\"); printf(\"\\n\"); printf(\"SEN is bound: \"); printf(is_bound ? \"true\" : \"false\"); printf(\"\\n\\n\"); } int main() { zkCTX zk_ctx; int status = zkOpen(\u0026zk_ctx); check_code(status, \"zkOpen\"); printf(\"\\n\\n\"); HSM_soft_bind(zk_ctx); status = zkClose(zk_ctx); check_code(status, \"zkClose\"); printf(\"\\n\"); return 0; } C++ - lockBinding #include \u003cstdio.h\u003e #include \u003czkAppUtilsClass.h\u003e using namespace std; using namespace zkAppUtils; void HSM_soft_bind(zkClass* zk_inst) { bool binding_is_locked = false; bool is_bound = false; zk_inst-\u003egetCurrentBindingInfo(binding_is_locked, is_bound); printf(\"Binding is locked: \"); printf(binding_is_locked ? \"true\" : \"false\"); printf(\"\\n\"); printf(\"SEN is bound: \"); printf(is_bound ? \"true\" : \"false\"); printf(\"\\n\"); //zk_inst-\u003elockBinding(); //printf(\"lockBinding successful\\n\"); zk_inst-\u003egetCurrentBindingInfo(binding_is_locked, is_bound); printf(\"Binding is locked: \"); printf(binding_is_locked ? \"true\" : \"false\"); printf(\"\\n\"); printf(\"SEN is bound: \"); printf(is_bound ? \"true\" : \"false\"); printf(\"\\n\"); } int main() { zkClass* zk_inst; zk_inst = new zkClass(); HSM_soft_bind(zk_inst); delete zk_inst; return 0; } Python - lock_binding import zymkey tup = zymkey.client.get_current_binding_info() print(\"SEN is bound: \" + str(tup[1])) print(\"Binding is locked: \" + str(tup[0])) #zymkey.client.lock_binding() tup = zymkey.client.get_current_binding_info() print(\"SEN is bound: \" + str(tup[1])) print(\"Binding is locked: \" + str(tup[0])) Warning Do not proceed without completing the steps outlined above, including setting the Perimeter Event Actions to none or notify. Prior to setting the Bind Lock. Finalize your device for deployment After using the APIs to lock binding, reboot. The blink pattern on the SEN will change to 3 rapid blinks once every 3 seconds to indicate that the SEN has bound to the host in Production Mode.\nIf you are using the Perimeter Detect features, close your perimeter circuits (for example, by closing the enclosure’s lid), and then clear any Perimeter Detect Events using the API:\npython3 -c \"import zymkey; idx = 0; zymkey.client.clear_perimeter_detect_info() for p in zymkey.client.get_perimeter_detect_info(): if p: print(f'Channel {idx} has a detected breach event. Clear the Perimeter Detect Events again.') idx += 1 else: print('No perimeter breach detected.')\" If you get a message that a breach event was detected from the above command, run it again to ensure all events have been cleared.\nWarning You only get one chance to set Perimeter Event Actions once you are in Production Mode! When it confirms that no breach events have been detected, it is then safe to arm the system by setting the Perimeter Event Actions to notify or selfdestruct, if desired.\nYour system is now armed and ready to be used in the field!\n","categories":"","description":"","excerpt":"If left in Development Mode, self-destruct events are simulated with …","ref":"/getting-started/sen/production-mode/","tags":"","title":"Enabling Production Mode - Secure Edge Node"},{"body":" DESTRUCTIVE ACTION THE BINDING PROCESS IS PERMANENT AND CANNOT BE REVERSED. PAY ATTENTION TO THE FOLLOWING:\nYour specific HSM4 will be permanently locked to the specific host device. It will be impossible to move or bind your HSM4 to another device. There are no factory resets, masterkeys, or other forms of recovery. If you are using the Perimeter Detect features, then the sequence in which you arm and disarm this feature is very important. Be sure to carefully follow the process steps below. Once you have locked your HSM4 into production mode, Zymbit cannot guarantee its operation if you subsequently do a major distribution upgrade (e.g. Raspbian Jessie to Stretch). Contact Zymbit for more information. If you decide that you are not ready for permanent binding, leave the HSM4 in developer mode, but beware this makes it easier for a bad actor to replace the host with rogue hardware.\nDESTRUCTIVE ACTION When you have completed your development work with the HSM4 and are ready to deploy your system into the field, we recommend that you permanently bind your HSM4 to a specific host device and SD card.\nResources Binding, Device ID, and Authentication HSM4 generates a unique Device ID by measuring certain attributes of the specific host and the HSM4 itself to permanently associate the two devices. Read article Summary of Steps Develop your application\nEnsure your host has all the necessary prerequisites in place to interface with the HSM4 and that it will be able to run your software application. Active production mode\nPermanently bind your HSM4 to the host device. Develop your application To begin, ensure that you have followed the Getting Started guide for your HSM4 carefully to install the prerequisite client software:\nResources HSM4 Install your HSM4 to a Raspberry Pi running Raspbian or Ubuntu before moving to production mode. Read article To reiterate, before you continue, the following steps should be complete:\nInstall a battery on the HSM4. Connect the GPIO header of the HSM4 to the GPIO pins of the host board while the host is powered down. Install HSM4 software on the host and establish temporary binding in development mode. After these steps have been completed, you are ready to prepare your device for permanent binding.\nPrepare Perimeter Detect The Perimeter Event Actions for your HSM4 should be set to none or notify only. If your HSM4’s action mode is set to selfdestruct, you might render your HSM4 useless while attempting to activate production mode.\nResources Perimeter Detect: HSM4 Understand how to use the HSM4’s perimeter detect features. Read article To do this quickly, with the HSM4 client libraries installed, you can run the following shell command to use the Python API to communicate with the HSM4 and set the Perimeter Event Actions to do nothing when triggered:\npython3 -c \"import zymkey; for ch in (0, 1): zymkey.client.set_perimeter_event_actions(ch, action_notify=False, action_self_destruct=False) zymkey.client.clear_perimeter_detect_info()\" Prepare your application If you intend to use your HSM4 to encrypt your root file system, you should complete that step now, using our guide. This step is highly recommended.\nResources Encrypting Root File System with Zymbit Security Modules Encrypt the root file system of your host device using LUKS and your HSM4. Read article You should then install your application on your host SBC (in the encrypted volume, if applicable).\nTest, debug, and test again Danger DO NOT skip this step. If you encounter a major issue with your application after your HSM4 has been permanently bound to your device and armed, you may not be able to fix it. Test the functionality of your application thoroughly to ensure it is free of major defects that will prevent it from functioning properly. After the HSM4 has been bound to your host SBC, especially if Perimeter Detect features are in use, it may be difficult to make significant chances to your configuration without locking youself out of the HSM4, depending on the nature of your application and its configuration.\nActivate production mode With the Zymkey, a physical tab was cut to go into production mode. In the HSM models, to go into production mode it only requires a function call followed by a reboot.\nThe API function lock binding puts the HSM into production mode. Below are three examples which check the current binding info, lock the HSM binding, then check the current binding info again. Remove the comments around the lock binding function to move to production mode.\nC - zkLockBinding // gcc example_binding.c -I /usr/include/zymkey -l zk_app_utils -o example_binding #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \"zk_app_utils.h\" #include \"zk_b64.h\" void check_code(int code, char* location){ if (code \u003c 0) { fprintf(stderr, \"FAILURE: %s - %s\\n\", location, strerror(code)); } else if (code \u003e= 0) { fprintf(stdout, \"SUCCESS: %s - %d\\n\", location, code); } } void HSM_soft_bind(zkCTX zk_ctx) { bool binding_is_locked = false; bool is_bound = false; int ret = zkGetCurrentBindingInfo(zk_ctx, \u0026binding_is_locked, \u0026is_bound); check_code(ret, \"zkGetCurrentBindingInfo\"); printf(\"Binding is locked: \"); printf(binding_is_locked ? \"true\" : \"false\"); printf(\"\\n\"); printf(\"HSM is bound: \"); printf(is_bound ? \"true\" : \"false\"); printf(\"\\n\\n\"); //ret = zkLockBinding(zk_ctx); //if(binding_is_locked \u0026\u0026 is_bound) //{ // check_code(ret, \"zkLockBinding - Already Bound\"); //} //else //{ // check_code(ret, \"zkLockBinding\"); //} //printf(\"\\n\"); ret = zkGetCurrentBindingInfo(zk_ctx, \u0026binding_is_locked, \u0026is_bound); check_code(ret, \"zkGetCurrentBindingInfo\"); printf(\"Binding is locked: \"); printf(binding_is_locked ? \"true\" : \"false\"); printf(\"\\n\"); printf(\"HSM is bound: \"); printf(is_bound ? \"true\" : \"false\"); printf(\"\\n\\n\"); } int main() { zkCTX zk_ctx; int status = zkOpen(\u0026zk_ctx); check_code(status, \"zkOpen\"); printf(\"\\n\\n\"); HSM_soft_bind(zk_ctx); status = zkClose(zk_ctx); check_code(status, \"zkClose\"); printf(\"\\n\"); return 0; } C++ - lockBinding #include \u003cstdio.h\u003e #include \u003czkAppUtilsClass.h\u003e using namespace std; using namespace zkAppUtils; void HSM_soft_bind(zkClass* zk_inst) { bool binding_is_locked = false; bool is_bound = false; zk_inst-\u003egetCurrentBindingInfo(binding_is_locked, is_bound); printf(\"Binding is locked: \"); printf(binding_is_locked ? \"true\" : \"false\"); printf(\"\\n\"); printf(\"HSM is bound: \"); printf(is_bound ? \"true\" : \"false\"); printf(\"\\n\"); //zk_inst-\u003elockBinding(); //printf(\"lockBinding successful\\n\"); zk_inst-\u003egetCurrentBindingInfo(binding_is_locked, is_bound); printf(\"Binding is locked: \"); printf(binding_is_locked ? \"true\" : \"false\"); printf(\"\\n\"); printf(\"HSM is bound: \"); printf(is_bound ? \"true\" : \"false\"); printf(\"\\n\"); } int main() { zkClass* zk_inst; zk_inst = new zkClass(); HSM_soft_bind(zk_inst); delete zk_inst; return 0; } Python - lock_binding import zymkey tup = zymkey.client.get_current_binding_info() print(\"HSM is bound: \" + str(tup[1])) print(\"Binding is locked: \" + str(tup[0])) #zymkey.client.lock_binding() tup = zymkey.client.get_current_binding_info() print(\"HSM is bound: \" + str(tup[1])) print(\"Binding is locked: \" + str(tup[0])) Warning Do not proceed without completing the steps outlined above, including setting the Perimeter Event Actions to none or notify. Finalize your device for deployment After using the APIs to lock binding, reboot. The blink pattern on the HSM4 will change to 3 rapid blinks once every 3 seconds to indicate that HSM4 has bound to the host in production mode.\nIf you are using the Perimeter Detect features, close your perimeter circuits (for example, by closing the enclosure’s lid), and then clear any Perimeter Detect Events using the API:\npython3 -c \"import zymkey; idx = 0; zymkey.client.clear_perimeter_detect_info() for p in zymkey.client.get_perimeter_detect_info(): if p: print(f'Channel {idx} has a detected breach event. Clear the Perimeter Detect Events again.') idx += 1 else: print('No perimeter breach detected.')\" If you get a message that a breach event was detected from the above command, run it again to ensure all events have been cleared. When it confirms that no breach events have been detected, it is then safe to arm the system by setting the Perimeter Event Actions to notify or selfdestruct, if desired.\nYour system is now armed and ready to be used in the field!\n","categories":"","description":"","excerpt":" DESTRUCTIVE ACTION THE BINDING PROCESS IS PERMANENT AND CANNOT BE …","ref":"/getting-started/hsm4/production-mode/","tags":"","title":"Enabling Production Mode - HSM4"},{"body":" DESTRUCTIVE ACTION THE BINDING PROCESS IS PERMANENT AND CANNOT BE REVERSED. PAY ATTENTION TO THE FOLLOWING:\nYour specific HSM6 will be permanently locked to the specific host device. It will be impossible to move or bind your HSM6 to another device. There are no factory resets, masterkeys, or other forms of recovery. If you are using the Perimeter Detect features, then the sequence in which you arm and disarm this feature is very important. Be sure to carefully follow the process steps below. Once you have locked your HSM6 into production mode, Zymbit cannot guarantee its operation if you subsequently do a major distribution upgrade (e.g. Raspbian Jessie to Stretch). Contact Zymbit for more information. If you decide that you are not ready for permanent binding, leave the HSM6 in developer mode, but beware this makes it easier for a bad actor to replace the host with rogue hardware.\nDESTRUCTIVE ACTION When you have completed your development work with the HSM6 and are ready to deploy your system into the field, we recommend that you permanently bind your HSM6 to a specific host device and SD card.\nResources Binding, Device ID, and Authentication HSM6 generates a unique Device ID by measuring certain attributes of the specific host and the HSM6 itself to permanently associate the two devices. Read article Summary of Steps Develop your application\nEnsure your host has all the necessary prerequisites in place to interface with the HSM6 and that it will be able to run your software application. Active production mode\nPermanently bind your HSM6 to the host device. Develop your application To begin, ensure that you have followed the Getting Started guide for your HSM6 carefully to install the prerequisite client software:\nResources HSM6 Install your HSM6 to a Raspberry Pi running Raspbian or Ubuntu before moving to production mode. Read article To reiterate, before you continue, the following steps should be complete:\nInstall a battery on the HSM6. Connect the GPIO header of the HSM6 to the GPIO pins of the host board while the host is powered down. Install HSM6 software on the host and establish temporary binding in development mode. After these steps have been completed, you are ready to prepare your device for permanent binding.\nPrepare Perimeter Detect The Perimeter Event Actions for your HSM6 should be set to none or notify only. If your HSM6’s action mode is set to selfdestruct, you might render your HSM6 useless while attempting to activate production mode.\nResources Perimeter Detect: HSM6 Understand how to use the HSM6’s perimeter detect features. Read article To do this quickly, with the HSM6 client libraries installed, you can run the following shell command to use the Python API to communicate with the HSM6 and set the Perimeter Event Actions to do nothing when triggered:\npython3 -c \"import zymkey; for ch in (0, 1): zymkey.client.set_perimeter_event_actions(ch, action_notify=False, action_self_destruct=False) zymkey.client.clear_perimeter_detect_info()\" Prepare your application If you intend to use your HSM6 to encrypt your root file system, you should complete that step now, using our guide. This step is highly recommended.\nResources Encrypting Root File System with Zymbit Security Modules Encrypt the root file system of your host device using LUKS and your HSM6. Read article You should then install your application on your host SBC (in the encrypted volume, if applicable).\nTest, debug, and test again Danger DO NOT skip this step. If you encounter a major issue with your application after your HSM6 has been permanently bound to your device and armed, you may not be able to fix it. Test the functionality of your application thoroughly to ensure it is free of major defects that will prevent it from functioning properly. After the HSM6 has been bound to your host SBC, especially if Perimeter Detect features are in use, it may be difficult to make significant chances to your configuration without locking youself out of the HSM6, depending on the nature of your application and its configuration.\nActivate production mode With the Zymkey, a physical tab was cut to go into production mode. In the HSM models, to go into production mode it only requires a function call followed by a reboot.\nThe API function lock binding puts the HSM into production mode. Below are three examples which check the current binding info, lock the HSM binding, then check the current binding info again. Remove the comments around the lock binding function to move to production mode.\nC - zkLockBinding // gcc example_binding.c -I /usr/include/zymkey -l zk_app_utils -o example_binding #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \"zk_app_utils.h\" #include \"zk_b64.h\" void check_code(int code, char* location){ if (code \u003c 0) { fprintf(stderr, \"FAILURE: %s - %s\\n\", location, strerror(code)); } else if (code \u003e= 0) { fprintf(stdout, \"SUCCESS: %s - %d\\n\", location, code); } } void HSM_soft_bind(zkCTX zk_ctx) { bool binding_is_locked = false; bool is_bound = false; int ret = zkGetCurrentBindingInfo(zk_ctx, \u0026binding_is_locked, \u0026is_bound); check_code(ret, \"zkGetCurrentBindingInfo\"); printf(\"Binding is locked: \"); printf(binding_is_locked ? \"true\" : \"false\"); printf(\"\\n\"); printf(\"HSM is bound: \"); printf(is_bound ? \"true\" : \"false\"); printf(\"\\n\\n\"); //ret = zkLockBinding(zk_ctx); //if(binding_is_locked \u0026\u0026 is_bound) //{ // check_code(ret, \"zkLockBinding - Already Bound\"); //} //else //{ // check_code(ret, \"zkLockBinding\"); //} //printf(\"\\n\"); ret = zkGetCurrentBindingInfo(zk_ctx, \u0026binding_is_locked, \u0026is_bound); check_code(ret, \"zkGetCurrentBindingInfo\"); printf(\"Binding is locked: \"); printf(binding_is_locked ? \"true\" : \"false\"); printf(\"\\n\"); printf(\"HSM is bound: \"); printf(is_bound ? \"true\" : \"false\"); printf(\"\\n\\n\"); } int main() { zkCTX zk_ctx; int status = zkOpen(\u0026zk_ctx); check_code(status, \"zkOpen\"); printf(\"\\n\\n\"); HSM_soft_bind(zk_ctx); status = zkClose(zk_ctx); check_code(status, \"zkClose\"); printf(\"\\n\"); return 0; } C++ - lockBinding #include \u003cstdio.h\u003e #include \u003czkAppUtilsClass.h\u003e using namespace std; using namespace zkAppUtils; void HSM_soft_bind(zkClass* zk_inst) { bool binding_is_locked = false; bool is_bound = false; zk_inst-\u003egetCurrentBindingInfo(binding_is_locked, is_bound); printf(\"Binding is locked: \"); printf(binding_is_locked ? \"true\" : \"false\"); printf(\"\\n\"); printf(\"HSM is bound: \"); printf(is_bound ? \"true\" : \"false\"); printf(\"\\n\"); //zk_inst-\u003elockBinding(); //printf(\"lockBinding successful\\n\"); zk_inst-\u003egetCurrentBindingInfo(binding_is_locked, is_bound); printf(\"Binding is locked: \"); printf(binding_is_locked ? \"true\" : \"false\"); printf(\"\\n\"); printf(\"HSM is bound: \"); printf(is_bound ? \"true\" : \"false\"); printf(\"\\n\"); } int main() { zkClass* zk_inst; zk_inst = new zkClass(); HSM_soft_bind(zk_inst); delete zk_inst; return 0; } Python - lock_binding import zymkey tup = zymkey.client.get_current_binding_info() print(\"HSM is bound: \" + str(tup[1])) print(\"Binding is locked: \" + str(tup[0])) #zymkey.client.lock_binding() tup = zymkey.client.get_current_binding_info() print(\"HSM is bound: \" + str(tup[1])) print(\"Binding is locked: \" + str(tup[0])) Warning Do not proceed without completing the steps outlined above, including setting the Perimeter Event Actions to none or notify. Finalize your device for deployment After using the APIs to lock binding, reboot. The blink pattern on the HSM6 will change to 3 rapid blinks once every 3 seconds to indicate that HSM6 has bound to the host in production mode.\nIf you are using the Perimeter Detect features, close your perimeter circuits (for example, by closing the enclosure’s lid), and then clear any Perimeter Detect Events using the API:\npython3 -c \"import zymkey; idx = 0; zymkey.client.clear_perimeter_detect_info() for p in zymkey.client.get_perimeter_detect_info(): if p: print(f'Channel {idx} has a detected breach event. Clear the Perimeter Detect Events again.') idx += 1 else: print('No perimeter breach detected.')\" If you get a message that a breach event was detected from the above command, run it again to ensure all events have been cleared. When it confirms that no breach events have been detected, it is then safe to arm the system by setting the Perimeter Event Actions to notify or selfdestruct, if desired.\nYour system is now armed and ready to be used in the field!\n","categories":"","description":"","excerpt":" DESTRUCTIVE ACTION THE BINDING PROCESS IS PERMANENT AND CANNOT BE …","ref":"/getting-started/hsm6/production-mode/","tags":"","title":"Enabling Production Mode - HSM6"},{"body":" DESTRUCTIVE ACTION THE BINDING PROCESS IS PERMANENT AND CANNOT BE REVERSED. PAY ATTENTION TO THE FOLLOWING:\nYour specific ZYMKEY4 will be permanently locked to the specific host device. It will be impossible to move or bind your ZYMKEY4 to another device. There are no factory resets, masterkeys, or other forms of recovery. If you are using the Perimeter Detect features, then the sequence in which you arm and disarm this feature is very important. Be sure to carefully follow the process steps below. Once you have locked your ZYMKEY4 into production mode, Zymbit cannot guarantee its operation if you subsequently do a major distribution upgrade (e.g. Raspbian Jessie to Stretch). Contact Zymbit for more information. If you decide that you are not ready for permanent binding, leave the ZYMKEY4 in developer mode, but beware this makes it easier for a bad actor to replace the host with rogue hardware.\nDESTRUCTIVE ACTION When you have completed your development work with the ZYMKEY4 and are ready to deploy your system into the field, we recommend that you permanently bind your ZYMKEY4 to a specific host device and SD card.\nResources Binding, Device ID, and Authentication ZYMKEY4 generates a unique Device ID by measuring certain attributes of the specific host and the ZYMKEY4 itself to permanently associate the two devices. Read article Summary of Steps Develop your application Ensure your host has all the necessary prerequisites in place to interface with the ZYMKEY4 and that it will be able to run your software application. Active production mode Permanently bind your ZYMKEY4 to the host device. Develop your application DESTRUCTIVE ACTION DO NOT cut the lock tab yet. DESTRUCTIVE ACTION To begin, ensure that you have followed the Getting Started guide for your ZYMKEY4 carefully to install the prerequisite client software:\nResources ZYMKEY4 Install your ZYMKEY4 to a Raspberry Pi running Raspbian or Ubuntu before moving to production mode. Read article To reiterate, before you continue, the following steps should be complete:\nInstall a battery on the ZYMKEY4. Connect the GPIO header of the ZYMKEY4 to the GPIO pins of the host board while the host is powered down. Install ZYMKEY4 software on the host and establish temporary binding in development mode. After these steps have been completed, you are ready to prepare your device for permanent binding.\nPrepare Perimeter Detect The Perimeter Event Actions for your ZYMKEY4 should be set to none or notify only. If your ZYMKEY4’s action mode is set to selfdestruct, you might render your ZYMKEY4 useless while attempting to activate production mode.\nResources Perimeter Detect: ZYMKEY4 Understand how to use the ZYMKEY4’s perimeter detect features. Read article To do this quickly, with the ZYMKEY4 client libraries installed, you can run the following shell command to use the Python API to communicate with the ZYMKEY4 and set the Perimeter Event Actions to do nothing when triggered:\npython3 -c \"import zymkey; for ch in (0, 1): zymkey.client.set_perimeter_event_actions(ch, action_notify=False, action_self_destruct=False) zymkey.client.clear_perimeter_detect_info()\" Prepare your application If you intend to use your ZYMKEY4 to encrypt your root file system, you should complete that step now, using our guide. This step is highly recommended.\nResources Encrypting Root File System with Zymbit Security Modules Encrypt the root file system of your host device using LUKS and your ZYMKEY4. Read article You should then install your application on your host SBC (in the encrypted volume, if applicable).\nTest, debug, and test again Danger DO NOT skip this step. If you encounter a major issue with your application after your ZYMKEY4 has been permanently bound to your device and armed, you may not be able to fix it. Test the functionality of your application thoroughly to ensure it is free of major defects that will prevent it from functioning properly. After the ZYMKEY4 has been bound to your host SBC, especially if Perimeter Detect features are in use, it may be difficult to make significant chances to your configuration without locking youself out of the ZYMKEY4, depending on the nature of your application and its configuration.\nActivate production mode Danger DO NOT cut the lock tab yet. Before proceeding, shut your host board down and disconnect it from power. Then, without removing the ZYMKEY4’s battery (if installed), remove the ZYMKEY4 from the host SBC.\nCut the lock tab Warning This procedure can be performed while the ZYMKEY4 is connected to the host SBC, but the host must be disconnected from power.\nDo not proceed without completing the steps outlined above, including setting the Perimeter Event Actions to none or notify.\nFollow the procedure below carefully to move your ZYMKEY4 into production mode.\n1. Use sharp diagonal cutter pliers 2. Cut the tab Align the pliers with the guide lines on the Cut-2-Lock tab, and carefully cut the tab. 3. Finish the cut The resulting cut should leave the edge of the ZYMKEY4 motherboard flush. If portions of the tab remain attached to the board, you can remove them with the angle cutter pliers. Finalize your device for deployment After cutting the lock tab, reinstall the ZYMKEY4 the host SBC, reconnect it to power, and boot into the host. The blink pattern on the ZYMKEY4 will change to 3 rapid blinks once every 3 seconds to indicate that ZYMKEY4 has bound to the host in production mode.\nIf you are using the Perimeter Detect features, close your perimeter circuits (for example, by closing the enclosure’s lid), and then clear any Perimeter Detect Events using the API:\npython3 -c \"import zymkey; idx = 0; zymkey.client.clear_perimeter_detect_info() for p in zymkey.client.get_perimeter_detect_info(): if p: print(f'Channel {idx} has a detected breach event. Clear the Perimeter Detect Events again.') idx += 1 else: print('No perimeter breach detected.')\" If you get a message that a breach event was detected from the above command, run it again to ensure all events have been cleared. When it confirms that no breach events have been detected, it is then safe to arm the system by setting the Perimeter Event Actions to notify or selfdestruct, if desired.\nYour system is now armed and ready to be used in the field!\n","categories":"","description":"","excerpt":" DESTRUCTIVE ACTION THE BINDING PROCESS IS PERMANENT AND CANNOT BE …","ref":"/getting-started/zymkey4/production-mode/","tags":"","title":"Enabling Production Mode - ZYMKEY4"},{"body":" Bootware File Structure Overview: Brief description of Bootware files that complete the Bootware process.\nLocation: /boot or /boot/firmware Critical Files: Filename: config.txt\nDescription: RPi Configuration File\nCritical Lines:\ndtoverlay=dwc2,dr_mode=host kernel=u-boot.bin enable_uart=1 Filename: u-boot.bin\nDescription: U-Boot Bootloader\nFunctions: Loads and executes boot script\nFilename: boot.scr\nDescription: U-Boot Boot Script\nFunctions:\nGenerates U-Boot Environment Updates U-Boot Environment Loads and Boots Kernel Filename: zboot.enc\nDescription: zboot (Bootware zboot Module)\nFunctions:\nInitialize Bootware Perform Update Perform Rollback Perform Recovery Filename: zb_config.enc\nDescription: zboot Configuration File - Generated by zbcli update-config\nFilename: uboot.env\nDescription: u-Boot Environment\nFilename: usr-kernel.enc\nDescription: Encrypted Kernel - Generated by zboot\nNon-Critical Files: Filename: zboot.log\nDescription: zboot Log File\nzbconfig zbcli config-update internally uses the zbconfig tool to configure the device environment. Developers may directly use the zbconfig CLI interface instead of the zbcli config-update to configure their device environment.\nzbconfig simply reads and writes values to an encrypted JSON file (/boot/zb_config.enc) that bootware uses to apply updates. The values that can be configured are listed below:\nValue Type Description one_root_fs Boolean True will facilitate A only filesystems, while false enables A/B filesystems. resize_a Boolean If one_root_fs is true, this parameter is checked for resizing A only filesystems.\ntrue - full disk\nfalse - half disk update_mode String This parameter is only checked for A/B filesystems. Set the policy for the updates: UPDATE_ACTIVE UPDATE_BACKUP UPDATE_BOTH update_endpoint String The endpoint where new images are pulled from. Example https URL: https://zk-sw-repo.s3.amazonaws.com/ota_preview/base_ota.zi\nExample USB stick: /dev/sda1 endpoint_type String The type of endpoint for the update_endpoint param. Value must be all uppercase.\nHTTPS\nUSB update_name String The name of the .zi image that will be used for the update. If the name of the new update is base_ota.zi, this parameter needs to be named “base_ota ","categories":"","description":"Detailed information about important Bootware files","excerpt":"Detailed information about important Bootware files","ref":"/bootware/troubleshooting/file-info/","tags":"","title":"Bootware Additional Info"},{"body":"Updated: 2023-01-22\nWhat is Supervised Boot? Supervised Boot is Zymbit’s method for insuring that the boot process is secure. A list of files can be specifed to be hashed, signed, and verified by the SCM prior to allowing the CM4 module to boot. By default, the following files are signed and verified:\n/boot/bcm2711-rpi-cm4.dtb /boot/cmdline.txt /boot/config.txt /boot/initrd.img /boot/kernel8.img (or /boot/kernel7l.img for 32-bit) /boot/start4.elf /boot/zymbit_mac_address /boot/overlays/vc4-kms-v3d.dtbo The Manifest The Manifest is the list of files that will be tracked and verified by the Zymbit Secure Compute Module (SCM) during the boot process. The Manifest resides within the SCM itself. It does not live on any file system. Zymbit provides an API interface to add/update/delete entries in the Manifest as well as set the action to take if a signature verification of a file should fail.\nAll files in the Manifest must reside within the /boot partition. File paths in the Manifest all include /boot/ by default. Only include the portion of the file path after /boot/. For instance, to include /boot/config.txt, you would call our API with the string config.txt.\nIf any file exists in the Manifest, Supervised Boot is automatically enabled. To turn off Supervised Boot, remove all files from the Manifest.\nExample Python CLI Application Prerequisites Zymbit Modules that support this feature:\nSecure Compute Module (SCM ) All code snippets written in this article are written using Python3. For more Zymbit API documentation (Python/C/C++) visit: API Documentation\nExample Application The code below can be used to add/update/delete and display the Manifest of files to check during Secure Boot operation. It can also update all the files in the Manifest or delete all the files in the Manifest. Save the code below to a file. We will name it manifest.py for the following examples.\n#!/usr/bin/python3 import argparse import zymkey def add_update(filepath, slot=None): if slot: print(f\"Manifest Add/Update {filepath} slot={slot}\") zymkey.client.add_or_update_supervised_boot_file(filepath, int(slot)) else: print(f\"Manifest Add/Update {filepath} default slot=15\") zymkey.client.add_or_update_supervised_boot_file(filepath) def update_all_entries(slot=None): list = zymkey.client.get_supervised_boot_file_manifest() if len(list) == 0: print(\"Manifest is empty\") else: for filepath in list.split(): add_update(filepath, slot) def delete(filepath): print(f\"Manifest Delete: {filepath}\") zymkey.client.remove_supervised_boot_file(filepath) def delete_all_entries(): list = zymkey.client.get_supervised_boot_file_manifest() if len(list) == 0: print(\"Manifest is empty\") else: for filepath in list.split(): delete(filepath) def show(): print(\"\\nManifest:\") print(\"---------\") list = zymkey.client.get_supervised_boot_file_manifest() if len(list) == 0: print(\"Manifest is empty\") else: for filepath in list.split(): print(filepath) print(\"\") if __name__ == \"__main__\": # Setup arg parser parser = argparse.ArgumentParser( description=\"add/del/update Supervised Boot Manifest. (show by default)\", epilog=\"filepath from /boot. ex: for /boot/config.txt, provide config.txt.\" ) group = parser.add_mutually_exclusive_group() group.add_argument(\"-a\", \"--add\", metavar=\"filepath\", help=\"add filepath to manifest\", action=\"store\", required=False) group.add_argument(\"-u\", \"--update\", metavar=\"filepath\", help=\"update filepath in manifest\", action=\"store\", required=False) group.add_argument(\"-U\", help=\"update all entries in manifest\", action=\"store_true\", required=False) group.add_argument(\"-d\", \"--delete\", metavar=\"filepath\", help=\"delete filepath from manifest\", action=\"store\", required=False) group.add_argument(\"-D\", help=\"delete all entries from manifest\", action=\"store_true\", required=False) parser.add_argument(\"-s\", \"--slot\", metavar=\"slot_num\", help=\"use slot for add/delete (default=15)\", action=\"store\", required=False) args = parser.parse_args() parser.parse_args() if args.add: add_update(args.add, args.slot) elif args.update: add_update(args.update, args.slot) elif args.U: print(\"Updating all entries in manifest...\") update_all_entries(args.slot) elif args.delete: delete(args.delete) elif args.D: print(\"Deleting all entries from manifest...\") delete_all_entries() show() Working with the Manifest Running the example with no parameters will display the current contents of the Manifest. The default Manifest as shipped contains:\n$ ./manifest.py Manifest: --------- bcm2711-rpi-cm4.dtb bootcode.bin cmdline.txt config.txt initrd.img kernel8.img start4.elf zymbit_mac_address overlays/vc4-kms-v3d.dtbo To add a file to the Manifest, run the example script with the --add option and give it a filepath to a file in /boot. We’ll create a sample file by copying /etc/hosts,\n$ sudo cp /etc/hosts /boot/sample.txt $ ./manifest.py --add sample.txt Manifest: --------- bcm2711-rpi-cm4.dtb bootcode.bin cmdline.txt config.txt initrd.img kernel8.img start4.elf zymbit_mac_address overlays/vc4-kms-v3d.dtbo sample.txt The SCM will create a signature for the file sample.txt and store it internally. The SCM will verify that signature against the file upon the next boot. If the signature does not verify, the SCM will be held in reset and will not boot. In Development Mode (no bind lock), the SCM will “simulate” this process by flashing an LED sequence of 4 followed by 2 flashes, repeated three times, and then the SCM will boot normally.\nYou can test this out:\nFirst, after adding sample.txt to the Manifest and power cycle. The system should boot normally. Next, edit /boot/sample.txt and power cycle. The sign/verify process will fail and the SCM will simulate a Held in Reset condition with a sequence of 4 flashes followed by 2 flashes, three times. If left in Development Mode (no bind lock), the SCM will boot up and allow you to recover. There are three ways you can remedy the verification failure:\nEdit /boot/sample.txt and revert back to its original contents. Update the Manifest to sync up the current contents of the file with the Manifest ./manifest.py --update sample.txt Remove the file from the Manifest with `./manifest.py –delete ./manifest.py --delete sample.txt The next powercycle should boot with the normal sequence - it should not flash the 4 flashes followed by 2 flashes, three times sequence.\nSpecifying a Different Slot The example above uses the default slot 15 but will take alternative slot numbers, 0-15. Slots in the key store (Slots 16-528) are not supported.\n","categories":"","description":"","excerpt":"Updated: 2023-01-22\nWhat is Supervised Boot? Supervised Boot is …","ref":"/tutorials/supervised-boot/","tags":"","title":"Working with SCM Supervised Boot"},{"body":"Introduction While all Zymbit modules make it trivial to verify data signed on the device with that module, verifying the signature of data on other devices using the exportable public key requires a little more explanation. Below is a simple code snippet to show how to verify the signature of data using Zymbit’s Python API.\n#!/usr/bin/python3 import zymkey # sign data data = 'hello world!' payload_sig = zymkey.client.sign(data) # verify signature matches encrypted data try: if zymkey.client.verify(data, payload_sig): print('Signature signed correctly by Zymbit module and matches payload.') except Exception as e: print('Signature invalid. Data not signed by Zymbit module private key.') Since the IoT environment is all about communication among many devices, we will demonstrate how to verify a Zymbit module’s ECDSA signature on other devices. We will do this using the public key corresponding to the device’s private key stored securely on the Zymbit module.\nAfter showing how to do signature verification, we will demonstrate how this can be used in a practical situation by collecting temperature data from a sensor and signing the data. We will then package the data in JSON format - a standard format for data communication over the internet using strings. This data will then be published to AWS IoT, where it will be routed via a Rule to a Lambda Function. The Lambda Function will validate the data based on the public key. From there you can route the data to any service you desire.\nThis post will demonstrate how to validate the signatures of all data sent to AWS before processing by another service. All data published to AWS will be authenticated against a device certificate which validates against the Zymbit module’s private key without exporting said key. We will do this by making HTTPS requests to AWS IoT using PyCurl. This serves as client authentication when connecting to AWS IoT. All these examples will be done via Python using the Python-ECDSA library.\nPrerequisites Follow the Getting Started guide first, installing all baseline software. If you wish to try Signature validation on AWS, you need a valid device certificate attached to your AWS account. The device certificate needs to have a policy attached giving it permission to publish data. Simple Signature Validation against Zymkey Public Key Installing Python-Ecdsa library For the verification of ECDSA-NIST256 signatures, we will be using the Python-ECDSA library. Using Pip, the library can be installed simply by running the following command:\nsudo pip3 install ecdsa Simple Signature Verification with Public Key Below is a simple Python program demonstrating how to verify a Zymbit module signature with a public key hosted on a device bound to that Zymbit module. The data passed to the ECDSA verifying function is in bytearray format. The function is validating against the default signing hash function Zymbit module uses, sha256, and returns a boolean indicating whether the signature matches the public key and data. The public key for Zymkey is exported as bytearray using the API function get_public_key().\n#!/usr/bin/python3 import zymkey import ecdsa import hashlib # Function to verify ECDSA signatures, all arguments must be in bytearray format. # Validating against Zymkey signing's default hashing function, sha256 but this can be modified. def verify_ecdsa_signature(data, sig, pub_key): vk = ecdsa.VerifyingKey.from_string(pub_key, ecdsa.NIST256p) return vk.verify(sig, data, hashfunc=hashlib.sha256) if __name__ == \"__main__\": # exporting Zymkey public key as bytearray pub_key = zymkey.client.get_public_key(slot=0, foreign=False) data = 'hello world!' data_bytes = bytearray(data, 'utf-8') payload_sig = zymkey.client.sign(data) if verify_ecdsa_signature(data=data_bytes, sig=payload_sig, pub_key = pub_key): print('Signature matches data and public key pair.') else: print('Signature is invalid; it does not correspond to the public key.') Signature Verification on Another Device This next section will simulate signature verification on another device that receives data in JSON format that has been signed with a Zymbit module. The public key is hard coded into the program for the sake of a simple demonstration, but public key exchange between devices is up to the discretion of the user.\nThe data payload and signature is passed in a JSON string in the format of a hex string. Hex strings are simply representations of the underlying bytes in a human readable format. The JSON data is represented below as the variable received_payload. For this example, we are using received_payload data generated with the following example code on your device with the Zymbit module.\nExport Public Key and Generate Example JSON Data for Validation\n#!/usr/bin/python3 import json import zymkey if __name__ == \"__main__\": # Get public key to give to remote pub_key = zymkey.client.get_public_key() print(\"Public key:\") print(pub_key.hex()) # Create data then sign data data = 'hello world' data_bytes = bytearray(data, 'utf-8') signature = zymkey.client.sign(data) # Store data in a python dictionary that represents JSON. Data is originally in bytearray form # but will be converted to hex_string json_dictionary = { 'data': data_bytes.hex(), 'signature': signature.hex() } # Convert python dictionary to JSON string format received_payload = json.dumps(json_dictionary) print(\"\\nJSON string:\") print(received_payload) Python Code to Verify Signature with Data Generated above Either substitute in your pub_key and JSON data from the previous example or use as is.\n#!/usr/bin/python3 import json import zymkey import hashlib import ecdsa def verify_ecdsa_signature(data, sig, pub_key): vk = ecdsa.VerifyingKey.from_string(pub_key, ecdsa.NIST256p) return vk.verify(sig, data, hashfunc=hashlib.sha256) if __name__ == \"__main__\": # Zymkey public key in hex string format. Converted to byte_array, public key storage/exchange up to user. pub_key = bytearray.fromhex('6cd0b8b14963f6712877eb50a3f5afa9c0e39483e560f58eb795e634df53f399ba370dbceb71ea87cba5e2fca4f23ef73b8e683a9946758829f76521e7a19e5a') ''' The variable received_payload will be the JSON string sent over to this device from the Zymkey. It contains 1.the data and 2.the signature for this data. See next code example to create an example. Here is how it will be formatted: \"{ 'data': 'hex_string of data', 'signature': 'hex_string of signature; }\" ''' received_payload = '{ \"data\": \"68656c6c6f20776f726c64\", \"signature\": \"28953e99dcc7f7ebf2771acae9e996e45997a212f7deba04a5974d1db6651fc8c50f11a5e5ad24ef25bdf0dafbdb736513f618184505f469f126c7dd4557cade\" }' # Converting JSON string to Python dictionary for easier manipulation payload_pydict = json.loads(received_payload) # Getting the hex_strings from the new Python dictionary payload = payload_pydict['data'] payload_sig = payload_pydict['signature'] # Validating signature against public key and data, converting all hex_strings to bytearrays. if verify_ecdsa_signature(data=bytearray.fromhex(payload), sig=bytearray.fromhex(payload_sig), pub_key=pub_key): print('Signature matches data and public key pair.') else: print('Signature is invalid; it does not correspond to the public key.') Validation of Sensor Data Signature on AWS This example will generate randomly simulated temperature sensor data, package the data into JSON format, and sign and send to send to AWS IoT. The function read_temp() will return an array containing random values for temp_c and temp_f.\nNotice If you wish to use an actual DS18B20 OneWire probe to collect temperature data, you can follow the instructions at this link.\nResources Using a DS18B20 OneWire Probe to Collect Temperature Data Read article Add this code and substitute for the read_temp() function in the example below. This code collects Temperature data from the probe. It reads from a file that the probes deposit temperature data to. The function read_temp() will return an array containing temp_c and temp_f, whenever you need to read temperature from the probes. Substitute this next snippet of code if you are using a real probe.\n#!/usr/bin/python3 os.system('modprobe w1-gpio') os.system('modprobe w1-therm') base_dir = '/sys/bus/w1/devices/' device_folder = glob.glob(base_dir + '28*')[0] device_file = device_folder + '/w1_slave' def read_temp(): # Supplies random temperature in Celsius and Farenheit for this example. lines = read_temp_raw() while lines[0].strip()[-3:] != 'YES': time.sleep(0.2) lines = read_temp_raw() equals_pos = lines[1].find('t=') if equals_pos != -1: temp_string = lines[1][equals_pos+2:] temp_c = float(temp_string) / 1000.0 temp_f = temp_c * 9.0 / 5.0 + 32.0 return temp_c, temp_f Collect data in JSON format, sign, and prepare for AWS\n#!/usr/bin/python3 import json import random import time import zymkey ''' Note that JSON data needs to be in this format: \"{ 'data': 'hex_string of data', 'signature': 'hex_string of signature; }\" If you wish to use a different JSON format, you can always modify the lambda function. ''' def read_temp(): # this provides simulated random data for the example temp_c = float(random.randint(0,100)) temp_f = temp_c * 9.0 / 5.0 + 32.0 return temp_c, temp_f while True: temp_C, temp_F = read_temp() deviceID = 1 myIP= '192.168.100.100' # Package the data in Python dictionary, then convert to JSON string. data = {'temp_F': temp_F, 'temp_C': temp_C, 'deviceIP': myIP, 'deviceID': deviceID} # sign the JSON string json_str = json.dumps(data) json_str_bytes = bytearray(json_str, 'utf-8') signature = zymkey.client.sign(json_str) # Make a new dictionary to hold the hex_strings of the data and signature, and then turn into JSON json_data = json.dumps({'data': json_str_bytes.hex(), 'signature': signature.hex()}) print(json_data) # 10 seconds before reading temperature again time.sleep(10) Sending Encrypted Temperature Data to AWS The AWS SDK doesn’t support TLS connections over OpenSSL engines. Therefore, since we keep the private key in the Zymbit module and not the file system, we will use CURL to make HTTPS requests to AWS with the Zymbit module’s embedded private key. We will be using PyCurl to do this programatically.\nInstalling PyCurl\nPyCurl is simply a wrapper on the libssl library for C/C++. Install and configure libssl library along with PyCurl:\nsudo apt-get install libcurl4-openssl-dev sudo apt-get install libssl-dev sudo pip install pycurl Registering Zymbit module device Certificate\nConnecting to and Publishing data to AWS IoT requries you to present a valid certificate that has been regsitered with your AWS account. Instructions for that process is outlined here. Make sure that the certificate has a policy attached to allow data publication on AWS, if you follow the post completely this should be done.\nPublishing data to AWS IoT\nNext we will publish the temperature data signed and saved from the last section to AWS IoT using PyCurl. Make sure to find and change your AWS IoT endpoint in the following code. Information on how to do this can be found in the tutorial linked above.\n#!/usr/bin/python3 import json import pycurl import random import time import zymkey def read_temp(): temp_c = float(random.randint(0,100)) temp_f = temp_c * 9.0 / 5.0 + 32.0 return temp_c, temp_f def ZK_AWS_Publish(url, post_field, CA_Path, Cert_Path,): c = pycurl.Curl() # Set Curl to use zymkey_ssl engine c.setopt(c.SSLENGINE, \"zymkey_ssl\") c.setopt(c.SSLVERSION, c.SSLVERSION_TLSv1_2) # Set certificates for HTTPS connection c.setopt(c.SSLCERT, Cert_Path) c.setopt(c.CAINFO, CA_Path) # Set endpoint and HTTPS type, here it is a POST c.setopt(c.URL, url) c.setopt(c.POSTFIELDS, post_field) # Tell Curl to do client and host authentication c.setopt(c.SSL_VERIFYPEER, 1) c.setopt(c.SSL_VERIFYHOST, 2) # Turn on Verbose output and set key as placeholder, not actually a real file. c.setopt(c.VERBOSE, 1) c.setopt(c.SSLKEYTYPE, \"ENG\") c.setopt(c.SSLKEY, \"nonzymkey.key\") c.perform() c.close() if __name__ == '__main__': while True: temp_C, temp_F = read_temp() deviceID = 1 myIP= '192.168.100.100' # Package the data in Python dictionary, then convert to JSON string. data = {'temp_F': temp_F, 'temp_C': temp_C, 'deviceIP': myIP, 'deviceID': deviceID} # sign the JSON string json_str = json.dumps(data) json_str_bytes = bytearray(json_str, 'utf-8') signature = zymkey.client.sign(json_str) # Make a new dictionary to hold the hex_strings of the data and signature, and then turn into JSON json_data = json.dumps({'data': json_str_bytes.hex(), 'signature': signature.hex()}) # make sure and substitute you AWS endpoint as well as the paths to your certificate AWS_ENDPOINT = 'https://\u003cendpoint\u003e.amazonaws.com:8443/topics/pub_key_validate?qos=1' ZK_AWS_Publish(url=AWS_ENDPOINT, post_field=json_data, CA_Path='/home/pi/verify-sig/AWS_CA.pem', Cert_Path='/home/pi/verify-sig/zymkey.crt') time.sleep(10) Checking Data is being published to AWS IoT If all the previous steps have been done correctly, then you should be able to see the JSON string you published on the AWS IoT console. It will be published to the topic pub_key_validate. This is encoded in the endpoint link you can see in the code. The topic can be changed to whatever you want. Here’s how to check the data from the AWS IoT console:\nFrom the AWS console, select AWS IoT. On the left hand bar, select Test. If MQTT Test is shown choose that. Under subscription topic, write pub_key_validate and hit subscribe. You should see your data being shown as it is being published. Verifying Signature of Encrypted Data with Zymkey Public Key on AWS Signature Verification Lambda function An AWS Lambda function is code that runs on the cloud based on a configured trigger. For this demonstration, the trigger will be data published to a specific topic, pub_key_validate, on AWS IoT. From there the lambda function can validate signatures and talk with any other AWS service.\nThe function is written in terms of a lambda_handler. The event that it gets passed is the JSON string published to AWS IoT. The Python lambda context automatically converts event from a JSON string to Python dictionary.\n#!/usr/bin/python3 import ecdsa import json import hashlib def verify_ecdsa_signature(data, sig, pub_key): vk = ecdsa.VerifyingKey.from_string(pub_key, ecdsa.NIST256p) return vk.verify(sig, data, hashfunc=hashlib.sha256) def lambda_handler(event, context): #event is already converted from json-\u003epython dict pub_key_byte = bytearray.fromhex('9929a80b1d2e1543992dc767f394d1859bc33e9b241203f53473d859e1506f7ee5593b53a7fe7014aecc1f14886e1440e6bde27571c596a7ae3d1573e4122d90') byte_data = bytearray.fromhex(event['data']) byte_signature = bytearray.fromhex(event['signature']) success_message = 'Signature is authenticated against public key and data presented; it is valid.' fail_message = 'Signature authentication has failed.' if verify_ecdsa_signature(data=byte_data, sig=byte_signature, pub_key=pub_key_byte): print(success_message) return success_message else: print(fail_message) return fail_message Setting up Lambda function on AWS\nThe lambda function is the python code that actually validates your Zymbit module signature. The data in JSON format will be published to AWS IoT, and then routed to the lambda function. This is triggered by an IoT rule. This basic lambda function will take the JSON string, validate the data using the Python-ECDSA package, and then print and log its success status.\nTo set up the lambda function on AWS, we must first package the code with the ECDSA package, since it is not part of the Python STL. To do this we zip up the lambda code with the ECDSA package in the build directory.\nPackaging function with Python-ECDSA\nYou can download a pre-configured zip file with Python-ECDSA included here. You can modify the lambda function however you want here, but make sure you change the public key in particular if you want to test out simple validation. If you change the lambda function make sure it is changed inside the zip file.\nOtherwise just zip up the lambda function with the ecdsa directory you made in the build directory. You can do this by first cloning the Github repository. Then build the project by running this build command while inside the project directory.\npython setup.py build Find the ecdsa directory inside the build directory, and zip up that directory with your code.\nNow, follow these steps to upload and activate your code on AWS:\nFrom the AWS Console, select Lambda Select the orange Create function button Choose to Author from Scratch Click next, the trigger will be configured later. Give the Lambda function an appropriate Name and Description. Select Python 2.7 as the Runtime. Under Code entry type, choose to Upload a .ZIP file Upload your Zip file, making sure you have adjusted the public key for the lambda. For Handler make sure to change it to Signature_Validation_Lambda.lambda_handler Choose to Create A Role if you don’t already have one with basic logging privileges. Give it an appropriate name and choose a policy template, picking basicedgelambda. Finally, click next and then create function. Testing Lambda function is working properly\nAWS’ lambda function can be given sample JSON input to test the function. So what we can do is create data and sign it with Zymkey then convert it to a hex string locally, and then copy these strings as input into the lambda function. If the public key in the lambda function you set up is the complement to your Zymkey, it will validate correctly. Here we will use python to print out the JSON string we need.\n#!/usr/bin/python3 import zymkey import json data = bytearray('hello world~') signature = zymkey.client.sign(data) python_dictionary = {'data': data, 'signature': signature} print(json.dumps(python_dictionary)) Copy the output string, you will need to paste it onto the AWS test inputs. From the AWS Lambda console, select your lambda function and click Test. Paste your JSON string as the input. It should return and print a success message.\nCreating AWS IoT Rule\nThe final step is to create a trigger for the Lambda function. Here we will make a Rule in AWS IoT, so that all data published to pub_key_readings are routed to and trigger your Lambda function.\nFrom your AWS Console, click on the AWS IoT service. On the left hand side, select Rules and then click the blue Create button. Give it an appropriate Name and Description. Using SQL version 2016-03-23 use the following settings: Attribute: * Topic Filter: pub_key_reading Set it to trigger a lambda function, and select the lambda function you created for signature validation.\nSeeing it all in Action\nThe whole data pipeline goes like this:\npython collects data -\u003e zymkey signs data -\u003e python packages data to json -\u003e pycurl publish data to AWS IoT -\u003e AWS IoT rule routs data and triggers lambda -\u003e Lambda validates signature and logs the success/failure.\nIf you’ve tested that data is being published and the lambda function is working properly, it should all work when you run the program to publish data.\nFrom your AWS Console, select CloudWatch. Under Logs you shoud see something like /aws/lambda/Signature_Validation. Check the logs for proper validation, if you have no logs chances are your AWS IoT rule is not routing the data properly. If data is being published and no logs appear, check your rule is configured properly.\n","categories":"","description":"","excerpt":"Introduction While all Zymbit modules make it trivial to verify data …","ref":"/tutorials/aws-iot/verify-sigs/","tags":"","title":"How to Verify Signatures against Public Key on AWS and Other Devices"},{"body":"How to generate a client certificate for your Zymkey, register your own CA, and establish a TLS connection to AWS IoT to publish data. Overview The following post will show you how to create and register a Zymkey Client Certificate for devices connecting to AWS IoT, as well as how to publish data to AWS IoT using Zymkey. This will allow you to connect a client device to AWS IoT using the private key stored in a Zymkey hardware security module, which is inherently a more secure client certification and authentication method.\nIf you have a large number of client devices to connect to AWS IoT, consider using the more automated Just In Time Registration Process using Zymkey. More details.\nAWS IoT uses a certificate based system for its TLS client authentication. This means that any attempted connection to the AWS IoT servers such as when pulling/publishing data, which is done through TLS/HTTPS, requires the client to present a valid client certificate as well as a valid certificate authority certificate. Furthermore the client must be able to prove that they have the private key associated with the provided certificate. Client Certificates are considered valid if they are registered with Amazon.\nIn this example we will be using AWS IoT’s BYOC (Bring Your Own Certicate) system to create a certificate based on Zymkey’s private key and register it with Amazon. The Zymkey certificate can be signed by either the AWS IoT root certificate authority or your own certificate authority. Both methods will be covered here. Once the setup is complete, you will be able to work with AWS IoT using their REST API, authenticating with Zymkey’s private key.\nClassic client TLS authentication requires the user to keep their private key stored in a file, such as in a file called zymkey.key, and the key is read by whatever client is establishing the TLS connection so that it can be used to prove that you own the key.\nWith Zymkey, authentication is done by a key that cannot be read/exported and that isn’t kept on the file system. The key is always stored in the Zymkey hardware.\nLastly, we will show you how to test your setup. This is done with CURL to make HTTPS requests to the MQTT port 8443.\nPrerequisites Notice The following procedure was done with Raspberry PI OS Buster 32bit. The current version of cURL included in bullseye (7.74.0) seems to have an issue using the openssl engine import feature. Install the necessary software packages and insure the Zymkey is bound to its host using the Getting Started Guide.\nHave a registered AWS Account, a free developer account can be made here.\nProcess Overview Create a Certificate Signing Request (CSR) with Zymkey private key Sign CSR with a Certificate Authority to get a Zymkey Device Certificate If using your own Certificate Authority, register it with AWS Register the Zymkey Device Certificate with AWS Test a TLS connection using your Zymkey Device Certificate and Private Key Attach a policy to the Zymkey Device Certificate to allow it to publish data to AWS IoT Publish data to AWS IoT over TLS using Zymkey Device Certificate for authentication Manual vs. Programmatic Setup Details All AWS settings can be configured either manually through the AWS web interface or programatically through AWS’ boto 3 module in Python. If you would like to use scripts to programatically set up your client certificate, you will need to do the following steps.\nFirst, follow these instructions on the boto3 page to set up the boto3 module for Python: http://boto3.readthedocs.io/en/latest/guide/quickstart.html\nThe boto3 module authenticates with AWS based on a IAM Access ID and Secret Key. The boto3 tutorial will ask you to setup an IAM user, here are some instructions on how to do so:\nFrom the AWS console, choose the IAM service. Go to Users and select Add User Choose a username and check the Programmatic access box For simplicity, choose Attach existing policies directly and select AdministratorAccess If you wish to better manage your IAM credentials, feel free to customize your Access Policy. Click Review and then Create User Save the Access ID and Secret Key and follow the boto3 guide. Creating a Certificate Signing Request with Zymkey Bring Your Own device Certificate (BYOC)\nThe first step is to create a valid device certificate using Zymkey’s private key. This can be done by first creating a Certificate Signing Request using OpenSSL:\nopenssl req -key nonzymkey.key -new -out zymkey.csr -engine zymkey_ssl -keyform e -subj \"/C=US/ST=California/L=Santa Barbara/O=Zymbit/OU=Zymkey/CN=rpi.edge.zymbit.com\" The file nonzymkey.key is a placeholder argument and is not actually a real file or used since Zymkey’s private key can not be exported nor read. A CSR file zymkey.csr is created in the directory where this command is run. The -subj argument automatically inserts certificate information, but you can leave this argument out and will be prompted to input your own information. Your CSR now needs to be signed by a valid Certificate Authority.\nRegistering a Certificate Authority Now that you have created a CSR with Zymkey, you have two options for Certificate Authorities.\nOption A - Using the AWS IoT Root Certificate Authority (Easiest) Details Signing CSR with AWS’ Certificate Authority Using AWS’ Certificate Authority is the easier option in terms of setup and allows you to use a trustworthy Certificate Authority that Amazon uses its services. The following steps show you how to sign your Zymkey’s private key with Amazon’s CA and get a valid device certificate:\nManually:\nSign into your AWS console. Here is a link to the console sign-in page: https://aws.amazon.com/console/ From the console, select the AWS IoT Core service Under the secure tab, click on Certificates and click the blue Create a certificate bar Choose the Create with CSR option When the File Selection menu pops up point to your CSR file. It shoud be zymkey.csr by default. Choose Upload file. We created this file on your IoT device, you may need to transfer it to where your logged into AWS. Download the Certificate file on the next screen and save as zymkey.crt. If you are not logged into AWS from your IoT device, transfer the file to your IoT device. We will use this later. You also need to download the root CA for AWS IoT, by clicking Download. On the page that opens, scroll down to the section CA certificates for server authentication, click ECC 256 bit key and click on the adjacent link Amazon Root CA 3. Copy the public key into a file named AWS_CA.pem file. If you are not logged into AWS from your IoT device, transfer AWS_CA.pem to your IoT device. We will use this later. Return to the Create Certificate AWS IoT page and click Activate Programatically: Using the boto3 client, this python script will read the csr file zymkey.csr, give it to AWS to sign with their Certificate Authority, and create a signed certificate zymkey.crt in the directory where this program is run. Furthermore the certificate will be automatically registered and activated with AWS IoT and will be ready for use.\nimport boto3 iot_client = boto3.client('iot') with open('zymkey.csr', 'r') as zymkey_csr_file: zymkey_csr = zymkey_csr_file.read() zymkey_cert = iot_client.create_certificate_from_csr( certificateSigningRequest=zymkey_csr, setAsActive=True ) with open('zymkey.crt', 'w') as zymkey_cert_file: zymkey_cert_file.write(zymkey_cert['certificatePem']) Save the above script into a file called aws_sign_csr.py and run with the following command:\npython aws_sign_csr.py Now that your Certificate has been signed and activated by AWS IoT, it can be used to establish a TLS connection with the AWS IoT servers. Skip down to Testing the TLS Connection section to continue.\nOption B - Using your own Certificate Authority Details AWS IoT also allows you do you use own Certificate Authority as long as you register it with them. This constitutes proving you own the private key to the CA by signing a verification CSR that includes a registration code.\nIf you already have a Certificate Authority that you would like to use, you can ignore the next part. Here we create an example Certificate Authority using OpenSSL.\nCreating an example CA with OpenSSL #!/bin/bash set -e mkdir CA_files cd CA_files openssl ecparam -genkey -name prime256v1 -out zk_ca.key OPENSSL_CONF=/etc/ssl/openssl.cnf openssl req \\ -x509 -new -SHA256 -nodes -key zk_ca.key \\ -days 3650 -out zk_ca.crt \\ -subj \"/C=US/ST=California/L=Santa Barbara/O=Zymkey/CN=zymkey-verify.zymbit.com.dev\" cp zk_ca.crt zk_ca.pem Copy the above lines into a script called mk_ca.sh. You can then run the script in the command line by being in the same directory with the following command:\nbash mk_ca.sh The script will create a directory called CA_files and a couple of files: zk_ca.key: Private key for the created CA, will be supplied to OpenSSL for signing CSRs. zk_ca.pem: PEM formatted certificate for the CA zk_ca.crt: Same file as zk_ca.pem\nSigning CSR with Certificate Authority Next we will be signing the Zymkey CSR with your chosen Certificate Authority.\n#!/bin/bash set -e SCRIPT_NAME=$(basename $0) [ -z $2 ] \u0026\u0026 echo \"${SCRIPT_NAME} \u003ccsr filename\u003e \u003ccrt filename\u003e\" 1\u003e\u00262 \u0026\u0026 exit 1 csr=$1 crt=$2 openssl x509 -req -SHA256 -days 3650 \\ -CA CA_files/zk_ca.crt -CAkey CA_files/zk_ca.key -CAcreateserial \\ -in ${csr} -out ${crt} Copy the above lines into a script called sign_csr.sh. The first argument is the relative or absolute path of your csr file, such as zymkey.csr. The second argument is what you want to name the certificate file of the signed cert. Change the -CA and -CAkey file path, can be relative or absolute, if you are using your own CA. You can then run the script in the command line by being in the same directory with the following command:\nbash sign_csr.sh zymkey.csr zymkey.crt Registering Your Certificate Authority with AWS You now have a valid certificate, zymkey.crt signed by the Certificate Authority of your choice. If you are using your own Certificate Authority, you have to register your Certificate Authority with Amazon’s IoT service so that AWS IoT will accept certificates signed by that Certificate Authority.\nManually:\nFrom the AWS IoT console select Secure, then click CAs and then click Register Click Register CA Follow Steps 1 through 3 on the next screen to create a verification certificate. When signing the verification certificate with your CA in Step 4 run the following command: openssl x509 -req -in verificationCert.csr -CA CA_files/zk_ca.pem -CAkey CA_files/zk_ca.key -CAcreateserial -out verificationCert.crt -days 500 -sha256 Note that if you use a different CA and not the demo one we generated, change the **-CA** and **-CAkey** paths appropriately. Step 5: click Select CA certificate and point to the correct .pem file. If you use the OpenSSL generated SSL point to CA_files/zk_ca.pem Step 6: click Select verification certificate and point to verificationCert.crt which was created in Step 4. Select Activate CA certificate and Enable auto-registration of device certificates Click Register CA certificate button. Programatically:\nThe following python script will automatically create a verification cert with a registration code and automatically activate your Certificate Authority. While it may look a bit intimidating, all you have to worry about is the very last line, where you can change to point to your CA files.\nimport OpenSSL import boto3 import os def gen_AWS_verification_csr(registrationCode): key = OpenSSL.crypto.PKey() key.generate_key(OpenSSL.crypto.TYPE_RSA, 2048) req = OpenSSL.crypto.X509Req() req.get_subject().CN = registrationCode req.set_pubkey(key) req.sign(key, \"sha256\") return OpenSSL.crypto.dump_certificate_request(OpenSSL.crypto.FILETYPE_PEM, req) def sign_CSR_with_CA(verification_csr, CA_cert_path, CA_key_path): ca_cert = OpenSSL.crypto.load_certificate(OpenSSL.crypto.FILETYPE_PEM, open(CA_cert_path).read()) ca_key = OpenSSL.crypto.load_privatekey(OpenSSL.crypto.FILETYPE_PEM, open(CA_key_path).read()) req = OpenSSL.crypto.load_certificate_request(OpenSSL.crypto.FILETYPE_PEM, verification_csr) cert = OpenSSL.crypto.X509() cert.set_subject(req.get_subject()) cert.set_serial_number(1) cert.gmtime_adj_notBefore(0) cert.gmtime_adj_notAfter(24 * 60 * 60) cert.set_issuer(ca_cert.get_subject()) cert.set_pubkey(req.get_pubkey()) cert.sign(ca_key, \"sha256\") return OpenSSL.crypto.dump_certificate(OpenSSL.crypto.FILETYPE_PEM, cert) def register_CA_AWS(CA_cert_path, CA_key_path): client = boto3.client('iot') response = client.get_registration_code() registration_key = response['registrationCode'] verification_pem = gen_AWS_verification_csr(registrationCode=registration_key) verification_cert = sign_CSR_with_CA(verification_csr=verification_pem, CA_cert_path=CA_cert_path, CA_key_path=CA_key_path) response = client.register_ca_certificate( caCertificate=open(CA_cert_path).read(), verificationCertificate=verification_cert, setAsActive=True, allowAutoRegistration=True ) return response register_CA_AWS(CA_cert_path='CA_files/zk_ca.crt', CA_key_path='CA_files/zk_ca.key') Copy the above lines into a file called activate_aws_ca.py and run with the following command:\npython activate_aws_ca.py Registering a Device Certificate signed by Certificate Authority Now that your Certificate Authority has been registered with AWS IoT, all that is left to do is to register and activate your Zymbit device certificate.\nDetails Manually:\nFrom the AWS IoT Console click Secure, then Certificates and then click the blue Create button Under Use My Certificate click the Get Started button If you registered your own CA, choose the CA you registered on the Select a CA screen, then click Next Click Select certificates and navigate to the certificate that was signed by your CA. Its default name is zymkey.crt Make sure to check the Activate all circle on the certificate box, and finally click the blue Register certificates button. Programatically:\nThe same thing can be done in Python. Just change the last line to point to your CA_Path and Cert_Path, the paths can be either relative or absolute. For example if the two certificate files: zk_ca.crt and zymkey.crt are in the same directory as the Python script, you don’t have to change anything from the following:\nimport boto3 import OpenSSL def activate_cert_AWS(CA_path, Cert_path): boto3client = boto3.client('iot') with open(CA_path) as CA_file: CA_Pem = CA_file.read() with open(Cert_path) as Cert_file: Cert_Pem = Cert_file.read() return boto3client.register_certificate( certificatePem=Cert_Pem, caCertificatePem=CA_Pem, setAsActive=True, ) activate_cert_AWS(CA_path='CA_files/zk_ca.crt', Cert_path='zymkey.crt') Copy the above lines into a file called activate_aws_cert.py and run with the following command: Change the CA_Path and Cert_path if necessary.\npython activate_aws_cert.py Testing TLS connection with Zymkey Device Certificate: You can now test that your certificate zymkey.crt has been registered correctly by testing a TLS connection with your AWS IoT endpoint. We will be doing this with CURL.\nDetails The first thing to do is to look for your AWS endpoint:\nFrom the AWS IoT console screen, click on Settings in the left hand bar.\nIn the Device data endpoint section, copy the Endpoint.\nReplace endpoint.iot.region.amazonaws.com with the Endpoint you just copied in the following command. Now run the command, making sure to do it in the same directory where you keep your signed certificate, zymkey.crt and your CA cert/pem file, AWS_CA.pem, or CA_files/zk_ca.pem:\n#replace endpoint iot region with the copied endpoint ```bash curl --tlsv1.2 --cacert AWS_CA.pem --cert zymkey.crt --key nonzymkey.key --engine zymkey_ssl --key-type ENG -v -X POST -d \"{ \\\"hello\\\": \\\"world\\\"}\" \"https://endpoint.iot.region.amazonaws.com:8443/topics/hello/world\" ``` Optionally, you can set an environment variable specifying the slot to use. For the HSM6, you will need to specify the variable prior to running the curl command:\nexport ZK_SSL_SLOT=0 You should see a successful TLS connection, but receive a 403 Forbidden Exception from AWS. This is because the certificate you registered, zymkey.crt doesn’t have the appropriate permissions to publish a message to the topic hello/world. We can fix this by adding a policy and attaching it to the certificate.\nHere’s what the successful TLS connection looks like:\nHere’s the 403 exception you should receive:\nAttaching Policy to Certificate and Publishing to AWS IoT Details Here we will attach a Policy to your Zymkey certificate that allows it to publish data to any topic on AWS IoT.\nFrom the AWS IoT console click on Secure and then Policies. Click the blue Create a policy button.\nGive your Policy an appropriate name.\nUnder Action, write the following:\niot:Connect, iot:Publish For Resource ARN write:\n* Check the Allow box, and click Create\nNow, click the Certificates tab on the left and click on the … option on the top right corner of your certificate. Select Attach Policy\nAttach the appropriate policy and you are done.\nPublishing data to AWS IoT Details Now the previous command should work and {“hello”: “world”} should be published to the hello/world topic on your AWS IoT endpoint.\nOn the AWS IoT console and the left hand bar, click on the Test option, and then the MQTT test client option.\nIn the Subscribe to a topic tab, in the Subscription topic box, type in hello/world. Click the Subscribe button\nTest your TLS connection with the following CURL command pointing to the CA cert/pem file and your Zymkey certificate:\n#replace endpoint.iot.region with the appropriate values curl --tlsv1.2 --cacert CA_files/zk_ca.pem --cert zymkey.crt --key nonzymkey.key --engine zymkey_ssl --key-type ENG -v -X POST -d \"{ \\\"hello\\\": \\\"world\\\"}\" \"https://endpoint.iot.region.amazonaws.com:8443/topics/hello/world\" If it works, your command line should have indication of successful TLS connection and “hello”: “world” should show up in your subscribed topic.\n","categories":"","description":"","excerpt":"How to generate a client certificate for your Zymkey, register your …","ref":"/tutorials/aws-iot/tls/","tags":"","title":"AWS IoT - TLS Client Certificate Authentication"},{"body":" Bootware File Structure Overview: Brief description of Bootware files that complete the Bootware process.\nLocation: /boot Critical Files: Filename: config.txt\nDescription: RPi Configuration File\nCritical Lines:\ndtoverlay=dwc2,dr_mode=host kernel=u-boot.bin enable_uart=1 Filename: u-boot.bin\nDescription: U-Boot Bootloader\nFunctions: Loads and executes boot script\nFilename: boot.scr\nDescription: U-Boot Boot Script\nFunctions:\nGenerates U-Boot Environment Updates U-Boot Environment Loads and Boots Kernel Filename: zboot.enc\nDescription: zboot (Bootware zboot Module)\nFunctions:\nInitialize Bootware Perform Update Perform Rollback Perform Recovery Filename: zb_config.enc\nDescription: zboot Configuration File - Generated by zb-wizard\nFilename: uboot.env\nDescription: u-Boot Environment\nFilename: kernel8.enc\nDescription: Bullseye 64 (Encrypted Kernel) - Generated by zboot\nNon-Critical Files: Filename: zboot.log\nDescription: zboot Log File\nzbconfig zb-wizard internally uses the zbconfig tool to configure the device environment. Developers may directly use the zbconfig CLI interface instead of the zb-wizard GUI to configure their device environment.\nzbconfig simply reads and writes values to an encrypted JSON file (/boot/zb_config.enc) that bootware uses to apply updates. The values that can be configured are listed below:\nValue Type Description one_root_fs Boolean True will facilitate A only filesystems, while false enables A/B filesystems. resize_a Boolean If one_root_fs is true, this parameter is checked for resizing A only filesystems.\ntrue - full disk\nfalse - half disk update_mode String This parameter is only checked for A/B filesystems. Set the policy for the updates: UPDATE_ACTIVE UPDATE_BACKUP UPDATE_BOTH update_endpoint String The endpoint where new images are pulled from. Example https URL: https://zk-sw-repo.s3.amazonaws.com/ota_preview/base_ota.zi\nExample USB stick: /dev/sda1 endpoint_type String The type of endpoint for the update_endpoint param. Value must be all uppercase.\nHTTPS\nUSB update_name String The name of the .zi image that will be used for the update. If the name of the new update is base_ota.zi, this parameter needs to be named “base_ota ","categories":"","description":"","excerpt":" Bootware File Structure Overview: Brief description of Bootware files …","ref":"/bootware/archive/bootware-one-zero-general/troubleshooting/file-info/","tags":"","title":"Bootware Additional Info"},{"body":"Remapping GPIO4 Pin Zymkey4 uses GPIO4 for a ‘handshake signal’ to coordinate communications with the host Pi. There is a logical (software), electrical and mechanical connection with GPIO4. If you need to use an alternative GPIO pin, here are the steps you need to take reconfigure your system:\nSoftware Configuration To remap the GPIO_4 pin used by Zymbit from GPIO4 to GPIO_X:\nLocate the directory ‘/var/lib/zymbit’ Locate the configuration file name ‘zkenv.conf’ - if non exists then create text file ‘zkenv.conf’ Into the file ‘zkenv.conf’ insert the line ZK_GPIO_WAKE_PIN=X, where X is your GPIO pin of choice. ‘In the RaspberryPi file named ‘config.txt’ you will also need to explicity set GPIO_X to an input . (Note that this is the RaspberryPi config file, which is different to the Zymbit conf file) Finish Electrical Configuration Electrically reconnect Zymkey4 pins per the diagram below. Mechanical Configuration Move your Zymkey4 so it does not mechanically or electrically interfere with other devices connected to pins 1 thru 10. ","categories":"","description":"","excerpt":"Remapping GPIO4 Pin Zymkey4 uses GPIO4 for a ‘handshake signal’ to …","ref":"/tutorials/alternative-gpio/","tags":"","title":"Using an Alternative GPIO Pin"},{"body":" Introduction C interface to Zymkey Application Utilities Library.\nThis file contains the C API to the the Zymkey Application Utilities library. This API facilitates writing user space applications which use Zymkey to perform cryptographic operations, such as:\nSigning of payloads using ECDSA. Verification of payloads that were signed using Zymkey. Exporting the public key that matches Zymkey’s private key. “Locking” and “unlocking” data objects. Generating random data Additionally, there are functions for changing the i2c address (i2c units only), setting tap sensitivity and controlling the LED. Typedefs typedef void *zkCTX typedef enum ZK_EC_KEY_TYPEZK_EC_KEY_TYPE Supported key types.\ntypedef enum ZK_RECOVERY_STRATEGYZK_RECOVERY_STRATEGY Supported recovery strategies.\ntypedef enum ZK_ECDH_KDF_TYPEZK_ECDH_KDF_TYPE Supported ECDH key derivation function types.\ntypedef enum ZK_ACCEL_AXIS_TYPEZK_ACCEL_AXIS_TYPE Accelerometer axis enum, used to set tap sensitivity.\ntypedef enum ZK_THRESHOLD_ACTION_TYPEZK_THRESHOLD_ACTION_TYPE Possible actions for threshold monitor functions.\ntypedef struct zkAccelAxisDataTypezkAccelAxisDataType zkGetAccelerometer data output.\nStructs struct zkAccelAxisDataType #include \u003czk_app_utils.h\u003e zkGetAccelerometer data output.\ndouble g the axis reading in units of g-force.\nint tapDirection the direction of the force along the axis which caused a tap event: -1 = negative +1 = positive 0 = did not cause a tap event.\nEnums enum ZK_EC_KEY_TYPE Supported key types.\nenumerator ZK_NISTP256 enumerator ZK_SECP256R1 enumerator ZK_SECP256K1 enumerator ZK_ED25519 enumerator ZK_X25519 enum ZK_RECOVERY_STRATEGY Supported recovery strategies.\nenumerator ZK_NONE enumerator ZK_BIP39 enumerator ZK_SLIP39 enum ZK_ECDH_KDF_TYPE Supported ECDH key derivation function types.\nenumerator ZK_KDF_RFC5869_SHA256 enumerator ZK_KDF_RFC5869_SHA512 enumerator ZK_KDF_PBKDF2_SHA256 enumerator ZK_KDF_PBKDF2_SHA512 enum ZK_ACCEL_AXIS_TYPE Accelerometer axis enum, used to set tap sensitivity.\nenumerator ZK_ACCEL_AXIS_X enumerator ZK_ACCEL_AXIS_Y enumerator ZK_ACCEL_AXIS_Z enumerator ZK_ACCEL_AXIS_ALL enum ZK_THRESHOLD_ACTION_TYPE Possible actions for threshold monitor functions.\nenumerator ZK_ACTION_NONE enumerator ZK_ACTION_SELF_DESTRUCT enumerator ZK_ACTION_SLEEP Functions Zymkey Context int zkOpen ( zkCTX * ctx) Open a Zymkey context.\nParameters ctx — (output) returns a pointer to a Zymkey context.\nReturns 0 for success, less than 0 for failure.\nint zkClose ( zkCTX ctx) Close a Zymkey context.\nParameters ctx — (input) The Zymkey context to close.\nReturns 0 for success, less than 0 for failure.\nRandom Number Generation int zkCreateRandDataFile ( zkCTX ctx, const char * dst_filename, int rdata_sz) Fill a file with random numbers.\nParameters ctx — (input) Zymkey context.\ndst_filename — (input) Absolute path name for the destination file.\nrdata_sz — (input) The number of random bytes to generate.\nReturns 0 for success, less than 0 for failure.\nint zkGetRandBytes ( zkCTX ctx, uint8_t ** rdata, int rdata_sz) Get an array of random bytes.\nParameters ctx — (input) Zymkey context.\nrdata — (input) Pointer to a pointer of bytes.\nrdata_sz — (input) The number of random bytes to generate.\nReturns 0 for success, less than 0 for failure.\nLock Data int zkLockDataF2F ( zkCTX ctx, const char * src_pt_filename, const char * dst_ct_filename, bool use_shared_key) Lock up source (plaintext) data from a file and store the results (ciphertext) in a destination file.\nThis function encrypts and signs a block of plaintext data from a file and stores the result in a destination file.\nParameters ctx — (input) Zymkey context.\nsrc_pt_filename — (input) The absolute path to the file where the source (plaintext) data is located.\ndst_ct_filename — (input) The absolute path to the file where the destination (ciphertext) data should be deposited.\nuse_shared_key — (input) This parameter specifies which key will be used to used to lock the data up. A value of “false” specifies that the Zymkey will use the one-way key whereas “true” specifies that the shared key will be used. Specify “true” for publishing data to another that has the shared key (e.g. Zymbit cloud) and “False” when the data is meant to reside exclusively withing the host computer.\nReturns 0 for success, less than 0 for failure.\nint zkLockDataB2F ( zkCTX ctx, const uint8_t * src_pt, int src_pt_sz, const char * dst_ct_filename, bool use_shared_key) Lock up source (plaintext) data from a byte array and store the results (ciphertext) in a destination file.\nThis function encrypts and signs a block of binary plaintext data and stores the result in a destination file.\nParameters ctx — (input) Zymkey context.\nsrc_pt — (input) Binary plaintext source byte array.\nsrc_pt_sz — (input) Size of plaintext source data.\ndst_ct_filename — (input) The absolute path to the file where the destination (ciphertext) data should be deposited.\nuse_shared_key — (input) Specifies if shared key is to be used. See zkLockDataF2F.\nReturns 0 for success, less than 0 for failure.\nint zkLockDataF2B ( zkCTX ctx, const char * src_pt_filename, uint8_t ** dst_ct, int * dst_ct_sz, bool use_shared_key) Lock up source (plaintext) data from a file and store the results (ciphertext) in a destination byte array.\nThis function encrypts and signs a block of plaintext data from a file and stores the result in a binary byte array.\nParameters ctx — (input) Zymkey context.\nsrc_pt_filename — (input) The absolute path to the file where the source (plaintext) data is located.\ndst_ct — (output) A pointer to a pointer to an array of unsigned bytes created by this function. This pointer must be freed by the application when no longer needed.\ndst_ct_sz — (output) A pointer to an integer which contains the size of the destination array.\nuse_shared_key — (input) Specifies if shared key is to be used. See zkLockDataF2F.\nReturns 0 for success, less than 0 for failure.\nint zkLockDataB2B ( zkCTX ctx, const uint8_t * src_pt, int src_pt_sz, uint8_t ** dst_ct, int * dst_ct_sz, bool use_shared_key) Lock up source (plaintext) data from a byte array and store the results (ciphertext) in a destination byte array.\nThis function encrypts and signs a block of plaintext data and stores the result in a binary byte array.\nParameters ctx — (input) Zymkey context.\nsrc_pt — (input) Binary plaintext source byte array.\nsrc_pt_sz — (input) Size of plaintext source data.\ndst_ct — (output) A pointer to a pointer to an array of unsigned bytes created by this function. This pointer must be freed by the application when no longer needed.\ndst_ct_sz — (output) A pointer to an integer which contains the size of the destination array.\nuse_shared_key — (input) Specifies if shared key is to be used. See zkLockDataF2F.\nReturns 0 for success, less than 0 for failure.\nUnlock Data int zkUnlockDataF2F ( zkCTX ctx, const char * src_ct_filename, const char * dst_pt_filename, bool use_shared_key) Unlock source (ciphertext) data from a file and store the results (plaintext) in a destination file.\nThis function verifies a locked object signature and decrypts the associated ciphertext data.\nParameters ctx — (input) Zymkey context.\nsrc_ct_filename — (input) The absolute path to the file where the source (ciphertext) data is located.\ndst_pt_filename — (input) The absolute path to the file where the destination (plaintext) data should be deposited.\nuse_shared_key — (input) This parameter specifies which key will be used to used to lock the data up. A value of “false” specifies that the Zymkey will use the one-way key whereas “true” specifies that the shared key will be used. Specify “true” for publishing data to another that has the shared key (e.g. Zymbit cloud) and “False” when the data is meant to reside exclusively withing the host computer.\nReturns 0 for success, less than 0 for failure.\nint zkUnlockDataB2F ( zkCTX ctx, const uint8_t * src_ct, int src_ct_sz, const char * dst_pt_filename, bool use_shared_key) Unlock source (ciphertext) data from a byte array and store the results (plaintext) in a destination file.\nThis function verifies a locked object signature and decrypts the associated ciphertext data.\nParameters ctx — (input) Zymkey context.\nsrc_ct — (input) Binary ciphertext source byte array.\nsrc_ct_sz — (input) Size of ciphertext source data.\ndst_pt_filename — (input) The absolute path to the file where the destination (plaintext) data should be deposited.\nuse_shared_key — (input) Specifies if shared key is to be used. See zkLockDataF2F.\nReturns 0 for success, less than 0 for failure.\nint zkUnlockDataF2B ( zkCTX ctx, const char * src_ct_filename, uint8_t ** dst_pt, int * dst_pt_sz, bool use_shared_key) Unlock source (ciphertext) data from a file and store the results (plaintext) in a destination byte array.\nThis function verifies a locked object signature and decrypts the associated ciphertext data.\nParameters ctx — (input) Zymkey context.\nsrc_ct_filename — (input) The absolute path to the file where the source (ciphertext) data is located.\ndst_pt — (output) A pointer to a pointer to an array of unsigned bytes created by this function. This pointer must be freed by the application when no longer needed.\ndst_pt_sz — (output) A pointer to an integer which contains the size of the destination array.\nuse_shared_key — (input) Specifies if shared key is to be used. See zkLockDataF2F.\nReturns 0 for success, less than 0 for failure.\nint zkUnlockDataB2B ( zkCTX ctx, const uint8_t * src_ct, int src_ct_sz, uint8_t ** dst_pt, int * dst_pt_sz, bool use_shared_key) Unlock source (ciphertext) data from a byte array and store the results (plaintext) in a destination byte array.\nThis function verifies a locked object signature and decrypts the associated ciphertext data.\nParameters ctx — (input) Zymkey context.\nsrc_ct — (input) Binary ciphertext source byte array.\nsrc_ct_sz — (input) Size of ciphertext source data.\ndst_pt — (output) A pointer to a pointer to an array of unsigned bytes created by this function. This pointer must be freed by the application when no longer needed.\ndst_pt_sz — (output) A pointer to an integer which contains the size of the destination array.\nuse_shared_key — (input) Specifies if shared key is to be used. See zkLockDataF2F.\nReturns 0 for success, less than 0 for failure.\nECDSA int zkGenECDSASigFromDigest ( zkCTX ctx, const uint8_t * digest, int slot, uint8_t ** sig, int * sig_sz) Generate a signature using the Zymkey’s ECDSA private key.\nParameters ctx — (input) Zymkey context.\ndigest — (input) This parameter contains the digest of the data that will be used to generate the signature.\nslot — (input) The key slot to generate a signature from. This parameter is only valid for Zymkey models 4i and beyond.\nsig — (output) A pointer to a pointer to an array of unsigned bytes which contains the generated signature. This pointer is created by this function and must be freed by the application when no longer needed.\nsig_sz — (output) A pointer to an integer which contains the size of the signature.\nReturns 0 for success, less than 0 for failure.\nint zkGenECDSASigFromDigestWithRecID ( zkCTX ctx, const uint8_t * digest, int slot, uint8_t ** sig, int * sig_sz, uint8_t * recovery_id) Generate a signature using the Zymkey’s ECDSA private key.\nParameters ctx — (input) Zymkey context.\ndigest — (input) This parameter contains the digest of the data that will be used to generate the signature.\nslot — (input) The key slot to generate a signature from. This parameter is only valid for Zymkey models 4i and beyond.\nsig — (output) A pointer to a pointer to an array of unsigned bytes which contains the generated signature. This pointer is created by this function and must be freed by the application when no longer needed.\nsig_sz — (output) A pointer to an integer which contains the size of the signature.\nrecovery_id — (output) Returns recovery id value needed for ethereum key recovery.\nReturns 0 for success, less than 0 for failure.\nint zkVerifyECDSASigFromDigest ( zkCTX ctx, const uint8_t * digest, int pubkey_slot, const uint8_t * sig, int sig_sz) Verify a signature using one of the Zymkey’s public keys.\nVerify a signature using an internal public key from the Zymkey private/public key store.\nParameters ctx — (input) Zymkey context.\ndigest — (input) This parameter contains the digest of the data that will be used to generate the signature.\npubkey_slot — (input) The key slot to generate a signature from. This parameter is only valid for Zymkey models 4i and beyond.\nsig — (input) Array of bytes which contains the signature.\nsig_sz — (input) Size of signature.\nReturns 0 for signature verification failed, 1 for signature verification passed, less than 0 for general failure.\nint zkVerifyECDSASigFromDigestWithForeignKeySlot ( zkCTX ctx, const uint8_t * digest, int pubkey_slot, const uint8_t * sig, int sig_sz) Verify a signature using one of the Zymkey’s foreign public keys.\nVerify a signature using a public key from the Zymkey foreign key store.\nParameters ctx — (input) Zymkey context.\ndigest — (input) This parameter contains the digest of the data that will be used to generate the signature.\npubkey_slot — (input) The key slot to generate a signature from. This parameter is only valid for Zymkey models 4i and beyond.\nsig — (input) Array of bytes which contains the signature.\nsig_sz — (input) Size of signature.\nReturns 0 for signature verification failed, 1 for signature verification passed, less than 0 for general failure.\nECDH and KDF int zkDoRawECDH ( zkCTX ctx, int slot, const uint8_t * peer_pubkey, int peer_pubkey_sz, uint8_t ** pre_master_secret) Perform a raw ECDH operation. (Supported Devices: HSM6, Secure Compute Module).\nPerform an ECDH operation with no Key Derivation Function (KDF). The raw pre-master secret is returned in the response. The peer public key is presented in the call.\nParameters ctx — (input) Zymkey context.\nslot — (input) The key slot to use for the local key. If this parameter is -1, the ephemeral key is used.\npeer_pubkey — (input) The peer public key.\npeer_pubkey_sz — (input) Size of the peer public key.\npre_master_secret — (output) returned pointer to the pre-master secret.\nReturns 0 for success, less than 0 for general failure.\nint zkDoRawECDHWithIntPeerPubkey ( zkCTX ctx, int slot, int peer_pubkey_slot, bool peer_pubkey_slot_is_foreign, uint8_t ** pre_master_secret) Perform a raw ECDH operation. (Supported Devices: HSM6, Secure Compute Module).\nPerform an ECDH operation with no Key Derivation Function (KDF). The raw pre-master secret is returned in the response. The peer public key is referenced from the zymkey internal key store.\nParameters ctx — (input) Zymkey context.\nslot — (input) The key slot to use for the local key. If this parameter is -1, the ephemeral key is used.\npeer_pubkey_slot — (input) The peer public key slot where the peer public key is to be found.\npeer_pubkey_slot_is_foreign — (input) If true, the peer public key slot is found in the foreign public keyring.\npre_master_secret — (output) returned pointer to the pre-master secret.\nReturns 0 for success, less than 0 for general failure.\nint zkDoECDHAndKDF ( zkCTX ctx, ZK_ECDH_KDF_TYPE kdf_type, int slot, const uint8_t * peer_pubkey, int peer_pubkey_sz, const uint8_t * salt, int salt_sz, const uint8_t * info, int info_sz, int num_iterations, int derived_key_sz, uint8_t ** derived_key) Perform an ECDH operation plus Key Derivation Function. (Supported Devices: HSM6, Secure Compute Module).\nPerform an ECDH operation with Key Derivation Function (KDF). The derived key is returned in the response. The peer public key is presented in the call.\nParameters ctx — (input) Zymkey context.\nslot — (input) The key slot to use for the local key. If this parameter is -1, the ephemeral key is used.\npeer_pubkey — (input) The peer public key.\npeer_pubkey_sz — (input) Size of the peer public key.\nsalt — (input) The salt to use for the selected KDF.\nsalt_sz — (input) The salt size. Must be less than or equal to 128 bytes.\ninfo — (input) The info field to use for RFC 5869. Ignored for PBKDF2.\ninfo_sz — (input) The size of the info parameter. Must be less than or equal to 128 bytes.\nnum_iterations — (input) Number of iterations to carry out (PBKDF only).\nderived_key_sz — (input) The desired number of bytes to return for the KDF. For RFC 5869, this value must be less than 8160 bytes (SHA256) or 16320 (SHA512).\nderived_key — (output) returned pointer to the derived key.\nReturns 0 for success, less than 0 for general failure.\nint zkDoECDHAndKDFWithIntPeerPubkey ( zkCTX ctx, ZK_ECDH_KDF_TYPE kdf_type, int slot, int peer_pubkey_slot, bool peer_pubkey_slot_is_foreign, const uint8_t * salt, int salt_sz, const uint8_t * info, int info_sz, int num_iterations, int derived_key_sz, uint8_t ** derived_key) Perform an ECDH operation plus Key Derivation Function. (Supported Devices: HSM6, Secure Compute Module).\nPerform an ECDH operation with Key Derivation Function (KDF). The derived key is returned in the response. The peer public key is referenced from the zymkey internal key store.\nParameters ctx — (input) Zymkey context.\nslot — (input) The key slot to use for the local key. If this parameter is -1, the ephemeral key is used.\npeer_pubkey_slot — (input) The peer public key slot where the peer public key is to be found.\npeer_pubkey_slot_is_foreign — (input) If true, the peer public key slot is found in the foreign public keyring.\nsalt — (input) The salt to use for the selected KDF.\nsalt_sz — (input) The salt size. Must be less than or equal to 128 bytes.\ninfo — (input) The info field to use for RFC 5869. Ignored for PBKDF2.\ninfo_sz — (input) The size of the info parameter. Must be less than or equal to 128 bytes.\nnum_iterations — (input) Number of iterations to carry out (PBKDF only).\nderived_key_sz — (input) The desired number of bytes to return for the KDF. For RFC 5869, this value must be less than 8160 bytes (SHA256) or 16320 (SHA512).\nderived_key — (output) returned pointer to the derived key.\nReturns 0 for success, less than 0 for general failure.\nKey Management int zkSaveECDSAPubKey2File ( zkCTX ctx, const char * filename, int slot) [DEPRECATED] Use zkExportPubKey2File. Store the public key to a host file in PEM format.\nThis function is useful for generating Certificate Signing Requests (CSR).\nParameters ctx — (input) Zymkey context.\nfilename — (input) Filename where PEM formatted public key is to be stored.\nslot — (input) The key slot to retrieve. Only valid for model 4i and above.\nReturns 0 for success, less than 0 for failure.\nint zkExportPubKey2File ( zkCTX ctx, const char * filename, int pubkey_slot, bool slot_is_foreign) Store the public key to a host file in PEM format.\nThis function is useful for generating Certificate Signing Requests (CSR).\nParameters ctx — (input) Zymkey context.\nfilename — (input) Filename where PEM formatted public key is to be stored.\npubkey_slot — (input) The key slot to retrieve. Zymkey and HSM4 have slots 0, 1, and 2.\nslot_is_foreign — (input) If true, designates the pubkey slot to come from the foreign keystore. (Supported Devices: HSM6, Secure Compute Module).\nReturns 0 for success, less than 0 for failure.\nint zkGetECDSAPubKey ( zkCTX ctx, uint8_t ** pk, int * pk_sz, int slot) [DEPRECATED] Use zkExportPubKey. Gets the public key and stores in a byte array created by this function.\nParameters ctx — (input) Zymkey context.\npk — (output) Pointer to a pointer created by this function which contains the public key.\npk_sz — (output) Pointer to an integer which contains the size of the public key.\nslot — (input) The key slot to retrieve. Only valid for model 4i and above.\nReturns 0 for success, less than 0 for failure.\nint zkExportPubKey ( zkCTX ctx, uint8_t ** pk, int * pk_sz, int pubkey_slot, bool slot_is_foreign) Gets the public key and stores in a byte array created by this function.\nParameters ctx — (input) Zymkey context.\npk — (output) Pointer to a pointer created by this function which contains the public key.\npk_sz — (output) Pointer to an integer which contains the size of the public key.\npubkey_slot — (input) The key slot to retrieve. Zymkey and HSM4 have slots 0, 1, and 2.\nslot_is_foreign — (input) If true, designates the pubkey slot to come from the foreign keystore (Supported Devices: HSM6, Secure Compute Module).\nReturns 0 for success, less than 0 for failure.\nint zkGetAllocSlotsList ( zkCTX ctx, bool is_foreign, int * max_num_keys, int ** alloc_key_list, int * alloc_key_list_sz) Get the list of allocated keys (Supported Devices: HSM6, Secure Compute Module).\nThis function returns a list of all allocated key slots.\nParameters ctx — (input) Zymkey context.\nis_foreign — (input) if true, retrieve allocation list of the foreign keys.\nmax_num_keys — (input) retrieves the key pool size.\nalloc_key_list — (output) a pointer to an array of integers provided by this function to the caller.\nalloc_key_list_sz — (output) a pointer to an integer which contains the size of the returned key list.\nReturns 0 if successful, less than 0 for failure.\nint zkStoreForeignPubKey ( zkCTX ctx, ZK_EC_KEY_TYPE pk_type, uint8_t * pk, int pk_sz) Store a new foreign public key in Zymkey. (Supported Devices: HSM6, Secure Compute Module).\nThis function stores a new foreign public key in the Zymkey public key ring. This public key can be used for signature verification in use cases where it is desirable to hide the public key.\nParameters ctx — (input) Zymkey context.\npk_type — (input) The type of the public key.\npk — (input) Pointer to the public key to store.\npk_sz — (input) The public key size.\nReturns allocated slot number in foreign key store, less than 0 for failure.\nint zkDisablePubKeyExport ( zkCTX ctx, int pubkey_slot, bool slot_is_foreign) Prevent a public key from being exported to the host. (Supported Devices: HSM6, Secure Compute Module).\nThis function prevents the public key at the specified slot from being exported to the host using the API zkExportPubKey.\nParameters ctx — (input) Zymkey context.\npubkey_slot — (input) The key slot to disable pubkey export on.\nslot_is_foreign — (input) The slot parameter refers to a slot in the foreign keyring.\nReturns 0 for success, less than 0 for failure.\nint zkGenKeyPair ( zkCTX ctx, ZK_EC_KEY_TYPE type) Generate a new persistent key pair. (Supported Devices: HSM6, Secure Compute Module).\nThis function generates a new key pair of the specified type and store it persistently. This key pair cannot be used as part of the zymkey’s digital wallet operations.\nParameters ctx — (input) Zymkey context.\ntype — (input) The type of key to generate (ZK_EC_KEY_TYPE).\nReturns allocated slot number if successful, less than 0 for failure.\nint zkGenEphemeralKeyPair ( zkCTX ctx, ZK_EC_KEY_TYPE type) Generate an ephemeral key pair. (Supported Devices: HSM6, Secure Compute Module).\nThis function generates an ephemeral key pair of the specified type. Ephemeral key pairs are useful when performing ECDH for time-of-flight encryption. Only one ephemeral key slot is available and is not persistent between reboots.\nParameters ctx — (input) Zymkey context.\ntype — (input) The type of key to generate (ZK_EC_KEY_TYPE).\nReturns 0 if successful, less than 0 for failure.\nint zkRemoveKey ( zkCTX ctx, int slot, bool slot_is_foreign) Remove a key pair or a foreign public key. (Supported Devices: HSM6, Secure Compute Module).\nThis function deletes a key pair or a foreign public key from persistent storage.\nParameters ctx — (input) Zymkey context.\nslot — (input) The slot.\nslot_is_foreign — (input) The slot parameter refers to a slot in the foreign keyring.\nReturns 0 if successful, less than 0 for failure.\nint zkInvalidateEphemeralKey ( zkCTX ctx) Invalidate the ephemeral key. (Supported Devices: HSM6, Secure Compute Module).\nThis function invalidates the ephemeral key.\nParameters ctx — (input) Zymkey context.\nReturns 0 for success, less than 0 for failure.\nDigital Wallet (BIP32/39/44) int zkGenWalletMasterSeedWithBIP39 ( zkCTX ctx, ZK_EC_KEY_TYPE type, const char * variant, const char * wallet_name, const uint8_t * master_generator_key, int master_generator_key_size, const char * passphrase, char ** mnemonic) Generate master seed to start a new blockchain wallet. (Supported Devices: HSM6, Secure Compute Module).\nThis function generates a new blockchain master seed for creating a new wallet.\nParameters ctx — (input) Zymkey context.\ntype — (input) The type of key to generate (ZK_EC_KEY_TYPE).\nvariant — (input) The variant of the key_type to generate. Currently only “cardano” is supported for ed25519.\nwallet_name — (input) An ASCII string which contains the name of the wallet.\nmaster_generator_key — (input) The master generator key used to help generate the master seed. Can be empty string.\nmaster_generator_key_size — (input) The size of the master generator key. If 0, no master generator key is used in the formulation of the master seed.\npassphrase — (input) The passphrase to generate a different BIP39_mnemonic. Can be empty string.\nmnemonic — (output) A pointer to the mnemonic sentence. If NULL, the master seed is generated per BIP32. Otherwise, the master seed is generated per recovery strategy and the mnemonic sentence is returned in this parameter. The string is null terminated and encoded in UTF-8 NFKD from the English dictionary.\nReturns allocated slot number if successful, less than 0 for failure.\nint zkGenWalletMasterSeedWithSLIP39 ( zkCTX ctx, ZK_EC_KEY_TYPE type, const char * variant, const char * wallet_name, const uint8_t * master_generator_key, int master_generator_key_size, int group_count, int group_threshold, int group_iteration_exponent, const char * master_passphrase) Generate master seed to start a new blockchain wallet. (Supported Devices: HSM6, Secure Compute Module).\nThis function opens a session to generate a new blockchain master seed with the ability to recover from SLIP39 shards.\nParameters ctx — (input) Zymkey context.\ntype — (input) The type of key to generate (ZK_EC_KEY_TYPE).\nvariant — (input) The variant of the key_type to generate. Currently only “cardano” is supported for ed25519.\nwallet_name — (input) An ASCII string which contains the name of the wallet.\nmaster_generator_key — (input) The master generator key used to help generate the master seed. Can be empty string.\nmaster_generator_key_size — (input) The size of the master generator key. If 0, no master generator key is used in the formulation of the master seed.\ngroup_count — (input) The total count of groups(shards) to split into.\ngroup_threshold — (input) The count of groups(shards) needed to restore the master seed.\ngroup_iteration_exponent — (input) The iteration of exponent of SLIP39.\nmaster_passphrase — (input) The master passphrase used for slip 39 recovery process.\nReturns 0 if successful on opening a SLIP39 session, less than 0 for failure.\nint zkSetSLIP39GroupInfo ( zkCTX ctx, int group_index, int member_count, int member_threshold) Set the active SLIP39 group and the amount of members needed. (Supported Devices: HSM6, Secure Compute Module).\nThis function configures the active group to generate the number of shards requested for the active group.\nParameters ctx — (input) Zymkey context.\ngroup_index — (input) The index of the group to generate shards from. Index starts at 0.\nmember_count — (input) The total amount of member shards in this group to generate.\nmember_threshold — (input) The number of member shards needed to recreate this group in recovery.\nReturns 0 if successful on configuring the active group, less than 0 for failure.\nint zkAddSLIP39MemberPassword ( zkCTX ctx, const char * passhrase, char ** mnemonic_sentence) Generate a new SLIP39 member shard. (Supported Devices: HSM6, Secure Compute Module).\nThis function generates a new SLIP39 member shard. The shard can optionally have a password attached to it.\nParameters ctx — (input) Zymkey context.\npasshrase — (input) Password for the shard. Can be empty string.\nmnemonic_sentence — (output) The mnemonic sentence of the shard.\nReturns 0 if successful on opening a SLIP39 session, less than 0 for failure.\nint zkCancelSLIP39Session ( zkCTX ctx) Cancels the current active SLIP39 session (Supported Devices: HSM6, Secure Compute Module).\nThis function cancels open active SLIP39 sessions. For both generation and restore SLIP39 sessions.\nParameters ctx — (input) Zymkey context.\nReturns 0 if successful on aborting a SLIP39 session, less than 0 for failure.\nint zkGenOversightWallet ( zkCTX ctx, ZK_EC_KEY_TYPE type, const char * variant, const uint8_t * pub_key, const uint8_t * chain_code, const char * node_addr, const char * wallet_name) Generate master seed to start a new blockchain wallet. (Supported Devices: HSM6, Secure Compute Module).\nThis function generates a new blockchain master seed for creating a new wallet.\nParameters ctx — (input) Zymkey context.\ntype — (input) The type of key to generate (ZK_EC_KEY_TYPE).\npub_key — (input) The public key to create the oversight wallet from. Should come from a hardened node in a node tree.\nchain_code — (input) The chain code of the public key being used to create the oversight wallet.\nnode_addr — (input) The node address index of the public key being used.\nwallet_name — (input) The name of the oversight wallet being created.\nReturns allocated slot number if successful, less than 0 for failure.\nint zkGenWalletChildKey ( zkCTX ctx, int parent_key_slot, uint32_t index, bool is_hardened, bool return_chain_code, uint8_t ** chain_code) Generate child key from a parent key in a blockchain wallet . (Supported Devices: HSM6, Secure Compute Module).\nThis function generates a new child key descendent from a specified parent key in a wallet.\nParameters ctx — (input) Zymkey context.\nparent_key_slot — (input) The parent key slot to base the child key derivation on.\nindex — (input) The index of the child seed. This determines the node address as well as the outcome of the key generation.\nis_hardened — (input) If true, a hardened key is generated.\nreturn_chain_code — (input) If true, returns the chain code of the public key that was just generated. Has to be a hardened node as well.\nchain_code — (output) the chain code of the public key.\nReturns allocated slot number if successful, less than 0 for failure.\nint zkRestoreWalletMasterSeedFromBIP39Mnemonic ( zkCTX ctx, ZK_EC_KEY_TYPE type, const char * variant, const char * wallet_name, const uint8_t * master_generator_key, int master_generator_key_size, const char * BIP39_passphrase, char * BIP39_mnemonic) Restore a master seed from a BIP39 mnemonic and a master generator key. (Supported Devices: HSM6, Secure Compute Module).\nThis function restores a wallet master seed from a supplied BIP39 mnemonic string and a master generator key.\nParameters ctx — (input) Zymkey context.\ntype — (input) The type of key to generate (ZK_KEY_TYPE).\nvariant — (input) The variant of the key_type to generate. Currently only “cardano” is supported for ed25519.\nwallet_name — (input) An ASCII string which contains the name of the wallet.\nmaster_generator_key — (input) The master generator key used to help generate the master seed.\nmaster_generator_key_size — (input) The size of the master generator key. If 0, no master generator key is used in the formulation of the master seed.\nBIP39_passphrase — (input) The passphrase used to generate the BIP39_mnemonic.\nBIP39_mnemonic — (input) The BIP39_mnemonic string, null terminated and UTF-8 NFKD encoded from the BIP39 English dictionary.\nReturns allocated slot number if successful, less than 0 for failure.\nint zkRestoreWalletMasterSeedFromSLIP39 ( zkCTX ctx, ZK_EC_KEY_TYPE type, const char * variant, const char * wallet_name, const uint8_t * master_generator_key, int master_generator_key_size, const char * SLIP39_passphrase) Open a SLIP39 restore master seed session (Supported Devices: HSM6, Secure Compute Module).\nThis function starts a restore SLIP39 session, in order to start feeding shards into.\nParameters ctx — (input) Zymkey context.\ntype — (input) The type of key to generate (ZK_KEY_TYPE).\nvariant — (input) The variant of the key_type to generate. Currently only “cardano” is supported for ed25519.\nwallet_name — (input) An ASCII string which contains the name of the wallet.\nmaster_generator_key — (input) The master generator key used to help generate the master seed.\nmaster_generator_key_size — (input) The size of the master generator key. If 0, no master generator key is used in the formulation of the master seed.\nSLIP39_passphrase — (input) The master passphrase.\nReturns allocated slot number if successful, less than 0 for failure.\nint zkAddRestoreSLIP39Mnemonic ( zkCTX ctx, const char * passphrase, const char * mnemonic_sentence) Feed a SLIP39 shard to restore a master seed (Supported Devices: HSM6, Secure Compute Module).\nThis function will feed a shard to the module until the conditions are met and a master seed is generated.\nParameters ctx — (input) Zymkey context.\npassphrase — (input) The passphrase that was attached to the shard.\nmnemonic_sentence — (input) The twenty-four word sentence mnemonic shard.\nReturns allocated slot number when all shards required are fed in, less than 0 for no change.\nint zkGetWalletNodeAddrFromKeySlot ( zkCTX ctx, int slot, char ** node_addr, char ** wallet_name, int * master_seed_slot) Derive the node address from a key slot number. (Supported Devices: HSM6, Secure Compute Module).\nThis function derives a node address from an input key slot number.\nParameters ctx — (input) Zymkey context.\nslot — (input) A key slot number that is part of a digital wallet.\nnode_addr — (output) A pointer to a pointer which will contain the node address in ASCII.\nwallet_name — (output) A pointer to a pointer which will contain the wallet name in ASCII. If NULL, this parameter will not be retrieved.\nmaster_seed_slot — (output) A pointer to an integer which will contain the master seed key slot. If NULL, this parameter will not be retrieved.\nReturns 0 if successful, less than 0 for failure.\nint zkGetWalletKeySlotFromNodeAddr ( zkCTX ctx, const char * node_addr, const char * wallet_name, int master_seed_slot, int * slot) Derive the slot address from a node address. (Supported Devices: HSM6, Secure Compute Module).\nThis function returns the slot number associated with a given node address.\nParameters ctx — (input) Zymkey context.\nnode_addr — (input) A pointer which contains the node address in ASCII.\nwallet_name — (input) A pointer which contains the wallet name in ASCII, used to identify the wallet identity. If desired, this parameter can be NULL and the master_seed_slot parameter can be specified instead.\nmaster_seed_slot — (input) The master seed slot. Can be used to specify the wallet identity instead of the wallet name.\nslot — (output) A pointer to an integer which contains the associated key slot.\nReturns 0 if successful, less than 0 for failure.\nPerimeter Detect int zkSetPerimeterEventAction ( zkCTX ctx, int channel, uint32_t action_flags) Set perimeter breach action.\nThis function specifies the action to take when a perimeter breach event occurs. The possible actions are any combination of:\nNotify host. Zymkey self-destruct. Parameters channel — (input) The channel (0 or 1) that the action flags will be applied to.\naction_flags — (input) The actions to apply to the perimeter event channel:\nNotify (ZK_PERIMETER_EVENT_ACTION_NOTIFY). Self-destruct (ZK_PERIMETER_EVENT_ACTION_SELF_DESTRUCT). Returns 0 for success, less than 0 for failure.\nint zkSetDigitalPerimeterDetectLPPeriod ( zkCTX ctx, int lp_period) Set the low power period (Supported Devices: HSM6, Secure Compute Module).\nThis function sets low power period on the digital perimeter detect.\nParameters ctx — (input) Zymkey context.\nlp_period — (input) low power period in microseconds.\nReturns 0 if successful, less than 0 for failure.\nint zkSetDigitalPerimeterDetectLPMaxBits ( zkCTX ctx, int max_num_bits) Set the low power max number of bits (Supported Devices: HSM6, Secure Compute Module).\nThis function sets low power max number of bits on the digital perimeter detect.\nParameters ctx — (input) Zymkey context.\nmax_num_bits — (input) max number of bits.\nReturns 0 if successful, less than 0 for failure.\nint zkSetDigitalPerimeterDetectDelays ( zkCTX ctx, int min_delay_ns, int max_delay_ns) Set the delays (Supported Devices: HSM6, Secure Compute Module).\nThis function sets delays on the digital perimeter detect.\nParameters ctx — (input) Zymkey context.\nmin_delay_ns — (input) minimum delay in nanoseconds.\nmax_delay_ns — (input) maximum delay in nanoseconds.\nReturns 0 if successful, less than 0 for failure.\nint zkWaitForPerimeterEvent ( zkCTX ctx, uint32_t timeout_ms) Wait for a perimeter breach event to be detected.\nThis function is called in order to wait for a perimeter breach event to occur. This function blocks the calling thread unless called with a timeout of zero. Note that, in order to receive perimeter events, the zymkey must have been configured to notify the host on either or both of the perimeter detect channels via a call to “zkSetPerimeterEventAction”.\nParameters timeout_ms — (input) The maximum amount of time in milliseconds to wait for a perimeter event to arrive.\nReturns 0 for success, less than 0 for failure, -ETIMEDOUT when no perimeter events detected within the specified timeout.\nint zkGetPerimeterDetectInfo ( zkCTX ctx, uint32_t ** timestamps_sec, int * num_timestamps) Get current perimeter detect info.\nThis function gets the timestamp of the first perimeter detect event for the given channel.\nParameters timestamps_sec — (output) The timestamps for when any breach occurred. The index in this array corresponds to the channel number used by zkSetPerimeterEventAction. A 0 value means no breach has occurred on this channel. This array is allocated by this routine and so it must be freed by the caller.\nnum_timestamps — (output) The number of timestamps in the returned array.\nReturns 0 for success, less than 0 for failure.\nint zkClearPerimeterDetectEvents ( zkCTX ctx) Clear perimeter detect events.\nThis function clears all perimeter detect event info and rearms all perimeter detect channels.\nReturns 0 for success, less than 0 for failure.\nLED Control int zkLEDOff ( zkCTX ctx) Turns the LED off.\nParameters ctx — (input) Zymkey context.\nReturns 0 for success, less than 0 for failure.\nint zkLEDOn ( zkCTX ctx) Turns the LED on.\nParameters ctx — (input) Zymkey context.\nReturns 0 for success, less than 0 for failure.\nint zkLEDFlash ( zkCTX ctx, uint32_t on_ms, uint32_t off_ms, uint32_t num_flashes) Flashes the LED.\nParameters ctx — (input) Zymkey context.\non_ms — (input) The amount of time, in milliseconds, that the LED will stay on during a flash cycle.\noff_ms — (input) The amount of time, in milliseconds, that the LED will stay off during a flash cycle.\nnum_flashes — (input) The number of on/off flash cycles to complete. If this parameter is 0, then the LED will flash indefinitely.\nReturns 0 for success, less than 0 for failure.\nAdministrative Ops int zkSetI2CAddr ( zkCTX ctx, int addr) Sets the i2c address of the Zymkey (i2c versions only).\nThis method should be called if the i2c address of the Zymkey is shared with another i2c device on the same i2c bus. The default i2c address for Zymkey units is 0x30. Currently, the address may be set in the ranges of 0x30 - 0x37 and 0x60 - 0x67. After successful completion of this command, the Zymkey will reset itself.\nParameters addr — (input) The i2c address that the Zymkey will set itself to.\nReturns 0 for success, less than 0 for failure.\nTime int zkGetTime ( zkCTX ctx, uint32_t * epoch_time_sec, bool precise_time) Get current GMT time.\nThis function is called to get the time directly from a Zymkey’s Real Time Clock (RTC).\nParameters epoch_time_sec — (output) The time in seconds from the epoch (Jan. 1, 1970).\nprecise_time — (input) If true, this API returns the time after the next second falls. This means that the caller could be blocked up to one second. If false, the API returns immediately with the current time reading.\nReturns 0 for success, less than 0 for failure.\nAccelerometer int zkSetTapSensitivity ( zkCTX ctx, int axis, float pct) Sets the sensitivity of tap operations.\nThis method permits setting the sensitivity of the tap detection feature. Each axis may be individually configured or all at once.\nParameters axis — (input) The axis to configure. This parameter should contain one of the values in the enum typedef ACCEL_AXIS_TYPE.\npct — (input) The sensitivity expressed as percentage.\nReturns 0 for success, less than 0 for failure.\nint zkWaitForTap ( zkCTX ctx, uint32_t timeout_ms) Wait for a tap event to be detected.\nThis function is called in order to wait for a tap event to occur. This function blocks the calling thread unless called with a timeout of zero.\nParameters timeout_ms — (input) The maximum amount of time in milliseconds to wait for a tap event to arrive.\nReturns 0 for success, less than 0 for failure, -ETIMEDOUT when no tap events detected within the specified timeout.\nint zkGetAccelerometerData ( zkCTX ctx, zkAccelAxisDataType * x, zkAccelAxisDataType * y, zkAccelAxisDataType * z) Get current accelerometer data and tap info.\nThis function gets the most recent accelerometer data in units of g forces plus the tap direction per axis.\nParameters x — (output) x axis accelerometer information y (output) y axis accelerometer information z (output) z axis accelerometer information.\nReturns 0 for success, less than 0 for failure.\nBinding Management int zkLockBinding ( zkCTX ctx) Set soft binding lock.\nThis function locks the binding for a specific HSM. This API is only valid for HSM series products.\nReturns 0 for success, less than 0 for failure.\nint zkGetCurrentBindingInfo ( zkCTX ctx, bool * binding_is_locked, bool * is_bound) Get current binding info.\nThis function gets the current binding lock state as well as the current binding state. This API is only valid for devices in the HSM family.\nParameters binding_is_locked — (output) Binary value which expresses the current binding lock state. is_bound (output) Binary value which expresses the current bind state.\nReturns 0 for success, less than 0 for failure.\nModule Info int zkGetModelNumberString ( zkCTX ctx, char ** model_str) Get Zymkey model number.\nThis function retrieves the model number of the zymkey referred to in a specified context.\nParameters ctx — (input) Zymkey context which was created with zkOpen.\nmodel_str — (output) A double pointer to the model string. This function allocates this string. It is the caller’s responsibility to free it.\nReturns 0 for success, less than 0 for failure.\nint zkGetFirmwareVersionString ( zkCTX ctx, char ** fw_ver_str) Get Zymkey firmware version.\nThis function retrieves the firmware version number of the zymkey referred to in a specified context.\nParameters ctx — (input) Zymkey context which was created with zkOpen.\nversion_str — (output) A double pointer to the firmware version string. This function allocates this string. It is the caller’s responsibility to free it.\nReturns 0 for success, less than 0 for failure.\nint zkGetSerialNumberString ( zkCTX ctx, char ** serial_num_str) Get Zymkey serial number.\nThis function retrieves the serial number of the zymkey referred to in a specified context.\nParameters ctx — (input) Zymkey context which was created with zkOpen.\nserial_num_str — (output) A double pointer to the serial number string. This function allocates this string. It is the caller’s responsibility to free it.\nReturns 0 for success, less than 0 for failure.\nint zkGetCPUTemp ( zkCTX ctx, float * cpu_temp) Get current HSM CPU temperature. (Supported Devices: HSM6, Secure Compute Module).\nThis function gets the current HSM CPU temp.\nParameters cpu_temp — (output) The temperature in celsius of the CPU.\nReturns 0 for success, less than 0 for failure.\nint zkGetAUXTemp ( zkCTX ctx, int index, float * aux_temp) Get current AUX temperature. (Only for secure compute modules).\nThis function gets an aux temp. THIS FUNCTION IS FOR INTERNAL ZYMBIT USE ONLY.\nParameters ctx — (input) Zymkey context.\nindex — (input) Index for which aux temp to be polled.\naux_temp — (output) The temperature in celsius.\nReturns 0 for success, less than 0 for failure.\nint zkGetRTCDrift ( zkCTX ctx, float * rtc_drift) Get current RTC drift. (Supported Devices: HSM6, Secure Compute Module).\nThis function is called to get the current RTC drift.\nParameters rtc_drift — (output) The RTC drift.\nReturns 0 for success, less than 0 for failure.\nint zkGetBatteryVoltage ( zkCTX ctx, float * batt_voltage) Get the battery voltage (Supported Devices: HSM6, Secure Compute Module).\nThis function gets the current battery voltage.\nParameters ctx — (input) Zymkey context.\nbattV — (output) The current battery voltage value.\nReturns 0 if successful, less than 0 for failure.\nBattery Voltage Monitor int zkSetBatteryVoltageAction ( zkCTX ctx, int action) Set battery voltage threshold action. (Supported Devices: HSM6, Secure Compute Module).\nThis function specifies the action to take when the battery voltage falls below the threshold set by zkSetBatteryVoltageThreshold. If this function is never called, do nothing is default. There are three actions:\nDo nothing. Go to sleep until battery is replaced. Self-destruct. Parameters action — (input) The action to apply, specify one of the ZK_THRESHOLD_ACTION_TYPE:\nDo nothing (ZK_ACTION_NONE). Sleep (ZK_ACTION_SLEEP). Self-destruct (ZK_ACTION_SELF_DESTRUCT). Returns 0 for success, less than 0 for failure.\nint zkSetBatteryVoltageThreshold ( zkCTX ctx, float threshold) Sets the battery voltage threshold. (Supported Devices: HSM6, Secure Compute Module).\nThis function sets the threshold at which if the battery voltage falls bellow, the action set by zkSetBatteryVoltageAction will be carried out. The recommended threshold is 2.3V. If this function isn’t called 2.3V is assumed by default. Threshold must be below 2.5V.\nParameters threshold — (input) The threshold in Volts.\nReturns 0 for success, less than 0 for failure.\nCPU Temperature Monitor int zkSetCPUTempAction ( zkCTX ctx, int action) Set HSM CPU temperature threshold action. (Supported Devices: HSM6, Secure Compute Module).\nThis function specifies the action to take when the HSM CPU temperature falls below the threshold set by zkSetCPULowTempThreshold, or rises above the threshold set by zkSetCPUHighTempThreshold. There are two actions to apply:\nDo nothing. Self-destruct. Parameters action — (input) The action to apply, used it’s named constant from ZK_THRESHOLD_ACTION_TYPE:\nDo nothing (ZK_ACTION_NONE). Self-destruct (ZK_ACTION_SELF_DESTRUCT). Returns 0 for success, less than 0 for failure.\nint zkSetCPULowTempThreshold ( zkCTX ctx, float threshold) Sets the HSM CPU low temperature threshold. (Supported Devices: HSM6, Secure Compute Module).\nThis function sets the threshold at which if the on-board HSM CPU’s tempreature falls below, the action set by zkSetCPUTempAction will be carried out. WARNING: You can lock yourself out in dev mode if you set a threshold above the CPU’s ambient temperature. The recommended setting is no more than 20C. If no threshold is set, -10 degrees celsius is set as default.\nParameters threshold — (input) The threshold in celsius.\nReturns 0 for success, less than 0 for failure.\nint zkSetCPUHighTempThreshold ( zkCTX ctx, float threshold) Sets the HSM CPU high temperature threshold. (Supported Devices: HSM6, Secure Compute Module).\nThis function sets the threshold at which if the on-board HSM CPU’s tempreature rises above, the action set by zkSetCPUTempAction will be carried out. WARNING: You can lock yourself out in dev mode if you set a threshold below the CPU’s ambient temperature. The recommended setting is no less than 40C. If no threshold is set, 65 degrees celsius is set as default.\nParameters threshold — (input) The threshold in celsius.\nReturns 0 for success, less than 0 for failure.\nint zkSetSupervisedBootPolicy ( zkCTX ctx, int policy_id) Sets the Supervised boot policy. (Supported Devices: Secure Compute Module).\nThis function specifies the action to take when Supervised boot event triggers based on a file change.\nParameters policy_id — (input) The actions to apply to the Supervised boot process:\n0 Do Nothing (ZK_SUPBOOT_FAIL_NO_ACTION). 1 Self-Destruct (ZK_SUPBOOT_FAIL_DESTROY). 2 Hold Chip in Reset (ZK_SUPBOOT_FAIL_HOLD_RESET). Returns 0 for success, less than 0 for failure.\nint zkAddOrUpdateSupervisedBootFile ( zkCTX ctx, const char * file_path, int slot) Update file manifest for Supervised boot to check. (Supported Devices: Secure Compute Module).\nThis function adds or updates files to be checked by Supervised boot.\nParameters file_path — (input) The file to be signed and checked by Supervised boot.\nslot — (input) The slot to sign the file with.\nReturns 0 for success, less than 0 for failure.\nint zkRemoveSupervisedBootFile ( zkCTX ctx, const char * file_path) Remove a file from file manifest for Supervised boot to check. (Supported Devices: Secure Compute Module).\nThis function removes a file to be checked by Supervised boot.\nParameters file_path — (input) The file to be removed from the Supervised boot manifest.\nReturns 0 for success, less than 0 for failure.\nint zkGetSupervisedBootFileManifest ( zkCTX ctx, char ** manifest) Get file manifest for Supervised boot to check. (Supported Devices: Secure Compute Module).\nThis function gets the list of files to be checked by Supervised boot.\nParameters manifest — (output) The file manifest that is checked by Supervised boot.\nReturns 0 for success, less than 0 for failure.\n","categories":"","description":"C interface to Zymkey Application Utilities Library.","excerpt":"C interface to Zymkey Application Utilities Library.","ref":"/api/c_api/","tags":"","title":"C API Documentation"},{"body":" Introduction C++ interface to Zymkey Application Utilities Library.\nThis file contains the C API to the the Zymkey Application Utilities library. This API facilitates writing user space applications which use Zymkey to perform cryptographic operations, such as:\nSigning of payloads using ECDSA. Verification of payloads that were signed using Zymkey. Exporting the public key that matches Zymkey’s private key. “Locking” and “unlocking” data objects. Generating random data Additionally, there are functions for changing the i2c address (i2c units only), setting tap sensitivity and controlling the LED. Typedefs typedef std::vector\u003cuint8_t\u003ebyteArray Typedef for a simple unsigned bytes container.\ntypedef std::vector\u003cint\u003eintArray Typedef for a simple integer container.\nStructs struct accelData #include \u003czkAppUtilsClass.h\u003e Structure typedef used for retrieval of accelerometer data.\ndouble x double y double z int tapDirX int tapDirY int tapDirZ Classes class recoveryStrategyBaseType zkAppUtilsClass.h Class used for retrieval of recovery mnemonic for Bip32 wallet.\nSubclassed by Public Functions recoveryStrategyBaseType ( const std::string \u0026 key_variant = \"\") ~recoveryStrategyBaseType () inline ZK_RECOVERY_STRATEGYgetRecoveryStrategy ()const inline voidsetVariant ( const std::string \u0026 key_variant) inline std::stringgetVariant ()const inline virtual std::stringgetPassPhrase ()const class recoveryStrategyBIP39 zkAppUtilsClass.h Class used for BIP39 recovery strategy. User can set b64 encoded passphrase and key variant (only “cardano” is supported for ed25519 currently) for bip32 seed generation. It can also hold the mnemonic sentence from master seed generation.\nPublic Functions recoveryStrategyBIP39 ( const std::string \u0026 passphrase = \"\", const std::string \u0026 key_variant = \"\") ~recoveryStrategyBIP39 () inline voidsetPassPhrase ( const std::string \u0026 passphrase) inline virtual std::stringgetPassPhrase ()const Private Members std::string passPhrase class recoveryStrategySLIP39 Public Functions recoveryStrategySLIP39 ( int group_count, int group_threshold, int iteration_exponent, const std::string \u0026 passphrase = \"\", const std::string \u0026 key_variant = \"\") ~recoveryStrategySLIP39 () inline voidsetPassPhrase ( const std::string \u0026 passphrase) inline virtual std::stringgetPassPhrase ()const inline voidsetGroupCount ( int group_count) inline intgetGroupCount ()const inline voidsetGroupThreshold ( int group_threshold) inline intgetGroupThreshold ()const inline voidsetIterationExponent ( int iteration_exponent) inline intgetIterationExponent ()const Private Members int groupCount int groupThreshold int iterationExponent std::string passPhrase class zkClass zkAppUtilsClass.h The main class.\nZymkey Context zkClass () Constructor: a Zymkey context is opened.\nExceptions zkAppUtilsException upon error virtual ~zkClass () Destructor: the Zymkey context is closed.\nRandom Number Generation void createRandDataFile ( std::string \u0026 dst_filename, int rdata_sz) Write random data to a file.\nParameters dst_filename — A string containing the absolute path to the file where random data is written.\nrdata_sz — The number of random bytes to generate.\nExceptions zkAppUtilsException upon error :: *getRandBytes ( int rdata_sz) Generate a block of random data.\nParameters rdata_sz — The number of random bytes to generate.\nExceptions zkAppUtilsException upon error Returns A pointer to container with the random bytes.\nLock Data void lockData ( const std::string \u0026 src_pt_filename, const std::string \u0026 dst_ct_filename, bool use_shared_key = false) Locks data from a plaintext source file and stores locked data object to a destination file.\nParameters src_pt_filename — Absolute path to source plaintext file.\ndst_ct_filename — Absolute path to destination file which will contain locked data object.\nuse_shared_key — Determines whether one-way or shared key is used for locking. Default = false.\nExceptions zkAppUtilsException upon error void lockData ( const zkAppUtils::byteArray \u0026 src_pt_data, const std::string \u0026 dst_ct_filename, bool use_shared_key = false) Locks data from a plaintext source byte container and stores locked data object to a destination file.\nParameters src_pt_data — Unsigned byte container which holds source plaintext data.\ndst_ct_filename — Absolute path to destination file which will contain locked data object.\nuse_shared_key — Determines whether one-way or shared key is used for locking. Default = false.\nExceptions zkAppUtilsException upon error :: *lockData ( const std::string \u0026 src_pt_filename, bool use_shared_key = false) Locks data from a plaintext source file and stores locked data object in a container of unsigned bytes.\nParameters src_pt_filename — Absolute path to source plaintext file.\nuse_shared_key — Determines whether one-way or shared key is used for locking. Default = false.\nExceptions zkAppUtilsException upon error Returns Byte container with locked data.\n:: *lockData ( const zkAppUtils::byteArray \u0026 src_pt_data, bool use_shared_key = false) Locks data from a plaintext source byte container and stores locked data object in a container of unsigned bytes.\nParameters src_pt_data — Unsigned byte container which holds source plaintext data.\nuse_shared_key — Determines whether one-way or shared key is used for locking. Default = false.\nExceptions zkAppUtilsException upon error Returns Byte container with locked data.\nUnlock Data void unlockData ( const std::string \u0026 src_ct_filename, const std::string \u0026 dst_pt_filename, bool use_shared_key = false) Unocks a locked data object from source file and stores unlocked data object to a destination file.\nParameters src_ct_filename — Absolute path to source file which contains locked data object.\ndst_pt_filename — Absolute path to destination file which will contain unlocked plaintext data.\nuse_shared_key — Determines whether one-way or shared key is used for locking. Default = false.\nExceptions zkAppUtilsException upon error void unlockData ( const zkAppUtils::byteArray \u0026 src_ct_data, const std::string \u0026 dst_pt_filename, bool use_shared_key = false) Unlocks a locked data object contained in an unsigned byte container and stores plaintext data to a destination file.\nParameters src_ct_data — Unsigned byte container which holds locked data object.\ndst_pt_filename — Absolute path to destination file which will contain unlocked plaintext data.\nuse_shared_key — Determines whether one-way or shared key is used for locking. Default = false.\nExceptions zkAppUtilsException upon error :: *unlockData ( const std::string \u0026 src_ct_filename, bool use_shared_key = false) Unlocks a locked data object from a plaintext source file and stores plaintext data in a container of unsigned bytes.\nParameters src_ct_filename — Absolute path to source file which contains locked data object.\nuse_shared_key — Determines whether one-way or shared key is used for locking. Default = false.\nExceptions zkAppUtilsException upon error Returns Byte container with plaintext data.\n:: *unlockData ( const zkAppUtils::byteArray \u0026 src_ct_bytes, bool use_shared_key = false) Unlocks a locked data object contained in an unsigned byte container and stores plaintext data in a container of unsigned bytes.\nParameters src_ct_data — Unsigned byte container which holds locked data object.\nuse_shared_key — Determines whether one-way or shared key is used for locking. Default = false.\nExceptions zkAppUtilsException upon error Returns Byte container with plaintext data.\nECDSA :: *genECDSASigFromDigest ( zkAppUtils::byteArray \u0026 digest, int slot = 0) Generate a signature from a data digest using the Zymkey’s private key.\nParameters digest — Currently, this should be a SHA256 digest.\nslot — The key slot to use for verification.\nExceptions zkAppUtilsException upon error Returns Byte container with binary signature.\n:: *genECDSASigFromDigest ( zkAppUtils::byteArray \u0026 digest, uint8_t \u0026 recovery_id, int slot = 0) Generate a signature from a data digest using the Zymkey’s private key.\nParameters digest — Currently, this should be a SHA256 digest.\nslot — The key slot to use for verification.\nrecovery_id — [Output]Returns recovery id value needed for ethereum key recovery.\nExceptions zkAppUtilsException upon error Returns Byte container with binary signature.\nbool verifyECDSASigFromDigest ( zkAppUtils::byteArray \u0026 digest, zkAppUtils::byteArray \u0026 sig, int pub_key_slot = 0, bool pub_key_is_foreign = false) Verify a signature from a data digest using the Zymkey’s public key. The public key is not given as an input. Rather, the Zymkey uses its own copy of the private key. This insures that the public key that matches the private key is used.\nParameters digest — Currently, this should be a SHA256 digest.\nsig — The signature to verify.\npub_key_slot — The key slot to use for verification.\npub_key_is_foreign — If false, the normal key store is referenced. Otherwise, the foreign public key store is referenced.\npub_key_is_foreign — If false, the normal key store is referenced. Otherwise, the foreign public key store is referenced.\nReturns true = signature verification passed, false = signature verification failed.\nECDH and KDF :: *doRawECDH ( int slot, zkAppUtils::byteArray \u0026 peer_pubkey) Perform a raw ECDH operation. (Supported Devices: HSM6, Secure Compute Module).\nPerform an ECDH operation with no Key Derivation Function (KDF). The raw pre-master secret is returned in the response. The peer public key is presented in the call.\nParameters slot — The key slot to use for the local key. If this parameter is -1, the ephemeral key is used.\npeer_pubkey — The peer public key.\nReturns Byte container with pre master secret.\n:: *doRawECDHWithIntPeerPubkey ( int slot, int peer_pubkey_slot, bool peer_pubkey_slot_is_foreign) Perform a raw ECDH operation. (Supported Devices: HSM6, Secure Compute Module).\nPerform an ECDH operation with no Key Derivation Function (KDF). The raw pre-master secret is returned in the response. The peer public key is referenced from the zymkey internal key store.\nParameters slot — The key slot to use for the local key. If this parameter is -1, the ephemeral key is used.\npeer_pubkey_slot — The peer public key slot where the peer public key is to be found.\npeer_pubkey_slot_is_foreign — If true, the peer public key slot is found in the foreign public keyring.\nReturns Byte container with pre master secret.\n:: *doECDHAndKDF ( ZK_ECDH_KDF_TYPE kdf_type, int slot, zkAppUtils::byteArray \u0026 peer_pubkey, zkAppUtils::byteArray \u0026 salt, zkAppUtils::byteArray \u0026 info, int num_iterations, int derived_key_sz) Perform an ECDH operation plus Key Derivation Function. (Supported Devices: HSM6, Secure Compute Module).\nPerform an ECDH operation with Key Derivation Function (KDF). The derived key is returned in the response. The peer public key is presented in the call.\nParameters slot — The key slot to use for the local key. If this parameter is -1, the ephemeral key is used.\npeer_pubkey — The peer public key.\nsalt — The salt to use for the selected KDF.\ninfo — The info field to use for RFC 5869. Ignored for PBKDF2.\nnum_iterations — Number of iterations to carry out (PBKDF only).\nderived_key_sz — The desired number of bytes to return for the KDF. For RFC 5869, this value must be less than 8160 bytes (SHA256) or 16320 (SHA512).\nReturns Byte container with pre master secret.\n:: *doECDHAndKDFWithIntPeerPubkey ( ZK_ECDH_KDF_TYPE kdf_type, int slot, int peer_pubkey_slot, bool peer_pubkey_slot_is_foreign, zkAppUtils::byteArray \u0026 salt, zkAppUtils::byteArray \u0026 info, int num_iterations, int derived_key_sz) Perform an ECDH operation plus Key Derivation Function. (Supported Devices: HSM6, Secure Compute Module).\nPerform an ECDH operation with Key Derivation Function (KDF). The derived key is returned in the response. The peer public key is referenced from the zymkey internal key store.\nParameters slot — The key slot to use for the local key. If this parameter is -1, the ephemeral key is used.\npeer_pubkey_slot — The peer public key slot where the peer public key is to be found.\npeer_pubkey_slot_is_foreign — If true, the peer public key slot is found in the foreign public keyring.\nsalt — The salt to use for the selected KDF.\ninfo — The info field to use for RFC 5869. Ignored for PBKDF2.\nnum_iterations — Number of iterations to carry out (PBKDF only).\nderived_key_sz — The desired number of bytes to return for the KDF. For RFC 5869, this value must be less than 8160 bytes (SHA256) or 16320 (SHA512).\nReturns Byte container with pre master secret.\nKey Management void saveECDSAPubKey2File ( std::string dst_filename, int slot = 0) [DEPRECATED] Use exportPubKey2File. Save the public key that matches the Zymkey’s private key into a PEM formatted file. Mainly used for Certificate Signing Request (CSR) generation.\nParameters dst_filename — Absolute location where the PEM formatted file is to be stored.\nslot — Reserved for future use.\nExceptions zkAppUtilsException upon error void exportPubKey2File ( std::string dst_filename, int pubkey_slot = 0, bool slot_is_foreign = false) Store the public key to a host file in PEM format.\nThis function is useful for generating Certificate Signing Requests (CSR).\nParameters dst_filename — Filename where PEM formatted public key is to be stored.\npubkey_slot — The key slot to retrieve. Zymkey and HSM4 have slots 0, 1, and 2.\nslot_is_foreign — If true, designates the pubkey slot to come from the foreign keystore. (Supported Devices: HSM6, Secure Compute Module).\nExceptions zkAppUtilsException upon error :: *getECDSAPubKey ( int slot = 0) [DEPRECATED] Use exportPubKey. Get a container of bytes which contains the ECDSA public key.\nParameters slot — Reserved for future use.\nExceptions zkAppUtilsException upon error Returns Byte container with binary public key.\n:: *exportPubKey ( int pubkey_slot = 0, bool slot_is_foreign = 0) Gets the public key and stores in a byte array created by this function.\nParameters pubkey_slot — The key slot to retrieve. Zymkey and HSM4 have slots 0, 1, and 2.\nslot_is_foreign — If true, designates the pubkey slot to come from the foreign keystore. (Supported Devices: HSM6, Secure Compute Module).\nExceptions zkAppUtilsException upon error * getAllocSlotsList ( bool foreign_key_pool) Get the list of allocated keys. (Supported Devices: HSM6, Secure Compute Module).\nThis function returns a list of all allocated key slots.\nParameters foreign_key_pool — (input) if true, retrieve allocation list of the foreign keys.\nReturns Array of the allocated keys.\nint storeForeignPubKey ( ZK_EC_KEY_TYPE pk_type, zkAppUtils::byteArray \u0026 pk) Store a new foreign public key in Zymkey. (Supported Devices: HSM6, Secure Compute Module).\nThis function stores a new foreign public key in the Zymkey public key ring. This public key can be used for signature verification in use cases where it is desirable to hide the public key.\nParameters pk_type — The type of the public key. {ZK_NISTP256, ZK_SECP256R1 = ZK_NISTP256, ZK_SECP256K1}.\npk — Public key to store.\nExceptions zkAppUtilsException upon error Returns Allocated slot number in foreign key store, less than 0 for failure.\nvoid disablePubKeyExport ( int pubkey_slot, bool slot_is_foreign = false) Prevent a public key from being exported to the host. (Supported Devices: HSM6, Secure Compute Module).\nThis function prevents the public key at the specified slot from being exported to the host using the API zkExportPubKey.\nParameters pubkey_slot — The key slot to disable pubkey export on.\nslot_is_foreign — The slot parameter refers to a slot in the foreign keyring.\nExceptions zkAppUtilsException upon error int genKeyPair ( ZK_EC_KEY_TYPE type) Generate a new persistent key pair. (Supported Devices: HSM6, Secure Compute Module).\nThis function generates a new key pair of the specified type and store it persistently. This key pair cannot be used as part of the zymkey’s digital wallet operations.\nParameters type — The type of key to generate (ZK_EC_KEY_TYPE). {ZK_NISTP256, ZK_SECP256R1 = ZK_NISTP256, ZK_SECP256K1}.\nExceptions zkAppUtilsException upon error Returns Allocated slot number if successful, less than 0 for failure.\nvoid genEphemeralKeyPair ( ZK_EC_KEY_TYPE type) Generate an ephemeral key pair. (Supported Devices: HSM6, Secure Compute Module).\nThis function generates an ephemeral key pair of the specified type. Ephemeral key pairs are useful when performing ECDH for time-of-flight encryption. Only one ephemeral key slot is available and is not persistent between reboots.\nParameters type — The type of key to generate (ZK_EC_KEY_TYPE). {ZK_NISTP256, ZK_SECP256R1 = ZK_NISTP256, ZK_SECP256K1}.\nExceptions zkAppUtilsException upon error void removeKey ( int slot, bool slot_is_foreign = false) Remove a key pair or a foreign public key. (Supported Devices: HSM6, Secure Compute Module).\nThis function deletes a key pair or a foreign public key from persistent storage.\nParameters slot — The slot.\nslot_is_foreign — The slot parameter refers to a slot in the foreign keyring.\nExceptions zkAppUtilsException upon error void invalidateEphemeralKey () Invalidate the ephemeral key. (Supported Devices: HSM6, Secure Compute Module).\nThis function invalidates the ephemeral key.\nExceptions zkAppUtilsException upon error Digital Wallet (BIP32/39/44) int genWalletMasterSeed ( ZK_EC_KEY_TYPE type, std::string \u0026 wallet_name, const zkAppUtils::recoveryStrategyBaseType \u0026 recovery_strategy zkAppUtils::recoveryStrategyBaseType = , const zkAppUtils::byteArray \u0026 master_generator_key zkAppUtils::byteArray = ) Generate a BIP32 master seed to start a new blockchain wallet. (Supported Devices: HSM6, Secure Compute Module).\nThis function generates a new blockchain master seed for creating a new wallet per BIP32.\nParameters type — The type of key to generate (ZK_EC_KEY_TYPE). {ZK_NISTP256, ZK_SECP256R1 = ZK_NISTP256, ZK_SECP256K1, ZK_ED25519, ZK_X25519}.\nwallet_name — An ASCII string which contains the name of the wallet.\nmnemonics(output) — Allocated mnemonics if it was asked for, based on recovery strategy used.\nmaster_generator_key — The master generator key used to help generate the master seed (bip32). Defaults to empty string.\nrecovery_strategy — The recovery strategy object for returning BIP39 or SLIP39 (starts a SLIP39 session instead of a one shot). Also contains key variants and passphrases. Defaults to no recovery strategy.\nReturns The slot the master seed was allocated to.\nint genWalletMasterSeed ( ZK_EC_KEY_TYPE type, std::string \u0026 wallet_name, const zkAppUtils::recoveryStrategyBIP39 \u0026 recovery_strategy, std::string * mnemonic_str, const zkAppUtils::byteArray \u0026 master_generator_key zkAppUtils::byteArray = ) int genWalletMasterSeed ( ZK_EC_KEY_TYPE type, std::string \u0026 wallet_name, const zkAppUtils::recoveryStrategySLIP39 \u0026 recovery_strategy, const zkAppUtils::byteArray \u0026 master_generator_key zkAppUtils::byteArray = ) int setGenSLIP39GroupInfo ( int group_index, int member_count, int member_threshold) Set the active SLIP39 group and the amount of members needed. (Supported Devices: HSM6, Secure Compute Module).\nThis function configures the active group to generate the number of shards requested for the active group.\nParameters group_index — The index of the group to generate shards from. Index starts at 0.\nmember_count — The total amount of member shards in this group to generate.\nmember_threshold — The number of member shards needed to recreate this group in recovery.\nReturns 0 if successful on configuring the active group, less than 0 for failure.\nint addGenSLIP39Member ( std::string passphrase, std::string * mnemonic_str) Generate a new SLIP39 member shard. (Supported Devices: HSM6, Secure Compute Module).\nThis function generates a new SLIP39 member shard. The shard can optionally have a password attached to it.\nParameters passphrase — Password for the shard. Can be empty string.\nmnemonic_str — (output) The mnemonic sentence of the shard.\nReturns 0 if successful on configuring the active group, less than 0 for failure.\nint cancelSLIP39Session () Cancels the current active SLIP39 session (Supported Devices: HSM6, Secure Compute Module).\nThis function cancels open active SLIP39 sessions. For both generation and restore SLIP39 sessions.\nReturns 0 if successful on configuring the active group, less than 0 for failure.\nint genOverSightWallet ( ZK_EC_KEY_TYPE type, zkAppUtils::byteArray \u0026 public_key, zkAppUtils::byteArray \u0026 chain_code, std::string \u0026 node_address, std::string \u0026 wallet_name, std::string \u0026 variant) Generate a oversight wallet from the last hardened node of a wallet node address (Supported Devices: HSM6, Secure Compute Module).\nThis function generates a new oversight wallet and are used to generate public keys in a deterministic way.\nParameters type — The type of key to generate (ZK_EC_KEY_TYPE). {ZK_NISTP256, ZK_SECP256R1 = ZK_NISTP256, ZK_SECP256K1, ZK_ED25519, ZK_X25519}.\npublic_key — The public_key of the last hardened node of the address.\nchain_code — The chain_code of the last hardened node of the address.\nnode_address — The node_address being derived from.\nwallet_name — An ASCII string which contains the name of the wallet.\nvariant — The key type variant to generate. Currently only “cardano” for ed25519 is supported.\nReturns The slot the oversight wallet was allocated to.\nint genWalletChildKey ( int parent_key_slot, uint32_t index, bool is_hardened, bool return_chain_code, zkAppUtils::byteArray * chain_code) Generate child key from a parent key in a wallet (Supported Devices: HSM6, Secure Compute Module).\nThis function generates a new child key descendent from a specified parent key in a wallet.\nParameters parent_key_slot — The parent key slot to base the child key derivation on.\nindex — The index of the child seed. This determines the node address as well as the outcome of the key generation.\nis_hardened — If true, a hardened key is generated.\nreturn_chain_code — If true, exports the chain code. Must be exported from a hardened node.\n(output) — Allocated chain_code if it was asked for.\nExceptions zkAppUtilsException upon error Returns Allocated slot number if successful, less than 0 for failure.\nint restoreWalletMasterSeedFromMnemonic ( ZK_EC_KEY_TYPE type, std::string \u0026 wallet_name, zkAppUtils::byteArray \u0026 master_generator_key, zkAppUtils::recoveryStrategyBIP39 \u0026 recovery_strategy, std::string \u0026 mnemonic_str) Restore a master seed from a BIP39 mnemonic and a master generator key. (Supported Devices: HSM6, Secure Compute Module).\nThis function restores a wallet master seed from a supplied BIP39 mnemonic string and a master generator key.\nParameters type — The type of key to generate (ZK_KEY_TYPE). {ZK_NISTP256, ZK_SECP256R1 = ZK_NISTP256, ZK_SECP256K1}.\nwallet_name — An ASCII string which contains the name of the wallet.\nmaster_generator_key — The master generator key used to help generate the master seed.\nrecovery_strategy — The recovery strategy used. Contains the passphrases and key variant to recover from.\nmnemonic_str — The mnemonic sentence to recover the master seed with. (Not used for SLIP39).\nExceptions zkAppUtilsException upon error Returns Allocated slot number if successful, less than 0 for failure.\nint restoreWalletMasterSeedFromMnemonic ( ZK_EC_KEY_TYPE type, std::string \u0026 wallet_name, zkAppUtils::byteArray \u0026 master_generator_key, zkAppUtils::recoveryStrategySLIP39 \u0026 recovery_strategy) int addRestoreSLIP39Mnemonic ( std::string passphrase, std::string mnemonic_sentence) Feed a SLIP39 shard to restore a master seed (Supported Devices: HSM6, Secure Compute Module).\nThis function will feed a shard to the module until the conditions are met and a master seed is generated.\nParameters passphrase — The passphrase that was attached to the shard.\nmnemonic_sentence — (output) The twenty-four word sentence mnemonic shard.\nReturns allocated slot number when all shards required are fed in, less than 0 for no change.\nint getWalletNodeAddrFromKeySlot ( int slot, std::string * out_node_addr, std::string * out_wallet_name = NULL) Derive the node address from a key slot number. (Supported Devices: HSM6, Secure Compute Module).\nThis function derives a node address from an input key slot number.\nParameters slot — (input) A key slot number that is part of a digital wallet.\nout_node_addr — (output) A pointer to a string which will contain the node address in ASCII.\nwallet_name — (output) A pointer to a string which will contain the wallet name in ASCII. If NULL, this parameter will not be retrieved.\nExceptions zkAppUtilsException upon error Returns The master seed key slot.\nint getWalletKeySlotFromNodeAddr ( std::string \u0026 node_addr, std::string \u0026 wallet_name, int master_seed_slot) Derive the slot address from a node address. (Supported Devices: HSM6, Secure Compute Module).\nThis function returns the slot number associated with a given node address.\nParameters node_addr — (input) A pointer which contains the node address in ASCII.\nwallet_name — (input) A pointer which contains the wallet name in ASCII, used to identify the wallet identity. If desired, this parameter can be NULL and the master_seed_slot parameter can be specified instead.\nmaster_seed_slot — (input) The master seed slot. Can be used to specify the wallet identity instead of the wallet name.\nExceptions zkAppUtilsException upon error Returns The associated key slot.\nLED Control void ledOff () Turn LED off.\nExceptions zkAppUtilsException upon error void ledOn () Turn LED on.\nExceptions zkAppUtilsException upon error void ledFlash ( uint32_t on_ms, uint32_t off_ms = 0, uint32_t num_flashes = 0) Flash LED a certain number of times.\nParameters on_ms — Number of milliseconds that the LED will be on during a flash cycle.\noff_ms — Number of milliseconds that the LED will be off during a flash cycle.\nnum_flashes — Number of flash cycles to execute. 0 = infinite.\nExceptions zkAppUtilsException upon error Administrative void setI2CAddr ( int addr) Sets the i2c address (i2c versions only). Used in case of i2c bus device address conflict.\nParameters addr — The i2c address to set. Upon successful change, the Zymkey will reset itself. However, if the address is the same as the current setting, the Zymkey will not reset. Valid address ranges are 0x30 - 0x37 and 0x60 - 0x67.\nExceptions zkAppUtilsException upon error Time uint32_t getTime ( bool precise_time = false) Get current GMT time.\nThis method is called to get the time directly from a Zymkey’s Real Time Clock (RTC).\nParameters precise_time — (input) If true, this API returns the time after the next second falls. This means that the caller could be blocked up to one second. If false, the API returns immediately with the current time reading.\nExceptions zkAppUtilsException upon error Returns The time in seconds from the epoch (Jan. 1, 1970).\nAccelerometer void setTapSensitivity ( float pct, ZK_ACCEL_AXIS_TYPE axis = ZK_ACCEL_AXIS_ALL) Sets the sensitivity of the tap detection as a percentage for an individual axis or all axes.\nParameters pct — Sensitivity expressed in percentage. 0% = off, 100% = maximum.\naxis — X, Y, Z or all (default).\nExceptions zkAppUtilsException upon error void waitForTap ( uint32_t timeout_ms) Wait for a tap event to be detected.\nThis function is called in order to wait for a tap event to occur. This function blocks the calling thread unless called with a timeout of zero.\nParameters timeout_ms — (input) The maximum amount of time in milliseconds to wait for a tap event to arrive.\nExceptions zkAppUtilsTimeoutException upon timeout or zkAppUtilsException upon other errors void getAccelerometerData ( zkAppUtils::accelData \u0026 accel_data) Get current accelerometer data and tap info.\nThis function gets the most recent accelerometer data in units of g forces plus the tap direction per axis. Array index 0 = x 1 = y 2 = z.\nParameters accel_data — (output) The current accelerometer data and tap information.\nExceptions zkAppUtilsException upon error Binding Management void lockBinding () Set soft binding lock.\nThis function locks the binding for a specific HSM. This API is only valid for HSM series products.\nExceptions zkAppUtilsException upon error void getCurrentBindingInfo ( bool \u0026 binding_is_locked, bool \u0026 is_bound) Get current binding info.\nThis function gets the current binding lock state as well as the current binding state. This API is only valid for devices in the HSM family.\nParameters binding_is_locked — (output) Binary value which expresses the current binding lock state. is_bound (output) Binary value which expresses the current bind state.\nExceptions zkAppUtilsException upon error Perimeter Detect void setPerimeterEventAction ( int channel, uint32_t action_flags) Set perimeter breach action.\nThis function specifies the action to take when a perimeter breach event occurs. The possible actions are any combination of:\nNotify host. Zymkey self-destruct. Parameters channel — (input) The channel (0 or 1) that the action flags will be applied to.\naction_flags — (input) The actions to apply to the perimeter event channel:\nNotify (ZK_PERIMETER_EVENT_ACTION_NOTIFY). Self-destruct (ZK_PERIMETER_EVENT_ACTION_SELF_DESTRUCT). Exceptions zkAppUtilsException upon error void setDigitalPerimeterDetectLPPeriod ( int lp_period) Set the low power period (Supported Devices: HSM6, Secure Compute Module).\nThis function sets low power period on the digital perimeter detect.\nParameters lp_period — (input) low power period in microseconds.\nExceptions zkAppUtilsException upon error Returns void.\nvoid setDigitalPerimeterDetectLPMaxBits ( int max_num_bits) Set the low power max number of bits (Supported Devices: HSM6, Secure Compute Module).\nThis function sets low power max number of bits on the digital perimeter detect.\nParameters max_num_bits — (input) max number of bits.\nExceptions zkAppUtilsException upon error Returns void.\nvoid setDigitalPerimeterDetectDelays ( int min_delay_ns, int max_delay_ns) Set the delays (Supported Devices: HSM6, Secure Compute Module).\nThis function sets delays on the digital perimeter detect.\nParameters min_delay_ns — (input) minimum delay in nanoseconds.\nmax_delay_ns — (input) maximum delay in nanoseconds.\nExceptions zkAppUtilsException upon error Returns void.\nvoid waitForPerimeterEvent ( uint32_t timeout_ms) Wait for a perimeter breach event to be detected.\nThis function is called in order to wait for a perimeter breach event to occur. This function blocks the calling thread unless called with a timeout of zero. Note that, in order to receive perimeter events, the zymkey must have been configured to notify the host on either or both of the perimeter detect channels via a call to “zkSetPerimeterEventAction”.\nParameters timeout_ms — (input) The maximum amount of time in milliseconds to wait for a perimeter event to arrive.\nExceptions zkAppUtilsException upon error void getPerimeterDetectInfo ( uint32_t ** timestamp_sec, int \u0026 num_timestamps) Get current perimeter detect info.\nThis function gets the timestamp of the first perimeter detect event for the given channel.\nParameters timestamps_sec — (output) The timestamps for when any events occurred. The index in this array corresponds to the channel number used by zkSetPerimeterEventAction. A 0 value means no breach has occurred on this channel. This array is allocated by this routine and so it must be freed by the caller.\nnum_timestamps — (output) The number of timestamps in the returned array.\nExceptions zkAppUtilsException upon error void clearPerimeterDetectEvents () Clear perimeter detect info.\nThis function clears all perimeter detect info and rearms all perimeter detect channels.\nExceptions zkAppUtilsException upon error std::string * getModelNumberString () Get Zymkey model number.\nThis function retrieves the model number of the zymkey referred to in a specified context.\nExceptions zkAppUtilsException upon error Returns A pointer to a string containing the Zymkey model number.\nstd::string * getFirmwareVersionString () Get Zymkey firmware version.\nThis function retrieves the firmware version of the zymkey referred to in a specified context.\nExceptions zkAppUtilsException upon error Returns A pointer to a string containing the Zymkey firmware version.\nstd::string * getSerialNumberString () Get Zymkey serial number.\nThis function retrieves the serial number of the zymkey referred to in a specified context.\nExceptions zkAppUtilsException upon error Returns A pointer to a string containing the Zymkey serial number.\nModule Info float getCPUTemp () Get the CPU Temp. (Supported Devices: HSM6, Secure Compute Module).\nThis function gets the current HSM CPU temp.\nExceptions zkAppUtilsException upon error Returns The CPU temp as a float.\nfloat getAUXTemp ( int index = 0) Get the AUX Temp. (Secure Compute Modules Only).\nThis function gets the current temp of an aux processor. (defaults to 0). THIS FUNCTION IS FOR INTERNAL ZYMBIT USE ONLY.\nExceptions zkAppUtilsException upon error Returns The CPU temp as a float.\nfloat getRTCDrift () Get the RTC drift. (Supported Devices: HSM6, Secure Compute Module).\nThis function gets the current RTC drift.\nExceptions zkAppUtilsException upon error Returns The RTC drift as a float.\nfloat getBatteryVoltage () Get the battery voltage(Supported Devices: HSM6, Secure Compute Module).\nThis function gets the current battery voltage.\nExceptions zkAppUtilsException upon error Returns the battery voltage as a float.\nBattery Voltage Monitor void setBatteryVoltageAction ( ZK_THRESHOLD_ACTION_TYPE action) Set battery voltage threshold action. (Supported Devices: HSM6, Secure Compute Module).\nThis function specifies the action to take when the battery voltage falls below the threshold set by zkSetBatteryVoltageThreshold. If this function is never called, do nothing is default. There are three actions:\nDo nothing. Go to sleep until battery is replaced. Self-destruct. Parameters action — (input) The action to apply, specify one of the ZK_THRESHOLD_ACTION_TYPE:\nDo nothing (ZK_ACTION_NONE). Sleep (ZK_ACTION_SLEEP). Self-destruct (ZK_ACTION_SELF_DESTRUCT). Exceptions zkAppUtilsException upon error void setBatteryVoltageThreshold ( float threshold) Sets the battery voltage threshold. (Supported Devices: HSM6, Secure Compute Module).\nThis function sets the threshold at which if the battery voltage falls bellow, the action set by zkSetBatteryVoltageAction will be carried out. The recommended threshold is 2.3V is assumed by default. Threshold must be below 2.5V.\nParameters threshold — (input) The threshold in Volts.\nExceptions zkAppUtilsException upon error CPU Temperature Monitor void setCPUTempAction ( ZK_THRESHOLD_ACTION_TYPE action) Set HSM CPU temperature threshold action. (Supported Devices: HSM6, Secure Compute Module).\nThis function specifies the action to take when the HSM CPU temperature falls below the threshold set by zkSetCPULowTempThreshold, or rises above the threshold set by zkSetCPUHighTempThreshold. There are two actions to apply:\nDo nothing. Self-destruct. Parameters action — (input) The action to apply, used it’s named constant from ZK_THRESHOLD_ACTION_TYPE:\nDo nothing (ZK_ACTION_NONE). Self-destruct (ZK_ACTION_SELF_DESTRUCT). Exceptions zkAppUtilsException upon error void setCPULowTempThreshold ( float threshold) Sets the HSM CPU low temperature threshold. (Supported Devices: HSM6, Secure Compute Module).\nThis function sets the threshold at which if the on-board HSM CPU’s tempreature falls below, the action set by zkSetCPUTempAction will be carried out. WARNING: You can lock yourself out in dev mode if you set a threshold above the CPU’s ambient temperature. The recommended setting is no more than 20C. If no threshold is set, -10 degrees Celsius is set as default.\nParameters threshold — (input) The threshold in celsius.\nExceptions zkAppUtilsException upon error void setCPUHighTempThreshold ( float threshold) Sets the HSM CPU high temperature threshold. (Supported Devices: HSM6, Secure Compute Module).\nThis function sets the threshold at which if the on-board HSM CPU’s tempreature rises above, the action set by zkSetCPUTempAction will be carried out. WARNING: You can lock yourself out in dev mode if you set a threshold below the CPU’s ambient temperature. The recommended setting is no less than 40C. If no threshold is set, 65 degrees celsius is set as default.\nParameters threshold — (input) The threshold in celsius.\nReturns 0 for success, less than 0 for failure.\nvoid setSupervisedBootPolicy ( int policy_id) Sets the Supervised boot policy. (Supported Devices: Secure Compute Module).\nThis function specifies the action to take when Supervised boot event triggers based on a file change.\nParameters policy_id — (input) The actions to apply to the Supervised boot process:\n0 Do Nothing (ZK_SUPBOOT_FAIL_NO_ACTION). 1 Self-Destruct (ZK_SUPBOOT_FAIL_DESTROY). 2 Hold Chip in Reset (ZK_SUPBOOT_FAIL_HOLD_RESET). Returns 0 for success, less than 0 for failure.\nvoid addOrUpdateSupervisedBootFile ( std::string file_path, int slot = 15) Update file manifest for Supervised boot to check. (Supported Devices: Secure Compute Module).\nThis function adds or updates files to be checked by Supervised boot.\nParameters file_path — (input) The file to be signed and checked by Supervised boot.\nslot — (input) The slot to sign the file with. Defaults to 15, if no slot 15, defaults to 0.\nReturns 0 for success, less than 0 for failure.\nvoid removeSupervisedBootFile ( std::string file_path) Remove a file from file manifest for Supervised boot to check. (Supported Devices: Secure Compute Module).\nThis function removes a file to be checked by Supervised boot.\nParameters file_path — (input) The file to be removed from the Supervised boot manifest.\nReturns 0 for success, less than 0 for failure.\nstd::string * getSupervisedBootFileManifest () Get file manifest for Supervised boot to check. (Supported Devices: Secure Compute Module).\nThis function gets the list of files to be checked by Supervised boot.\nParameters manifest — (output) The file manifest that is checked by Supervised boot.\nReturns a string for the list of files in the manifest.\nPrivate Members zkCTX zkContext ","categories":"","description":"C++ interface to Zymkey Application Utilities Library.","excerpt":"C++ interface to Zymkey Application Utilities Library.","ref":"/api/cpp_api/","tags":"","title":"C++ API Documentation"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/","tags":"","title":"Categories"},{"body":"OVERVIEW ZYMKEY and HSM security modules feature two independent perimeter circuits that can be configured to detect physical tamper intrusion events.\nElectrical Requirements Each perimeter loop should be connected with a 30 AWG wire or thicker and nominal length of 2 feet. For longer lengths contact Zymbit. The wire should be electrically insulated for all applications. A shielded cable may be necessary for electrically noisy or industrial applications.\nPhysical Circuit Connections How these circuits are configured physically will vary depending upon the specific application, enclosure and security needs. Standard wires, custom flex PCBs and rigid PCBs may all be used to complete a perimeter loop circuit.\nHere we share some practical examples of how to configure perimeter detect circuits for different applications and equipment.\nTo learn about software configuration and use of perimeter detect functions Learn more\u003e\nCONFIGURATION EXAMPLES Direct Connect to HSM4 Hat HSM4 HAT provides four pin header and FPC connectors to interface to perimeter circuits 1 and 2. This is convenient for rapid prototyping and small scale production situations. For high volume applications, different connector types are available - contact zymbit for more details.\nPerimeter HDR (Header) Pinout Perimeter FPC (Flexible Printed Circuit) Pinout HSM Direct Connector - Hirose Header DF40HC(3.5)-30DS-0.4V(51) Direct Cable Connect to Zymkey 4i Perimeter circuits on Zymbit 4i are accessed from a standard microUSB connector.\nUse a standard microUSB extension cable to close circuits P1 and P2 as follows.\nAdapter Connect to Zymkey 4i Several adapters are available from Zymbit that simplify connection from the microUSB to header and FPC. These are convenient for development. Buy Adapters \u003e\nFlexible Security Shield Wrapping RPi4 HSM4 Security Module, fitted to PiHat1. Flex circuit connects to FPC connector on HAT\nRigid Security Shield installed on ProtoKit4 A printed circuit shield is fitted into the lid of the ProtoKit 4 and pogo pins connect the top mesh to the the bottom board. When the lid is closed, the circuit is closed.\nThe shield connects the following four perimeter signals available on the protoboard:\nPERIM_1B PERIM_2B PERIM_2A PERIM_1A FlexCable Wrap with PiZero Hat SDCard Blocking Perimeter Adapter with PiZero Hat Tamper Switches \u0026 FlexCable with Secure Compute Device Zymbit secure compute motherboard for RPi\nInternal Tamper Switches\nSecure Compute Device in 2U Rack with External Tamper Switches ","categories":"","description":"","excerpt":"OVERVIEW ZYMKEY and HSM security modules feature two independent …","ref":"/tutorials/perimeter-detect/examples/","tags":"","title":"Perimeter Detect Circuit Examples"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tutorials/digital-wallet/","tags":"","title":"Zymbit Embedded Hardware Wallet"},{"body":"\nPrerequisites Raspberry Pi:\nRaspberry PI OS: Bookworm (64 bit) Raspberry PI OS: Bullseye (32 or 64 bit) Raspberry PI OS: Buster (32 or 64 bit) Ubuntu 22.04 LTS (32 or 64 bit) Ubuntu 20.04 LTS (32 or 64 bit) Ubuntu 18.04 LTS (32 or 64 bit) BACKGROUND To skip the background information and start encrypting your RFS, click here.\nWHY ENCRYPT? There are many reasons to encrypt the Root File System (RFS), from keeping WiFi credentials immutable to keeping proprietary software and sensitive data from being cloned.\nFor most Raspberry Pi configurations, only two partitions exist:\n/boot on /dev/mmcblk0p1 / on /dev/mmcblk0p2 INTRODUCING LUKS LUKS (Linux Unified Key Setup) is the popular key management setup for dm-crypt, the de-facto standard for block device encryption with Linux.\nLUKS provides a robust and flexible mechanism for multiple users (and services) to interface to and access Linux’s ‘dm-crypt’ infrastructure.\ndm-crypt is a transparent disk encryption subsystem in Linux kernel versions 2.6 and later and is part of the device mapper infrastructure, and uses cryptographic routines from the kernel’s Crypto API. Both are widely used and understood in the IT community.\nWeaknesses of single Master key dm-crypt has a single Master Key that is used to encrypt / decrypt data in/out of the block. To ensure long term security and deal with changing authorized users/services, it would be necessary to change the Master Key frequently, and potentially share it with multiple users/services on a regular basis. Every new iteration of Master Key would require the underlying data block to be re-encrypted everytime. In real systems, touched by different users/services, this is impractical.\nHierarchical key management A more practical solution is to have a hierarchical key management setup in which users/services are given User Keys that are used to release the MasterKey. User Keys can be easily changed and revoked, without having to re-encrypt the underlying data block. The management of such a hirearchical key managers is the role of LUKS.\nIn this post we show how to use Zymbit Security Module to lock a User Key, that is subsequently used to unlock the Master Key and provide access to the Root File System. If you’d like to learn more about LUKS see the References at the bottom of this post.\nSECURE STORAGE OF LUKS USER KEYS The security efficacy of your LUKS encrypted RFS is highly dependent upon how the User Keys are generated and where they are stored.\nThe SD Card is NOT a secure storage location The growing single board computer family is awesome, and we love it! It is inexpensive, has an incredible amount of computing power for an embedded device and has a very robust software development ecosystem.\nHowever, these devices have an Achilles heel: the SD card is the primary software deployment media, and it can be very easily removed and manipulated.\nThe natural inclination would be to encrypt the file system using LUKS on dm-crypt, but for unattended use across many deployed units the obvious question is: where is the LUKS key stored? Of course, it’s the file system. Even if you try to obfuscate it through various programmatic means, the key is still very vulnerable to attack.\nSecuring LUKS User Key with Zymbit Security Module. The Zymbit Security Module provides a general “locking” service whereby a block of plaintext data is encrypted and signed.\nWhen used with LUKS, the User Key is sent to the Zymbit Security Module to be locked (encrypted and signed) when the file system is created. When the system boots and needs to decrypt the root file system, the locked LUKS key is “unlocked” (signature verified and contents decrypted) and presented to dm-crypt. If the key was unlocked successfully, the boot process continues normally. Here is the boot sequence with a LUKS/dm-crypt filesystem where the key is protected by Zymbit Security Module:\nThe kernel initializes initramfs initramfs presents the locked LUKS key to Zymbit Security Module Zymbit Security Module validates the signature and decrypts the key* The decrypted key is presented to LUKS and the root file system is then decrypted *requires that Zymbit Security Module operational status is “secure”\nZYMKEY4 fitted to Raspberry Pi\nZymbit Security Module Authenticates Host System Before Unlocking LUKS Key\nOne of the key features of Zymbit Security Module is to generate a unique Identity (ID) for the host system, based upon a fingerprint that measures specific system components. This fingerprinting process is used to “bind” together a specific Zymbit Security Module (root of trust, key store, crypto services), a specific host computer and a specific SD card. Once bound, these components form a permanent and immutable ID of the host system.\nEach time the host device boots, and at random intervals thereafter, the Zymbit Security Module rechecks the ID fingerprint. If any of the system components have changed the fingerprint changes and the system is deemed to have been compromised, authentication fails and all security services are shut down.\nUsing this ID / Authentication feature, the Zymbit Security Module can be used to protect LUKS User Keys in unattended applications, where it might be easy to remove and copy SD card content. (The Zymbit Security Module also has other physical security features which are also used to lock/enable security services)\nWHERE TO STORE YOUR LUKS ENCRYPTED RFS LUKS is very versatile and can be applied to both SD Card and external storage media. Lets review the pros and cons of each option:\nWarning When encrypting your rootfs, we highly recommend turning off unattended-upgrades prior to the encryption process. In some cases primarily with Ubuntu, during an update/upgrade after encryption, the update-initramfs process may fail and leave the system unable to boot.\nTo mitigate this issue, remove the service unattended-upgrades:\nsystemctl stop unattended-upgrades\nsystemctl disable unattended-upgrades\napt remove unattended-upgrades -y\nOption 1 - Convert existing SD Card to LUKS Converting the existing root file system on the SD card still requires an external device (e.g. USB flash drive) that is used as a temporary boot root file system: this provide an easier and lower risk means to convert and copy the original contents. The external devices needs to be a little larger than the existing root file system in order to store the old file system.\nPros:\nLess physical space requirements. Much less power required. Cons:\nConversion is more complex and time consuming than migrating to an external drive. Data space constraints. Write cycle constraints. Access speed constraints. Process Steps Run By Script:\nMake a tarball of the original root file system and store it on the external device Copy the original root file system files to the external device to form a temporary file system Boot to the temporary file system. Once booted, the temporary file system will: Create a LUKS key Lock the LUKS key with Zymbit Security Module Create a LUKS volume on the original root partition. Create an ext4 partition on the LUKS volume on the original root partition Untar the root file system tarball into the converted partition Option 2 - Migrate existing SD card to external LUKS storage device. The existing root file system can be migrated to an external LUKS encrypted USB flash, hard drive or SSD.\nPros:\nExternal devices can hold much more data. Migration is easier and quicker than SD card conversion method. Some external devices have much faster data access than SD cards. Some external devices (e.g. HDD) can tolerate many more write cycles than an SD card. Cons:\nFor HDD and SSD and non-compact USB flash devices, there are additional power requirements. Except for compact USB flash devices, physical space requirements also increase. This may be especially important for the Raspberry Pi Zero family. Process Steps Run By Script:\nCreate the LUKS key Lock the LUKS key Create a LUKS volume on an external USB device Create an ext4 partition on the LUKS volume Move the existing root file system to the LUKS volume on the external device Boot to the new root file system and erase the previous root volume HOW TO ENCRYPT BUILDING YOUR LUKS ENCRYPTED RFS Prerequisites Make sure you have the Zymbit Security Module software suite already running and operational as well as bound. Instructions here.\nOption 1 - Convert existing SD Card to LUKS To convert your root file system to LUKS/dm-crypt, you will need to connect an external USB disk (as temporary storage). As mentioned previously, this is necessary because it is not possible to encrypt the partition in place, so the external disk is needed as temporary storage and a temporary root file system while the conversion takes place. The external disk needs to be at least twice as big as the root partition. Next, run the following script:\ncurl -G https://s3.amazonaws.com/zk-sw-repo/mk_encr_sd_rfs.sh | sudo bash\nFor RPi users: This script is parameterized, so if you have special requirements (e.g. root file system lives on /dev/mmcblk0p4), you can invoke it in the following fashion:\ncurl -G https://s3.amazonaws.com/zk-sw-repo/mk_encr_sd_rfs.sh | sudo bash -s -- -x \u003cpath to external storage device (e.g. /dev/sdX\u003e -m \u003csource partition number\u003e\nIn the above invocation with no parameters, the defaults are:\nOriginal root file system located on /dev/mmcblk0p2 Temporary root file system/storage for original root tarball located on /dev/sda Temporary root file system takes up entirety of new device The very first run of this script on a new temporary external USB disk could take a long time. Also, two reboots are required before the script is complete.\nOne thing to note is that, if the external storage device has an ext4 formatted partition with the original root file system partition (e.g. /dev/mmcblk0p2) on it, this script will use what is already on the external storage device to convert the SD card. This cuts down time for converting lots of device root file systems and allows the script to be used in a mass production deployment.\nOn a Pi4 with an attached USB SSD as the external device on a bare Bullseye “full” version, the first run of this script requires 30 minutes or so to complete the first phase. The second phase takes around 10 minutes.\nBased on the above, using the formatted external device to convert subsequent units should only take around 10 minutes.\nOption 2 - Migrate existing SD card to external LUKS storage device. To migrate your root file system to an external USB device, you can run the following script:\ncurl -G https://s3.amazonaws.com/zk-sw-repo/mk_encr_ext_rfs.sh | sudo bash\nThis script is parameterized, so if you have special requirements, you can invoke in the following fashion:\ncurl -G https://s3.amazonaws.com/zk-sw-repo/mk_encr_ext_rfs.sh | sudo bash -s -- -x \u003cpath to external storage device (e.g. /dev/sdX\u003e -p \u003cdestination partition number -s \u003cmax size of new root partition\u003e -m \u003csource partition number\u003e\nIn the above invocation with no parameters, the defaults for RPi are:\nOriginal root file system located on /dev/mmcblk0p2 New root file system located on /dev/sda1 New root file system takes up entirety of new device Please note that the new root file system should be at least a little larger in size than the original root partition\nRunning this script takes around 30-40 minutes. The Zymbit Security Module’s LED flashes rapidly until the process has completed.\nINTEGRATING LUKS INTO VOLUME MANUFACTURING WORKFLOW The examples above are designed to help you get up and running with single and low volume applications.\nIf you require support in developing a high volume manufacturing encryption workflow then please contact us to discuss our OEM engineering services.\nREFERENCES LUKS features - the de-facto standard in Linux Kernel.\nWiki overview to dm-crypt\nArchLinux - adding LUKS keys to dm-crypt device encryption\nGitLab - LUKS and Cryptsetup - FAQ\nGitLab - LUKS and Cryptsetup - open-source disk encryption\nTroubleshooting Troubleshooting\nCommunity\n","categories":"","description":"","excerpt":"\nPrerequisites Raspberry Pi:\nRaspberry PI OS: Bookworm (64 bit) …","ref":"/tutorials/encrypt-rfs/","tags":"","title":"Encrypting Root File System with Zymbit Security Modules"},{"body":"Why do this? If you are just getting started with HSM you may want to start by encrypting some data to disk. This would be useful if you are collecting data to be read/analyzed at later time; and you do not want to store your data ‘in the clear’.\nEncrypting data on disk prevents a bad actor from imaging your SD card and gaining access to sensitive data that is being stored in the field. If bad actor were to successfully image the card, data would remain encrypted and locked with your HSM’s private key. If the HSM was also removed, then the bad actor would still not be able to access the data because each specific HSM is bound to a specific host hardware. Moving a specific HSM to another host hardware would fail the binding process and HSM would not perform any crypto functions, including decryption of data blobs.\nEncrypting Data Blobs The process we describe here can also be used more generally to encrypt binary large objects, or ‘data blobs’\nWhat you will need If you have not already setup and bound your HSM please visit the Getting Started page.\nWe will use temperature data from a DS18B20 OneWire probe. We will encrypt the data to disk using the HSM python package, and then decrypt in a different session. For the purpose of this tutorial I will not be going over the circuit setup and one-wire configuration. That is adequately covered here. If you have questions however, we are happy to help!\nThe process is very simple:\nCollect Measurements Encrypt data with HSM Safely store data locally Decrypt at a later time with HSM. Locking Data Below is a sample script you can use to encrypt sensor data. Most of the code is for data acquisition, not encryption. For the most part, we are only interested in the lines toward the bottom using zymkey.client .\nimport base64 import time import zymkey import datetime import logging import argparse import subprocess as sub class TempRead(object): def __init__(self): self.base_dir = '/sys/bus/w1/devices/' def probe_scan(self): devices_raw = sub.check_output(['ls', self.base_dir]) devices = [] for i in range(0, len(devices_raw)-3): if devices_raw[i:i+3] == '28-': devices.append(devices_raw[i:i+15]) return devices def read_temp_raw(self, probe): f = open(self.base_dir+probe+'/w1_slave', 'r') lines = f.readlines() f.close() return lines def read_temp(self, probe): lines = self.read_temp_raw(probe) while lines[0].strip()[-3:] != 'YES': time.sleep(0.2) lines = self.read_temp_raw(probe) equals_pos = lines[1].find('t=') if equals_pos != -1: temp_string = lines[1][equals_pos+2:] c = round(float(temp_string) / 1000, 1) f = round(float(c * 9 / 5 + 32), 1) return c, f if __name__ == '__main__': parser = argparse.ArgumentParser() parser.add_argument('--loglevel', '-l', default='debug') parser.add_argument('--file_out', '-fo', type=str, default='/tmp/encrypted.bin') parser.add_argument('--zymkey', action='store_true', default=False) parser.add_argument('--sleep', type=float, default=20) parser.set_defaults() args = parser.parse_args() logging.basicConfig( format=\"%(levelname)s:%(name)s:%(lineno)s:%(message)s\", level=getattr(logging, args.loglevel.upper()) ) # streams to sys.stderr by default temp = TempRead() probes = temp.probe_scan() encrypted_file = open(args.file_out, mode='wb') while True: for probe in probes: temp_c, temp_f = temp.read_temp(probe) payload = \"action=data, \" \\ \"key=temperature, \" \\ \"tags.unit=c, \" \\ \"tags.sensor_id={},\" \\ \"timestamp={}, \" \\ \"value= {}\".format(str(\"ds18b20:\"+probe.replace(\"-\", \"\")), datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S'), temp_c) logging.debug('Unencrypted Payload: {}'.format(payload)) if args.zymkey: logging.info('Encrypting data...') locked_data = zymkey.client.lock(bytearray(payload)) encrypted_file.write(base64.b64encode(locked_data)+'\\n') logging.debug('Encrypted DATA: {}'.format(locked_data)) time.sleep(args.sleep) The takeaways here are the zymbit.client.lock method and the flow of data types. Specifically, we want to lock a measurement of type float , the zymkey app utils library expects a bytearray , and the data needs to be base64.encode d so the blob can be written to a file on disk. This may sound like a lot but it can all be contained in two simple lines of code:\nlocked_data = zymkey.client.lock(bytearray(payload)) encrypted_file.write(base64.b64encode(locked_data)+'\\n') See! HSM is super easy to use!\nTo see this in action copy this to your pi, save it as sensor_lock.py for consistency, and run the command:\npython sensor_lock.py --zymkey --sleep=5 You should see encrypted data flowing and the new file /tmp/encrypted.bin , where your data is saved on disk.\nUnlocking Data With the data we locked to disk above, lets unlock the data now so it is human and machine readable. A simple script such as the one pasted below will read the encrypted file, decode with base64, unlock with HSM and write to a decrypted.txt file so data is legible.\nimport base64 import logging import zymkey import argparse parser = argparse.ArgumentParser() parser.add_argument('--loglevel', '-l', default='debug') parser.add_argument('--file_in', '-fi', type=str, default='/tmp/encrypted.bin') parser.add_argument('--file_out', '-fo', type=str, default='/tmp/decrypted.txt') parser.set_defaults() args = parser.parse_args() logging.basicConfig( format=\"%(levelname)s:%(name)s:%(lineno)s:%(message)s\", level=getattr(logging, args.loglevel.upper()) ) # streams to sys.stderr by default with open(args.file_in) as f: logging.debug(\"Reading encrypted data from {}\".format(args.file_in)) content = f.readlines() decrypted_file = open(args.file_out, mode='w+') for i in content: payload = zymkey.client.unlock(bytearray(base64.b64decode(i))) logging.info(str(payload)) logging.debug(\"Writing decrypted sensor data {} to {}\".format(payload, args.file_out)) decrypted_file.write(str(payload) + '\\n') decrypted_file.close() Copy this to your Raspberry Pi, save as sensor_unlock.py and run as is with:\npython sensor_unlock.py Your data will be unlocked and saved to disk at /tmp/decrypted.txt . It should look something like this:\naction=data, key=temperature, tags.unit=c, tags.sensor_id=ds18b20:28000006151b77,timestamp=2016-12-13 22:55:02, value= 19.5 action=data, key=temperature, tags.unit=c, tags.sensor_id=ds18b20:280000061543fd,timestamp=2016-12-13 22:55:03, value= 19.6 action=data, key=temperature, tags.unit=c, tags.sensor_id=ds18b20:28000006156310,timestamp=2016-12-13 22:55:04, value= 19.3 action=data, key=temperature, tags.unit=c, tags.sensor_id=ds18b20:28000006e10735, Troubleshooting Troubleshooting Community\n","categories":"","description":"","excerpt":"Why do this? If you are just getting started with HSM you may want to …","ref":"/tutorials/sensor-data/","tags":"","title":"Encrypting \u0026 Decrypting Sensor Data on Disk"},{"body":"Secure Edge Node (SEN) Getting Started Guide for AWS IoT Greengrass Devices\nSecure Compute Module (SCM) Dev Kit Getting Started Guide for AWS IoT Greengrass Devices\nSecure Compute Module (SCM) Getting Started Guide for AWS IoT Greengrass Devices\nZYMKEY4 Getting Started Guide for AWS IoT Greengrass Devices\n","categories":"","description":"","excerpt":"Secure Edge Node (SEN) Getting Started Guide for AWS IoT Greengrass …","ref":"/tutorials/aws-iot/greengrass/","tags":"","title":"Getting Started with AWS IoT Greengrass"},{"body":"The AWS Credentials provider can give a remote device AWS credentials if it has a valid certificate. The device certificate is stored inside AWS IoT’s service and can be revoked, deactivated or deleted at any time. AWS IoT can also record and index individual IoT Things within a fleet. Each IoT thing will have its own unique certificate verified by AWS, and can be given unique attributes to identify each device along with policies which control the approved actions of each device.\nUsing AWS IoT also allows device data to be used by other AWS cloud services. Once the device is given credentials, other AWS services can be configured to receive data from the device.\nThe IoT device’s AWS credentials are only valid for a period of time. If the credentials expire, when the AWS CLI tries to connect to AWS servers, it will run an installed script to get new credentials.\nDevice Setup There are four devices in the provisioning process:\nThe Provisioning Device with AWS CLI installed (usually your PC) The Certificate Authority The AWS Credentials Provider The IoT Device(s) getting their credentials (with Zymbit security module(s) installed) If wanted, the CA and provisioning device can be on the same device.\nSetup the Provisioning Device The provisioning device can be any device with AWS CLI installed, but we recommend it not be an IoT device you deploy because the provisioning device will have more AWS permissions.\nInstall AWS CLI. Instructions here: https://aws.amazon.com/cli/ Specify user for AWS CLI Go to AWS IAM console, click users, add user, input a user name, and check programatic access. Click Next:Permissions, “Attach existing policies directly”, click AdministratorAccess Click Next:Tags, Next:Review, Create user. Stay on this page. On the provisioning device, run aws configure and fill in the appropriate values from the AWS page. For Default output format put json. Run git clone https://github.com/zymbit-applications/aws-credentials-provider.git Run sudo mkdir /opt/zymbit Setup the Certificate Authority The Certificate Authority can be a private CA you own or you can use AWS’s CA service. If you want to create a CA on your own device, follow these instructions.\nCreate a private CA On the device you want to hold your private CA and sign certificate requests, do the following.\nRun git clone https://github.com/zymbit-applications/aws-credentials-provider.git Run cd aws-credentials-provider Run the mk_ca script: mk_ca.sh There are now three files in the directory (~/aws-credentials-provider/CA_files).\nzk_ca.key The private key for the CA, used for signing CSR’s zk_ca.pem The certificate for the CA in PEM format zk_ca.crt The certificate for the CA If you have your own private CA, then you need to register it with AWS.\nRegister certificate authority with AWS Steps 1 and 6 are done on the provisioning device. Steps 2-5 must be done on the private CA.\nCopy the registration code for generating CA cert. aws iot get-registration-code Create a private key for AWS CA to verify against. openssl genrsa -out verificationCert.key 2048 Create a CSR for your CA to sign openssl req -new -key verificationCert.key -out verificationCert.csr Put registration code in the Common Name field Country Name (2 letter code) [AU]: State or Province Name (full name) [Some-State]: Locality Name (eg, city) []: Organization Name (eg, company) [Internet Widgits Pty Ltd]: Organizational Unit Name (eg, section) []: Common Name (e.g. server FQDN or YOUR name) []: 9c9df696a8a09688d040b4b719129e4d6dbd6a898eeb0c654af0a5753b41 Email Address []: Please enter the following 'extra' attributes to be sent with your certificate request A challenge password []: An optional company name []: Create a private key verification certificate for your CA. If you didn’t follow our CA creation section, then the -CA and -CAkey file paths are likely different. openssl x509 -req -in verificationCert.csr -CA CA_files/zk_ca.pem \\ -CAkey CA_files/zk_ca.key -CAcreateserial -out verificationCert.crt \\ -days 500 -sha256 Register CA certificate, set it as active and allow device certificates to auto register. aws iot register-ca-certificate --ca-certificate file://CA_files/zk_ca.crt \\ --verification-certificate file://verificationCert.crt \\ --set-as-active \\ --allow-auto-registration Setup AWS Credentials Provider All of these steps happen on the provisioning device\nCreate an IAM role for credentials provider aws iam create-role --role-name credential_helper --assume-role-policy-document file://aws-credentials-provider/role-trust-policy.json Create a role alias linked to role aws iot create-role-alias --role-alias deviceRoleAlias --role-arn \u003croleARN\u003e The roleARN is in the output of step 1, but you can run aws iam get-role --role-name credential_helper to find it again. If this fails, the user you currently are may not have GetRole and PassRole permissions. The tab below gives instructions to add these permissions. Add Permissions Go to AWS IAM console Select Users Select the user you currently are on your provisioning device Click the permissions tab Click Add permissions Click “Attach existing policies directly” Click Create Policy Click the JSON tab Copy the user-pass-permissions.json file into the editor Replace ACCOUNT_ID with your provisioning device user You can find this by running aws sts get-caller-identity on your provisioning device. Replace ROLE_NAME with name given in the step above (e.g. credential_helper) Click Next:Tags Click Next:Review Name the policy Click create. Create an IoT policy which allows role alias to be assumed with a certificate In ~/aws-credentials-provider/iot-role-policy.json substitute: REGION with the desired region ACCOUNT_ID with the “Account” number found by running aws sts get-caller-identity ALIAS with the name of the role alias created in step 2 Then run aws iot create-policy --policy-name credentialHelper --policy-document file://aws-credentials-provider/iot-role-policy.json Setup the IoT device getting credentials Run git clone https://github.com/zymbit-applications/aws-credentials-provider.git Run sudo mkdir /opt/zymbit Run sudo cp ~/aws-credentials-provider/credentials.sh /opt/zymbit/ \u0026\u0026 sudo chmod +x /opt/zymbit/credentials.sh Edit ~/aws-credentials-provider/config to specify the appropriate region. Run mkdir ~/.aws \u0026\u0026 cp ~/aws-credentials-provider/config ~/.aws/config Provisioning an IoT Device Notice The following procedure was done with Raspberry PI OS Buster 32bit. The current version of cURL included in bullseye (7.74.0) seems to have an issue using the openssl engine import feature. On the IoT device Run openssl req -key nonzymkey.key -new -out zymkey.csr -engine zymkey_ssl -keyform e Fill in the request with the specified values The IoT Policy name, we used credentialHelper. The desired AWS Region. Credential Provider URL. To find this, on the provisioning device run aws iot describe-endpoint --endpoint-type iot:CredentialProvider Copy the cxxxxxxxxxxxxx part. Role Alias name, we used deviceRoleAlias. The Thing name, whatever you want to name this IoT device. Country Name (2 letter code) [AU]: State or Province Name (full name) [Some-State]: \u003cIOT-POLICY\u003e Locality Name (eg, city) []: \u003cREGION\u003e Organization Name (eg, company) [Internet Widgits Pty Ltd]: \u003cCREDENTIAL-URL\u003e Organizational Unit Name (eg, section) []: \u003cROLE-ALIAS\u003e Common Name (e.g. server FQDN or YOUR name) []: \u003cTHING-NAME\u003e Email Address []: Please enter the following 'extra' attributes to be sent with your certificate request A challenge password []: An optional company name []: Copy zymkey.csr from the IoT device to CA device. If using our CA tutorial, put csr in the aws-credentials-provider directory (~/aws-credentials-provider) On the CA device, sign the CSR. If using our CA tutorial, in ~/aws-credentials-provider, run bash sign_csr.sh zymkey.csr device.crt. The first argument is the path to your CSR and the second argument the name you wish to give the signed device Certificate file. Copy the device cert (device.crt) and root ca key from the CA device to the provisioning device. If following our CA tutorial, the root ca key is CA_files/zk_ca.pem. On the provisioning device, run: sudo cp device.crt /opt/zymbit/ \u0026\u0026 sudo cp root.ca.pem /opt/zymbit/ cd ~/aws-credentials-provider; bash provision-device.sh The script will ask you a few questions, make sure everything is correct. The script behind the scenes will: Register device cert in AWS with root CA cert Create a IoT Thing in AWS Attach thing to device cert Attach IoT policy to device cert Once the script is done, transfer device.crt and root.ca.pem from the provisioning device to the IoT device. On the IoT device, run: sudo mv device.crt /opt/zymbit/ \u0026\u0026 sudo mv root.ca.pem /opt/zymbit/ /opt/zymbit/credentials.sh to test the TLS connection. If the resulting output contains values for AccessKey, SecretAccessKey, etc, then your device has AWS credentials! To use Zymbit credentials with AWS CLI, set the profile flag to zymkey like so; aws --profile zymkey iot describe-endpoint ","categories":"","description":"","excerpt":"The AWS Credentials provider can give a remote device AWS credentials …","ref":"/tutorials/aws-iot/integrate/","tags":"","title":"How to Integrate Zymbit with AWS Credentials Provider"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tutorials/aws-iot/","tags":"","title":"AWS IoT Integrations \u0026 Client Certificates"},{"body":"How to automatically generate a client certificate, register your own CA, and authenticate a device to establish a TLS connection to AWS IoT Overview AWS IoT requires an IoT device to register and activate a certificate with AWS before communicating. For large scale deployments, AWS provides an automated process called Just-In-Time-Registration. This allows a user to register a Certificate Authority with AWS so that upon a device’s first TLS connection to AWS servers, if the device certificate was signed by this Certificate Authority, the certificate will be quickly activated by a lambda-function and be ready to use.\nPrerequisites: Follow the Getting Started guide first. Programmatic Setup If you would like to use scripts to register your CA and Lambda function, there are a couple more things to set up. We recommend following the manual approach if your only doing this once or twice.\nDetails Follow these instructions to set up the boto3 module for Python:\nThe boto3 module authenticates with AWS based on a IAM Access ID and Secret Key. The boto3 tutorial will ask you to setup an IAM user, here are some instructions on how to do so:\nFrom the AWS console, choose the IAM service. Go to Users and select Add User Choose a username and check the Programmatic access box For simplicity, choose Attach existing policies directly and select AdministratorAccess If you wish to better manage your IAM credentials, feel free to customize your Access Policy. Click Review and then Create User Save the Access ID and Secret Key and follow the boto3 guide. Register Certificate Authority with AWS The following section will show how to generate your own CA using OpenSSL and register it with your AWS account.\nDetails Create CA Copy the lines below into a script called mk_ca.sh.\n#!/bin/bash set -e mkdir CA_files cd CA_files openssl ecparam -genkey -name prime256v1 -out zk_ca.key OPENSSL_CONF=/etc/ssl/openssl.cnf openssl req \\ -x509 -new -SHA256 -nodes -key zk_ca.key \\ -days 3650 -out zk_ca.crt \\ -subj \"/C=US/ST=California/L=Santa Barbara/O=Zymkey/CN=zymkey-verify.zymbit.com.dev\" cp zk_ca.crt zk_ca.pem You can then run the script in the command line by being in the same directory with the following command:\nbash mk_ca.sh The script will create a directory called CA_files and a couple of files: zk_ca.key: Private key for the created CA, will be supplied to OpenSSL for signing CSRs. zk_ca.pem: PEM formatted certificate for the CA zk_ca.crt: Same file as zk_ca.pem\nRegister CA with AWS Manually:\nFrom the AWS IoT console select Secure then CA and then click Register\nClick register CA\nFollow the directions on the following screen to create a verification certificate.\nWhen signing the verification certificate with your CA in Step 4 run the following command:\nopenssl x509 -req -in verificationCert.csr -CA CA_files/zk_ca.pem -CAkey CA_files/zk_ca.key -CAcreateserial -out verificationCert.crt -days 500 -sha256 Note that if you a different CA and not the demo one we generated, to change the -CA and -CAkey paths appropriately.\nClick Select CA certificate and point to the correct .pem file. If you use the OpenSSL generated SSL point to CA_files/zk_ca.pem\nClick Select verification certificate and point to verificationCert.crt which was created in Step 4.\nSelect Active CA certificate and Enable auto-registration of device certificates\nProgramatically: The following python script will automatically create a verification cert with a registration code and automatically active your Certificate Authority. While it may look a bit intimidating, all you have to worry about is the very last line, where you can change to point to your CA files.\nimport OpenSSL import boto3 import os def gen_AWS_verification_csr(registrationCode): key = OpenSSL.crypto.PKey() key.generate_key(OpenSSL.crypto.TYPE_RSA, 2048) req = OpenSSL.crypto.X509Req() req.get_subject().CN = registrationCode req.set_pubkey(key) req.sign(key, \"sha256\") return OpenSSL.crypto.dump_certificate_request(OpenSSL.crypto.FILETYPE_PEM, req) def sign_CSR_with_CA(verification_csr, CA_cert_path, CA_key_path): ca_cert = OpenSSL.crypto.load_certificate(OpenSSL.crypto.FILETYPE_PEM, open(CA_cert_path).read()) ca_key = OpenSSL.crypto.load_privatekey(OpenSSL.crypto.FILETYPE_PEM, open(CA_key_path).read()) req = OpenSSL.crypto.load_certificate_request(OpenSSL.crypto.FILETYPE_PEM, verification_csr) cert = OpenSSL.crypto.X509() cert.set_subject(req.get_subject()) cert.set_serial_number(1) cert.gmtime_adj_notBefore(0) cert.gmtime_adj_notAfter(24 * 60 * 60) cert.set_issuer(ca_cert.get_subject()) cert.set_pubkey(req.get_pubkey()) cert.sign(ca_key, \"sha256\") return OpenSSL.crypto.dump_certificate(OpenSSL.crypto.FILETYPE_PEM, cert) def register_CA_AWS(CA_cert_path, CA_key_path): client = boto3.client('iot') response = client.get_registration_code() registration_key = response['registrationCode'] verification_pem = gen_AWS_verification_csr(registrationCode=registration_key) verification_cert = sign_CSR_with_CA(verification_csr=verification_pem, CA_cert_path=CA_cert_path, CA_key_path=CA_key_path) response = client.register_ca_certificate( caCertificate=open(CA_cert_path).read(), verificationCertificate=verification_cert, setAsActive=True, allowAutoRegistration=True ) return response register_CA_AWS(CA_cert_path='CA_files/zk_ca.crt', CA_key_path='CA_files/zk_ca.key') Copy the above lines into a file called activate_aws_ca.py and run with the following command:\npython activate_aws_ca.py Generate Zymkey Certificate The first thing we will do is generate a device certificate using Zymkey’s private key. We will watch as this certificate gets activated on your AWS IoT console automatically on first connect. Make sure that you do not already have a Zymkey certificate registered on your AWS IoT console.\nGenerate a Certificate Signing Request with Zymkey’s private key using the following command:\nopenssl req -key nonzymkey.key -new -out zymkey.csr -engine zymkey_ssl -keyform e -subj \"/C=US/ST=California/L=Santa Barbara/O=Zymbit/OU=Zymkey/CN=rpi.edge.zymbit.com\" Note that the -subj line can be omitted or modified with your own information. If it is omitted, you will be prompted to enter your information on the command line.\nSigning the CSR to get a valid Zymkey certificate:\nNext we’ll sign this CSR with your Certificate Authority. Save the following script in a file called sign_csr.sh. Make sure to change the -CA and -CAkey paths to point to the private key and certificate file for your certificate authority:\n#!/bin/bash set -e SCRIPT_NAME=$(basename $0) [ -z $2 ] \u0026\u0026 echo \"${SCRIPT_NAME} \u003ccsr filename\u003e \u003ccrt filename\u003e\" 1\u003e\u00262 \u0026\u0026 exit 1 csr=$1 crt=$2 openssl x509 -req -SHA256 -days 3650 \\ -CA CA_files/zk_ca.crt -CAkey CA_files/zk_ca.key -CAcreateserial \\ -in ${csr} -out ${crt} Now run the script with the following command, where the first argument is the path to your CSR and the second argument the name you wish to give the signed Zymkey Certificate file.\nbash sign_csr.sh zymkey.csr zymkey.crt Creating the Lambda function Now we need to create and register the lambda function that will activate new certificates on your AWS account. This can be done either manually or programatically in Python. We’ll start with the Manual method as it is simpler and more straightforward.\nDetails Manually:\nFrom your AWS console, sign in here, choose the Lambda service. From the Lambda console, click on the orange Create Function button. Click the Author from Scratch button. Choose an appropriate function name and description. We will be using Node.js 12.x for the runtime environment. Click Create function. Copy the default JITR code from AWS located here into index.js under Function code (If pasting doesn’t work in their IDE, try Shift+Insert). Make sure that you change the region defined in the code to the appropriate value. Now scroll to the top and click the Permissions tab. Under Execution role, click Edit. There should be an existing role listed under Existing role. Click the blue title View the role on the IAM console. This should take you to the IAM console. Click Attach policies Click Create policy, then the JSON tab. Input the following policy { \"Version\":\"2012-10-17\", \"Statement\":[ { \"Effect\":\"Allow\", \"Action\":[ \"logs:CreateLogGroup\", \"logs:CreateLogStream\", \"logs:PutLogEvents\" ], \"Resource\":\"arn:aws:logs:*:*:*\" }, { \"Effect\":\"Allow\", \"Action\":[ \"iot:UpdateCertificate\", \"iot:CreatePolicy\", \"iot:AttachPrincipalPolicy\" ], \"Resource\":\"*\" } ] } Click Review policy. Give the policy an appropriate name (maybe JITR) and click Create policy. On the left hand bar, click Roles. Click on your lambda role name. It should start with the function name you defined in step 4, followed by role, then some random characters. Click Attach policies. Click the box next to the policy we just created in step 14. Click Attach policy. Click the X to the right of the old policy titled AWSLambdaBasicExecutionRole, and click Detach. Programatically: The creation of an AWS lambda function through python scripts is a little more intricate than the manual proccess and will need to be divided into numerous parts. The creation of the lambda function will be divided into these steps:\nCreating a new IAM role for the lambda function. Creating a new Policy for this IAM role. Attaching the Policy to the IAM role. Create the lambda function, attaching the IAM role to this function. \u003cdetails=“Details”\u003e\nCreating IAM Role for the Lambda function The first thing we need to do is create an IAM Role. This role gives the Lambda function permission to execute and perform its registration of new certificates.\nCreating this IAM role furthermore requires you to specify 2 things:\nIAM Trust Document: This is a document that details what AWS resources are allowed to assume this IAM role. Below is an example IAM trust document we will use that allows lambda services to assume this JITR role. Save the document in a file called trust_document.txt.\n{ \"Version\": \"2012-10-17\", \"Statement\": [ { \"Effect\": \"Allow\", \"Principal\": { \"Service\": \"lambda.amazonaws.com\" }, \"Action\": \"sts:AssumeRole\" } ] } Role Policy: This is a document describing what actions an IAM role may take. This policy is created and then attached to whatever role you wish. The following policy will allow the JITR role to create AWS logs as well as register/activate new certificates and attach policies to them. Save the document in a file called policy_document.txt.\n{ \"Version\":\"2012-10-17\", \"Statement\":[ { \"Effect\":\"Allow\", \"Action\":[ \"logs:CreateLogGroup\", \"logs:CreateLogStream\", \"logs:PutLogEvents\" ], \"Resource\":\"arn:aws:logs:*:*:*\" }, { \"Effect\":\"Allow\", \"Action\":[ \"iot:UpdateCertificate\", \"iot:CreatePolicy\", \"iot:AttachPrincipalPolicy\" ], \"Resource\":\"*\" } ] } Finally, this is the python code that will take care of the creation of the IAM role. The first thing it does is create an IAM role with the specified Trust settings. Then it creates an IAM policy with the aforementioned policy settings. Finally it will attach the policy to the role. This role will be used by the JITR lambda. By default it’ll read the two documents trust_document.txt and policy_document.txt from the same directory that the code is executed in. So save the python script in a file called create_jitr_lambda.py in the same directory as these files, or modify the path to these files in the code. They can be either relative or absolute\nimport boto3 iam_client = boto3.client('IAM') with open('trust_document.txt') as trust_role: trust_document = trust_role.read() with open('policy_document.txt') as policy: policy_document = policy.read() # Creating the IAM role with the specified Trust create_role_response = iam_client.create_role( RoleName='jitr_role', AssumeRolePolicyDocument=trust_document, Description='AWS Role given to the JITR lambda' ) # Creating the IAM policy with the specified P create_policy_resopnse = iam_client.create_policy( PolicyName=policy_name, PolicyDocument=policy_document, Description'Policy that allows JITR lambda to execute actions.' ) # Attaching the IAM policy to the IAM role attach_response = iam_client.attach_role_policy( RoleName=role_name, PolicyArn=create_policy_response['Policy']['Arn'] ) After saving the code in a file called create_jitr_lambda.py, you can execute by running the following command:\npython create_jitr_lambda.py Creating Lambda function The lambda function will then be created with the following script. The code for the lambda function will be in a zipped file named jitr_lambda.zip. Download the lambda code here and make sure to modify the region-name in the code to your approrpiate region.\nNext, zip up the code in a file called jitr_lambda.zip and keep it in the same directory as the following python script.\n#Download the zip file with the lambda code and save it in the same directory as this script. with open('jitr_lambda.zip', mode='rb') as file: filecontent = file.read() lambda_client = boto3.client('lambda') create_lambda_response = lambda_client.create_function( FunctionName='jitr-lambda', Runtime='nodejs4.3', #By appending this script unto create_jitr_lambda.py you do not need to find the role_ARN, as it will already be stored in this object. Role=attach_response['Arn'] Handler='index.handler\t', Code={ 'ZipFile': filecontent }, Description='Lambda function for Just-in-time-Registration', ) Note that this script requires the Role ARN for the IAM role you just created. If you append this script to the file create_jitr_lambda.py, it will already be included in the response from attaching the policy to the jitr_role, and you won’t have to do anything.\n#Do not copy and run these lines, this is just showing where the role_ARN was taken from attach_response = iam_client.attach_role_policy( RoleName=role_name, PolicyArn=create_policy_response['Policy']['Arn'] ) role_ARN = attach_response['Arn'] Otherwise, if you don’t wish to append the following script to the create_jitr_lambda.py, here is how you can find the appropriate role_arn:\nFrom your AWS Console choose the IAM service. On the left hand bar, click on Roles Select the role titled jitr_role. Copy the section following Role ARN In the following python script, replace: Role=attach_resopnse[‘Arn’] with Role=the_correct_role_arn Save the script in an appropriate location, and run it.\nCreating the AWS IoT Rule Finally we will be setting up an AWS IoT Rule to forward all requests with an unregistered certificate to the lambda function that will activate the certificate.\nFirst we need our caCertificateID\nUnder Secure click CAs. Click on the CA Certificate you created earlier. Under the CA Certificate ARN, copy the last section of characters possesing your CA Certificate ID. arn:aws:iot:us-east-2:302973482904:cacert/\u003ccaCertificateID\u003e Now to create the rule\nFrom your AWS Console, click on the AWS IoT service. On the left hand side, select Act and then click Rules. Click Create then give an appropriate Name and Description. Using SQL version 2016-03-23 use the following Rule query statement: SELECT * FROM '$aws/events/certificates/registered/\u003ccaCertificateID\u003e' Click Add action. Click Send a message to a Lambda function and Configure Action. Select your lambda function and click Add action. Finally click Create rule. Testing JITR with TLS Connection You can now test your JITR setup by doing a TLS connection with your AWS IoT endpoint and presenting your Zymkey device certificate.\nDetails The first thing to do is to look for your AWS endpoint.\nFrom the AWS IoT console screen, click on the gear that says Settings on the left hand bar.\nCopy the link in the Custom Endpoint box.\nNow on the left hand bar, click on the Test option.\nUnder Subscribe and Subscription Topic, type in hello/world.\nTest your TLS connection with the following CURL command pointing to your CA file and your Zymkey certificate:\nUse CURL to test your TLS connection, pointing to your CA file:\ncurl --tlsv1.2 --cacert zk_ca.pem --cert zymkey.crt --key nonzymkey.key --engine zymkey_ssl --key-type ENG -v -X POST -d \"{ \\\"hello\\\": \\\"world\\\"}\" \"https://endpoint.iot.region.amazonaws.com:8443/topics/hello/world\" The TLS connection should go through, and you should see something like this in your command line:\nOn first connection TLS connection, the TLS handshake should finish, but you should receive empty response from server:\nOn second TLS connection, you will see that the certifiacte is registered and you will get a correct response:\nYou can also check under your certifiactes in your AWS IoT console to see that the new certifciacte is indeed registered. Getting a non-empty response indicates that the certificate is indeed registerd on you AWS account. However, even though the certificate is activated, it does not have a valid policy granting it permission to publish data to your AWS IoT account, which results in the forbidden response. Fortunately you can always modify the jitr lambda function to attach an appropriate policy to the certificate upon registration/activation if you wish to do so.\n","categories":"","description":"","excerpt":"How to automatically generate a client certificate, register your own …","ref":"/tutorials/aws-iot/jitr/","tags":"","title":"AWS IoT - Just in Time Registration of Client Certificates using Lambda functions"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tutorials/perimeter-detect/","tags":"","title":"Perimeter Detect"},{"body":"SECURE PROTOKIT FOR Pi COMPUTERS Waterproof, Dustproof, Radio Transparent, Tamper Evident.\nUpgraded Features ProtoKit5 replaces the ProtoKit4. We had a lot of great feedback from customers of our earlier ProtoKit 4. Here are some of the improvements we made:\nLarger IP67 enclosure: W x H x D | 130 x 175 x 45 mm | 5.12 x 3.24 x 1.77 inches Two cable glands All components soldered to board, ready to go. Fully integrated tamper detect perimeter circuits - switch, pads, user defined. Easier to wire, more robust connectors - screwless, spring cage \u0026 tension clamp. Dedicated +5V connector Schematics How to wire What’s Inside Your Kit This kit comes assembled and ready to start building your prototype in to. The following components are included:\n❶ IP67 enclosure, dustproof, waterproof enclosure with lid\n❷ Integrated protoboard.\n❸ Adapter for perimeter circuits\n❹ GPIO connector extension\n❺ Standoffs for Pi, M2.5 - x 3\n❻ Screws for Pi, M2,5 Torx T8 - x 3\n❼ Screws for protoboard fix - x5\n❽ Cable glands, 3/4 - x2\n❾ IP67 lid with neoprene gasket\n❿ Screws for lid - x6\n⓫ Tamper switch actuators - x2\nBUY NOW \u003e A TOUR OF THE PROTOBOARD The protoboard fits cleaning into the enclosure and can easily be removed for wiring and assembly with your components.\nSlot for Pi Computer\nProtokit will fit the following Pi footprint computers:\nRaspberry Pi 2, 3, 3B+, Zero Asus Tinkerboard Odroid C2 (Heatsink may interfer if zymbit security module fitted) IMPORTANT ! - The Pi computer is fitted connector down, with the CPU facing the protoboard.\nStandoffs to Mount Pi Computer Three M2.5, 5mm pcb standoffs are soldered to the board. Additional screw-in standoffs are supplied to achieve an overal standoff - between Pi and protoboard - of 18mm. Slot for Zymbit Security Module - Zymkey 4i Perimeter Adapter Interface Perimeter Configuration Jumper Tamper Switches - Circuit 1 Perimeter Pads - Circuit 2 Input / Output Connectors +5V Power Input Connector Power Bus - 3v3 Bus Bars - 2 X 15 Grid Arrays - 5 X 15 The grids are not powered and are designed to make it convient to solder wires and components into your design. The reference markers make it easy to document your design and later transfer to work instructions or a PCB design net list. Each pad can be uniquely referenced as G15.D.9 for example. Schematic of Protoboard Download Schematic \u003e\nASSEMBLING YOUR PROTOKIT 5S Fitting a Zymbit Security Module \u0026 Perimeter Adapter If you are fitting a Zymbit security module, here’s where it goes. Fit the perimeter adapter at the same time.\nSequence for Fitting Zymkey4 and Perimeter Adapter\nConfiguring Perimeter Detect Circuits Zymbit security modules contain two perimeter circuits that can be used to detect tampering of a secure envelope. Each tamper circuit is closed in normal operation. When a circuit is opened, a Tamper Event is registered by the Zymbit Security Module.\nLearn how to configure and operate perimeter events in software \u003e\nTypically the two circuits are configured to provide independent layers of physical security:\nPERIM 1 - protects an inner electronic enclosure, like this ProtoKit5 enclosure. PERIM 2 - protects an outer cabinet enclosure, trip wire or other. On ProtoKit 5 there are several ways to configure PERIM 1 and PERIM 2. By default both circuits are closed with two jumpers. 1A\u003c\u003e1B , 2A\u003c\u003e2B.\nUsing Tamper Switches The protoboard includes two tamper switches, PERIM_SWA and PERIM_SWB, that are connected in series to the PERIM 1 tamper circuit. To configure and activate these switches follow these steps:\nRemove the Jumper 1A\u003c\u003e1B Pressing down both switches SWA, SWB will close the PERIM 1 circuit. The lid of you ProtoKit 5 includes two “actuators” that align with the switches and activate (close) them when the lid is fitted and screwed securely in place. If needed you can adjust the length by screwing the actuator in or our of the panel. Tamper Switch Actuators Fitted to Lid Tamper Switch Actuators Pressing Switches Using Perimeter Pads The protoboard includes four tamper pads that are connected to the PERIM 2 tamper circuit as follows:\nConnected on protoboard PCB (orange color) PERIM_PAD_2A \u003c\u003e PERIM_2A_ZYMKEY4 PERIM_PAD_2B \u003c\u003e PERIM_2B_ZYMKEY4 PERIM_PAD_2C \u003c\u003e PERIM_PAD_2D\nConnected by user circuit (green color) PERIM_PAD_2A \u003c\u003e PERIM_PAD_2C PERIM_PAD_2B \u003c\u003e PERIM_PAD_2D\nExamples for Using Perimeter Pads The Perimeter Pads are designed to be used in applications where the lid contains a user defined circuit such as a display or keypad, or this custom shield (which was designed for ProtoKit4). Springed Pogo pins can be used to connect the lid to the perimeter pads. This provides an additional layer of physical security to the tamper-switches.\nAdd Your Pi Computer Fit the GPIO extender header. Fit your Pi computer being careful to correctly align pins. Secure in place with three M2.5 screws using a T8 TORX driver. Place into Enclosure Fitting Cable Glands Your kit comes with two nylon cable glands pre-fitted into ½\" 14 NPT threaded holes. They accept cables with diameter 0.51\" to 0.71\".\nNeed something different? There a many different types of cable glands: size, cable clamp, strain relief, number of cables, material, etc. If you need something different to what is supplied with you kit, then check out this supplier who has a great selection. ElecDirect \u003e\nAdd Enclosure Lid Be sure to add the black seal that was provided with your kit.\nIP67 Enclosure Ratings The enclosure is rated for the following ingress protection.\nIP6x Solid particle protection\nDust Tight - complete protection against contact (dust tight). A vacuum must be applied. Test duration of up to 8 hours based on air flow. IPx7 Liquid ingress protection\nImmersion, up to 1 m depth. Ingress of water in harmful quantity shall not be possible when the enclosure is immersed in water under defined conditions of pressure and time (up to 1 m of submersion). For further details on IP ratings refer to wiki/IP_Code.\nMOUNTING OPTIONS Panel Mounting This enclosure can be mounted directly to a wall or flat surface using two self tapping screws.\nPole Mounting This enclosure can be easily mounted to a pole using a pole mounting brackets available from the Zymbit store.\n","categories":"","description":"","excerpt":"SECURE PROTOKIT FOR Pi COMPUTERS Waterproof, Dustproof, Radio …","ref":"/tutorials/protokit/","tags":"","title":"ProtoKit5"},{"body":" Introduction Python interface module to Zymkey Application Utilities Library.\nThis file contains a Python class which interfaces to the the Zymkey Application Utilities library. This class facilitates writing user space applications which use Zymkey to perform cryptographic operations, such as:\nSigning of payloads using ECDSA. Verification of payloads that were signed using Zymkey. Exporting the public key that matches Zymkey’s private key. “Locking” and “unlocking” data objects. Generating random data. Additionally, there are methods for changing the i2c address (i2c units only), setting tap sensitivity, and controlling the LED.\nClasses class zymkey.Zymkey The Zymkey class definition.\nThis class provides access to the Zymkey within Python.\nEPHEMERAL_KEY_SLOT = -1 __init__ () Initialize an instance of a Zymkey context.\n__del__ () led_on () Turn the LED on.\nExceptions AssertionError If ret is a bad return code from the Zymkey library function. led_off () Turn the LED off.\nExceptions AssertionError If ret is a bad return code from the Zymkey library function. led_flash ( on_ms, off_ms = 0, num_flashes = 0) Flash the LED.\nParameters on_ms (int) — The amount of time in milliseconds that the LED will be on for. off_ms (int) — The amount of time in milliseconds that the LED will be off for. If this parameter is set to 0 (default), the off time is the same as the on time. num_flashes (int) — The number of on/off cycles to execute. If this parameter is set to 0 (default), the LED flashes indefinitely. Exceptions AssertionError If ret is a bad return code from the Zymkey library function. get_random ( num_bytes) Get some random bytes.\nParameters num_bytes (int) — The number of random bytes to get. Exceptions AssertionError If ret is a bad return code from the Zymkey library function. Returns bytearray — An array of bytes returned by the random number generator. create_random_file ( file_path, num_bytes) Deposit random data in a file.\nParameters file_path (str) — The absolute path name for the destination file. num_bytes (int) — The number of random bytes to get. Exceptions AssertionError If ret is a bad return code from the Zymkey library function. lock ( src, dst = None, encryption_key = “zymkey”) Lock up source (plaintext) data.\nThis methods encrypts and signs a block of data.\nThe Zymkey that can be used for locking/unlocking operations.\nThe one-way key is meant to lock up data only on the local host computer. Data encrypted using this key cannot be exported and deciphered anywhere else. Parameters src (Union[str, bytes]) — The source (plaintext) data to lock.\nIf a str is passed to this method, the value is assumed to be the absolute path to the location of the source file. If bytes or bytesarray is passed, it is assumed to contain binary data. dst (Optional[str]) — The destination (ciphertext) of the locked data.\nIf a str is passed to this method, the value is assumed to be the absolute path to the location of the file where the destination data is meant to be written. Otherwise, if None is passed to the method (the default), the locked data is returned from the method as a bytearray. encryption_key (str) — This specifies which key will be used to lock the data. A value of “zymbit” (default) specifies that the Zymkey will use the one-way key. Exceptions AssertionError If ret is a bad return code from the Zymkey library function. Returns bytearray or None — The locked data is returned as a bytearray if no destination is specified when this method is called. Otherwise, None is returned. unlock ( src, dst = None, encryption_key = “zymkey”, raise_exception = True) Unlock source (ciphertext) data.\nThis method verifies a locked object signature and decrypts the associated ciphertext data.\nThe Zymkey has two keys that can be used for locking/unlocking operations.\nThe one-way key is meant to lock up data only on the local host computer. Data encrypted using this key cannot be exported and deciphered anywhere else. Parameters src (Union[str, bytes]) — The source (ciphertext) data to verify and decrypt.\nIf a str is passed to this method, the value is assumed to be the absolute path to the location of the source file. If bytes or bytesarray is passed, it is assumed to contain binary data. dst (Optional[str]) — The destination of the decrypted data (plaintext).\nIf a str is passed to this method, the value is assumed to be the absolute path to the location of the file where the destination data is meant to be written. Otherwise, if None is passed to the method (the default), the locked data is returned from the method as a bytearray. encryption_key (str) — This specifies which key will be used to lock the data. A value of “zymbit” (default) specifies that the Zymkey will use the one-way key. raise_exception (bool) — Specifies if an exception should be raised if the signature verification of the locked object fails. Exceptions AssertionError If ret is a bad return code from the Zymkey library function. Returns bytearray or None — The locked data is returned as a bytearray if no destination is specified when this method is called. Otherwise, None is returned. sign ( src, slot = 0, return_recid = False, encoding = “utf-8”, digest = None) Generate a signature using the Zymkey’s ECDSA private key.\nParameters src (Union[str, bytes, bytearray]) — The SHA256 digest of the data that will be used to generate the signature. slot (int) — The key slot used for signing. [HSM6]Slot can’t contain a X25519 key pair return_recid (bool) — This parameter asks for the y parity to be returned. encoding (str) — This parameter asks for the encoding for the string source. digest (_hashlib.HASH) — This parameter asks for the type of hash. Can be None. Defaults to sha256. Returns — bytearray – A bytearray of the signature. int – If return_recid = True, then return the y parity of the signature (either a 1 or 0). sign_digest ( digest, slot = 0, return_recid = False) Generate a signature using the Zymkey’s ECDSA private key.\nParameters digest (_hashlib.HASH) — A encoded str instance representing the digest to be signed. slot (int) — This parameter specifies the key slot used for signing. [HSM6]Slot can’t contain a X25519 key pair return_recid (bool) — This parameter asks for the y parity to be returned. Exceptions AssertionError If ret is a bad return code from the Zymkey library function. Returns — bytearray – The signature of the SHA-256 digest passed to this method. int – If return_recid = True, then return the y parity of the signature (either a 1 or 0). verify ( src, sig, raise_exception = True, pubkey_slot = 0, foreign = False, encoding = “utf-8”, digest = None) Verify data against a signature.\nThe public key is not specified in the parameter list to ensure that the public key that matches the Zymkey’s ECDSA private key is used.\nParameters src — The buffer to verify. sig — The signature to verify against. raise_exception (bool) — By default, when verification fails a VerificationError will be raised, unless this is set to False. pubkey_slot (int) — The key slot to use to verify the signature against. Defaults to the first key slot. foreign (bool) — If false, the normal key store is referenced. Otherwise, the foreign public key store is referenced.Note: This parameter is only applicable for Supported Devices: HSM6, Secure Compute Module. encoding (str) — This parameter asks for the encoding for the string source. digest (_hashlib.HASH) — This parameter asks for the type of hash. Can be None. Defaults to sha256. Returns bool — Returns True for a good verification or False for a bad verification when the raise_exception parameters is False. verify_digest ( digest, sig, raise_exception = True, pubkey_slot = 0, foreign = False) Verify a signature using the Zymkey’s ECDSA public key.\nThe public key is not specified in the parameter list to ensure that the public key that matches the Zymkey’s ECDSA private key is used.\nParameters digest — A hashlib instance that will be used to generate the signature. sig — The signature to verify. raise_exception (bool) — By default, when verification fails, a VerificationError will be raised, unless this is set to False. pubkey_slot (int) — The key slot to use to verify the signature against. Defaults to the first key slot. foreign (bool) — If false, the normal key store is referenced. Otherwise, the foreign public key store is referenced.Note: This parameter is only applicable for Supported Devices: HSM6, Secure Compute Module. Returns bool — Returns True for a good verification or False for a bad verification when raise_exception is False. ecdh ( local_slot, peer_pubkey, kdf_func_type = “none”, salt = [], info = [], num_iterations = 1, peer_pubkey_slot_is_foreign = True, derived_key_size = 32) Derive a key or a pre-master secret from an ECDH operation. (Supported Devices: HSM6, Secure Compute Module).\nParameters local_slot (int) — The local key slot to use. peer_pubkey (t.Union[t.List[bytes], int]) — The public key of the peer used to generate the pre-master secret against the private key located in local_slot. This parameter can be a list of bytes if the key is provided explicitly or an int if it refers to a key slot. kdf_func_type (str) — Specifies the KDF (Key Derivation Function) to use for the returned derived key. Valid values are:\n“none”: just return the pre-master secret. NOTE: The raw pre-master secret should not be used as a derived key should be put through a suitable KDF. Use “none” when it is desired to use a different KDF than what is offered by this method. “rfc5869-sha256”: RFC5869 with SHA256 “rfc5869-sha512”: RFC5869 with SHA512 “pbkdf2-sha256”: PBKDF2 with SHA256 “pbkdf2-sha512”: PBKDF2 with SHA512 salt (t.Optional[t.List[bytes]]) — A unique identifier for KDF. Ignored for kdf_func_type=’none’. info (t.Optional[t.List[bytes]]) — A unique field for rfc5869. Ignore for other KDF types. num_iterations (int) — The number of iterations that the KDF should complete. peer_pubkey_slot_is_foreign (bool) — TODO_DESCRIPTION derived_key_size (bool) — TODO_DESCRIPTION Returns bytearray — The computed signature. create_ecdsa_public_key_file ( filename, slot = 0) Create a file with the PEM-formatted ECDSA public key.\n[DEPRECATED]: Use create_public_key_file instead. This method is useful for generating a Certificate Signing Request.\nParameters filename (str) — The absolute file path where the public key will be stored in PEM format. slot (int) — The key slot for the public key. Exceptions AssertionError If ret is a bad return code from the Zymkey library function. create_public_key_file ( filename, slot = 0, foreign = False) Create a file with the PEM-formatted public key.\nThis method is useful for generating a Certificate Signing Request.\nParameters filename (str) — The absolute file path where the public key will be stored in PEM format. slot (int) — The key slot for the public key. foreign (bool) — If True, designates the pubkey slot to come from the foreign keystore (Supported Devices: HSM6, Secure Compute Module). Exceptions AssertionError If ret is a bad return code from the Zymkey library function. Returns TYPE — 0 for success, less than 0 for failure. get_ecdsa_public_key ( slot = 0) Retrieves the ECDSA public key as a binary bytearray.\n[DEPRECATED]: Use get_public_key instead. This method is used to retrieve the public key in binary form.\nParameters slot (int) — The key slot for the public key. Exceptions AssertionError If ret is a bad return code from the Zymkey library function. Returns bytearray — The public key in binary form. get_public_key ( slot = 0, foreign = False) Retrieves a public key as a binary bytearray.\nThis method is used to retrieve the public key in binary form.\nParameters slot (int) — The key slot for the public key. Zymkey and HSM4 have slots 0, 1, and 2. foreign (bool) — If True, designates the pubkey slot to come from the foreign keystore (Supported Devices: HSM6, Secure Compute Module). Exceptions AssertionError If ret is a bad return code from the Zymkey library function. Returns bytearray — The public key in binary form. get_slot_alloc_list ( foreign = False) Get a list of the allocated slots in the key store (Supported Devices: HSM6, Secure Compute Module).\nThis method gets a list of the allocated slots in the key store.\nParameters foreign (bool) — If True, designates the pubkey slot to come from the foreign keystore (Supported Devices: HSM6, Secure Compute Module). Exceptions AssertionError If ret is a bad return code from the Zymkey library function. Returns t.Tuple[list, int] — The allocation list and the maximum number of keys store_foreign_public_key ( key_type, pubkey) Stores a foreign public key on the Zymkey foreign keyring (Supported Devices: HSM6, Secure Compute Module).\nThis method stores a foreign public key onto the Zymkey foreign public keyring.\nParameters key_type — The EC curve type that should be associated with the public key. pubkey — The public key binary data. Exceptions AssertionError If ret is a bad return code from the Zymkey library function. Returns int — The slot allocated to the key, or less than one for failure. disable_public_key_export ( slot = 0, foreign = False) Disable exporting of a public key at a given slot (Supported Devices: HSM6, Secure Compute Module).\nThis method permanently disables exporting a public key from a given slot.\nParameters slot — This parameter specifies the key slot for the public key. foreign — If true, the slot refers to the foreign public keyring. Returns TYPE — 0 for success, less than 0 for failure. gen_key_pair ( key_type) Generate a new key pair (Supported Devices: HSM6, Secure Compute Module).\nThis method generates a new key pair of the specified type.\nParameters key_type — This parameter indicates the EC curve type that should be associated with the new key pair. Returns TYPE — the slot allocated to the key or less than one for failure. gen_ephemeral_key_pair ( key_type) Generate a new ephemeral key pair (Supported Devices: HSM6, Secure Compute Module).\nThis method generates a new ephemeral key pair of the specified type, overwriting the previous ephemeral key pair.\nParameters key_type — This parameter indicates the EC curve type that should be associated with the new key pair. Returns TYPE — 0 for success, less than 0 for failure. remove_key ( slot, foreign = False) Remove a key at the designated slot (Supported Devices: HSM6, Secure Compute Module).\nThis method removes a key at the designated slot in either the standard key store or the foreign public keyring.\nParameters slot — This parameter specifies the key slot for the key. foreign — If true, a public key in the foreign keyring will be deleted. Returns TYPE — 0 for success, less than 0 for failure. invalidate_ephemeral_key () Invalidate the ephemeral key (Supported Devices: HSM6, Secure Compute Module).\nThis method invalidates the ephemeral key, effectively removing it from service until a new key is generated.\nExceptions AssertionError If ret is a bad return code from the Zymkey library function. Returns TYPE — 0 for success, less than 0 for failure. gen_wallet_master_seed ( key_type, master_gen_key, wallet_name, recovery_strategy=\u003czymkey.RecoveryStrategy object\u003e) Generates a new master seed for creating a new BIP32 wallet (Supported Devices: HSM6, Secure Compute Module).\nThis method generates a new master seed for creating a new BIP32 wallet.\nParameters key_type — This parameter indicates the EC curve type that should be associated with the new key pair. master_gen_key — The master generator key (bytearray) used in the derivation of the child key. wallet_name — The name of the wallet (string) that this master seed is attached to. recovery_strategy — RecoveryStrategy() class that defines what strategy to be used {None, BIP39, SLIP39} are currently supported. RecoveryStrategy-\u003epassphrase must be b64 encoded. Returns TYPE — the slot the master seed was generated in. 0 for starting SLIP39 sessions. set_gen_SLIP39_group_info ( group_index, member_count, member_threshold) Configures the number of members and threshold for the group shares (Supported Devices: HSM6, Secure Compute Module).\nThis method sets the number of members required for a group share once a SLIP39 session was opened via gen_wallet_master_seed().\nParameters group_index — This parameter indicates the index of the group share to set the amount of member count/threshold for. member_count — The total number of members (mnemonics) in this group share. member_threshold — The number of members (mnemonics) needed to reconstruct the group share. Returns TYPE — 0 on successful configuration. non-zero for error. add_gen_SLIP39_member_pwd ( passphrase = ’’) Generates a new mnemonic_str tied to a SLIP39 member (Supported Devices: HSM6, Secure Compute Module).\nThis method generates a new member of a group share. Members can also be passphrase protected. Passphrases are not required to be unique. This function is meant to be called after configuring a group via set_gen_SLIP39_group_info().\nParameters passphrase — This parameter indicates the passphrase of the SLIP39 member and is associated with the mnemonic string generated. Can be empty string for no passphrase. Returns TYPE — A 24-word recovery phrase known as a mnemonic sentence. non-zero for error. cancel_SLIP39_session () Cancels an active SLIP39 session (Supported Devices: HSM6, Secure Compute Module).\nThis method cancels an ongoing SLIP39 session for both master seed generation and recovery.\nReturns TYPE — 0 on success. non-zero for error. gen_oversight_wallet ( key_type, pub_key, chain_code, node_addr, wallet_name, variant = ’’) Generates a supervisory bip32 wallet. (Supported Devices: HSM6, Secure Compute Module).\nThis method generates a new supervisory Bip32 wallet. Meant for read-only transactions and supervising history.\nParameters key_type — This parameter indicates the EC curve type that should be associated with the new key pair. pub_key — The public key (bytearray) of the last hardened node of the node address. chain_code — The chain code (bytearray) of the last hardened node of the node address. node_addr — The bip32 node address used. (EX: “m/1852’/1815’/0’”). wallet_name — The name of the wallet (string) that this master seed is attached to. variant — Key type variant to generate from. Currently only “cardano” is supported for “ed25519”. Returns TYPE — the slot the oversight wallet was generated in. gen_wallet_child_key ( parent_key_slot, index, hardened, return_chain_code = False) Generates a child key based on a parent key that is in a wallet (Supported Devices: HSM6, Secure Compute Module).\nThis method generates a child key based on a parent key that is in a wallet.\nParameters parent_key_slot — This parameter specifies the parent key slot. This key must already be part of a wallet. index — This parameter represents the index for the child key derivation which becomes part of the node address. hardened — If true, the key is a hardened key. return_chain_code — If true, returns the chain code for the key as well. (Must be from a hardened key). Returns TYPE — the allocated slot on success, or a tuple containing the chain code as well. restore_wallet_master_seed ( key_type, master_gen_key, wallet_name, recovery_strategy, mnemonics = None) Restore a wallet’s master seed based on the recovery strategy object (Supported Devices: HSM6, Secure Compute Module).\nThis method restores a wallet’s master seed based on a mnemonic string and a master generator key. This method can be used in the process of wallet duplication.\nParameters key_type — This parameter indicates the EC curve type that should be associated with the new key pair. master_gen_key — The master generator key used in the derivation of the child key. wallet_name — Name of the new wallet to be generated. recovery_strategy — RecoveryStategy class object that provides the type of recovery and key variant required for restoration. mnemonics — Mnemonic sentences required for restoration, number of mnemonics dependant on recovery strategy used. This field is not used for SLIP39. Returns TYPE — the allocated slot on success add_restore_SLIP39_mnemonic ( mnemonic_sentence, passphrase = ’’) Feed a mnemonic string and the passphrase associated with it (Supported Devices: HSM6, Secure Compute Module).\nThis method feeds in mnemonic sentences (shards) into the module. Meant to be called after starting a restore_wallet_master_seed() SLIP39 session. Will return -1 until the master seed is reconstructed properly.\nParameters mnemonic_sentence — 24-word recovery phrase associated with the SLIP39 member. passphrase — This parameter indicates the passphrase of the SLIP39 member and is associated with the mnemonic string generated. Can be empty string for no passphrase. Returns TYPE — A -1 for no change in status. Otherwise returns the slot of the master seed successfully reconstructed from the last shard passed in. get_wallet_node_addr ( slot) Get a wallet node address from a key slot (Supported Devices: HSM6, Secure Compute Module).\nThis method gets a wallet entry’s node address from its key slot assignment. The wallet name and master seed slot are also returned.\nParameters slot — The key slot assignment. Returns TYPE — the node address, wallet name and master seed key slot. get_wallet_key_slot ( node_addr, wallet_name = None, master_seed_slot = None) Look up a wallet key slot number from a node address (Supported Devices: HSM6, Secure Compute Module).\nThis method gets a wallet key slot number from its node address and wallet name or master seed key slot. Either the wallet name or the master seed slot must be present.\nParameters node_addr — The desired node address to look up wallet_name — The name of the wallet that the node address belongs to. Either this parameter or master_seed_slot must be specified or this function will fail. master_seed_slot — The master seed slot that the node address belongs to. Either this parameter or wallet_name must be specified or this function will fail. Returns TYPE — the key slot. set_i2c_address ( address) Set the i2c address of the Zymkey.\nNote: This is only applicable to versions of the Zymkey with i2c. This method should be called if the i2c address of the Zymkey is shared with another i2c device on the same i2c bus. The default i2c address for Zymkey units is 0x30. Currently, the address may be set in the ranges of 0x30 - 0x37 and 0x60 - 0x67.\nAfter successful completion of this command, the Zymkey will reboot itself.\nParameters address (int) — The i2c address that the Zymkey will set itself to. Exceptions AssertionError If ret is a bad return code from the Zymkey library function. Returns TYPE — 0 for success, less than 0 for failure. set_tap_sensitivity ( axis = “all”, pct = 50.0) Set the sensitivity of tap operations.\nThis method permits setting the sensitivity of the tap detection feature. Each axis may be individually configured or all at once.\nParameters axis — The axis to configure. Valid values include: ’all’: Configure all axes with the specified sensitivity value. ’x’ or “X”: Configure only the x-axis. ’y’ or “Y”: Configure only the y-axis. ’z’ or “Z”: Configure only the z-axis. pct — The sensitivity expressed as percentage. 0% = Shut down: Tap detection should not occur along the axis. 100% = Maximum sensitivity. Returns TYPE — 0 for success, less than 0 for failure. wait_for_tap ( timeout_ms = -1) Wait for tap event.\nThis function is called in order to wait for a tap event to occur. This function blocks the calling thread unless called with a timeout of zero.\nParameters timeout_ms — The maximum amount of time in milliseconds to wait for a tap event to arrive. class ZymkeyAccelAxisData ( g_force, tap_dir) __init__ ( g_force, tap_dir) Initialize self. See help(type(self)) for accurate signature.\nget_accelerometer_data () Get current accelerometer data and tap info.\nThis function gets the most recent accelerometer data in units of g forces plus the tap direction per axis.\nReturns An array of accelerometer readings in units of g-force. array index 0 = x axis – 1 = y axis 2 = z axis A value of -1 indicates that the tap event was detected in a negative direction for the axis, +1 for a positive direction and 0 for stationary. get_time ( precise = False) Get current GMT time.\nThis function is called to get the time directly from a Zymkey’s Real Time Clock (RTC).\nParameters precise — If true, this API returns the time after the next second falls. This means that the caller could be blocked up to one second. If False, the API returns immediately with the current time reading. Returns Time in epoch seconds — lock_binding () Set soft binding lock.\nThis function locks the binding for a specific HSM. This API is only valid for HSM series products.\nExceptions AssertionError If ret is a bad return code from the Zymkey library function. get_current_binding_info () Get current binding info.\nThis function gets the current binding lock state as well as the current binding state. This API is only valid for devices in the HSM family.\nReturns binding_is_locked – Binary value which expresses the current binding lock state. is_bound – Binary value which expresses the current bind state. set_perimeter_event_actions ( channel, action_notify = True, action_self_destruct = False) Set perimeter breach action.\nThis function specifies the action to take when a perimeter breach event occurs. The possible actions are any combination of:\nNotify host. Zymkey self-destruct. Parameters channel — The channel (0 or 1) that the action flags will be applied to action_notify — Set a perimeter breach to notify. (default = True) action_self_destruct — Set a perimeter breach to self destruct. (default = False) Returns TYPE — 0 for success, less than 0 for failure. set_digital_perimeter_lp_period ( lp_period) Set the digital perimeter detect low power period (Supported Devices: HSM6, Secure Compute Module).\nThis function sets the digital perimeter detect low power period (microseconds).\nParameters lp_period — The perimeter detect low power period in microseconds. Returns TYPE — 0 for success, less than 0 for failure. set_digital_perimeter_lp_max_bits ( max_num_bits) Set the low power max number of bits (Supported Devices: HSM6, Secure Compute Module).\nThis function sets the digital perimeter detect low power max number of bits.\nParameters max_num_bits — The perimeter detect low power max number of bits Returns TYPE — 0 for success, less than 0 for failure. set_digital_perimeter_delays ( min_delay_ns, max_delay_ns) Set the digital perimeter detect delays (Supported Devices: HSM6, Secure Compute Module).\nThis function sets the digital perimeter detect delay values.\nParameters min_delay_ns — The minimum delay in nanoseconds. max_delay_ns — The maximum delay in nanoseconds. Returns TYPE — 0 for success, less than 0 for failure. wait_for_perimeter_event ( timeout_ms = -1) Wait for a perimeter breach event to be detected.\nThis function is called in order to wait for a perimeter breach event to occur. This function blocks the calling thread unless called with a timeout of zero.\nParameters timeout_ms — (input) The maximum amount of time in milliseconds to wait for a perimeter breach event to arrive. Returns TYPE — 0 for success, less than 0 for failure. get_perimeter_detect_info () Get current perimeter detect info.\nThis function gets the timestamp of the first perimeter detect event for the given channel. The index corresponds to the channel specified in set_perimeter_event_actions.\nReturns TYPE — The array of timestamps for each channel for the first detected event in epoch seconds clear_perimeter_detect_info () Clear perimeter detect info.\nThis function clears all perimeter detect info and rearms all perimeter detect channels.\nReturns TYPE — 0 for success, less than 0 for failure. get_cpu_temp () Get current CPU temperature (Supported Devices: HSM6, Secure Compute Module).\nThis function gets the current HSM CPU temperature.\nReturns TYPE — The CPU temperature in celsius as a float get_aux_temp ( index = 0) Get current aux temperature (Secure Compute Modules only).\nTHIS FUNCTION IS FOR INTERNAL ZYMBIT USE ONLY.\nThis function gets the current aux temperature. (defaults to 0).\nParameters index — (input) The index id of the processor. Returns TYPE — The temperature in celsius as a float get_rtc_drift () Get RTC drift (Supported Devices: HSM6, Secure Compute Module).\nThis function gets the current RTC drift.\nReturns TYPE — The RTC drift as a float get_batt_volt () Get current battery voltage (Supported Devices: HSM6, Secure Compute Module).\nThis function gets the current battery voltage.\nReturns TYPE — The battery voltage as a float get_model_number () Get Zymkey model number.\nThis function gets the Zymkey model number.\nReturns TYPE — The model number as a string. get_firmware_version () Get Zymkey firmware version.\nThis function gets the Zymkey firmware version.\nReturns TYPE — The firmware version as a string. get_serial_number () Get Zymkey serial number.\nThis function gets the Zymkey serial number.\nReturns TYPE — The serial number as a string. set_battery_voltage_action ( sleep = False, self_destruct = False) Set battery voltage action. (Supported Devices: HSM6, Secure Compute Module).\nThis function specifies the action to take when the battery voltage falls below the threshold set by set_battery_voltage_threshold. If this function is never called, do nothing is default. There are three actions:\nDo nothing. Go to sleep until battery is replaced. Self-destruct. With sleep and self_destruct set to False, it removes a previously set sleep or self_destruct action.\nParameters sleep — Set the sleep action. self_destruct — Set the self_destruct action. Returns TYPE — 0 for success, less than 0 for failure. set_battery_voltage_threshold ( threshold) Sets the battery voltage threshold. (Supported Devices: HSM6, Secure Compute Module).\nThis function sets the threshold at which if the battery voltage falls bellow, the action set by set_battery_voltage_action will be carried out. The recommended threshold is 2.3V is assumed by default. Threshold must be below 2.5V.\nParameters threshold — The threshold in Volts. Returns TYPE — 0 for success, less than 0 for failure. set_cpu_temp_action ( self_destruct = False) Set HSM CPU temperature threshold action. (Supported Devices: HSM6, Secure Compute Module).\nThis function specifies the action to take when the HSM CPU temperature falls below the threshold set by set_cpu_low_temp_threshold, or rises above the threshold set by set_cpu_high_temp_threshold. There are two actions to apply:\nDo nothing. Self-destruct. To remove a previously set self-destruct action, call this function with self_destruct=False.\nParameters self_destruct — Set the self_destruct action. Returns TYPE — 0 for success, less than 0 for failure. set_cpu_low_temp_threshold ( threshold) Sets the HSM CPU low temperature threshold. (Supported Devices: HSM6, Secure Compute Module).\nThis function sets the threshold at which if the on-board HSM CPU’s tempreature falls below, the action set by set_cpu_temp_action will be carried out. WARNING: You can lock yourself out in dev mode if you set a threshold above the CPU’s ambient temperature. The recommended setting is no more than 20C. If this function is never called, -10 degrees celsius is assumed.\nParameters threshold — The threshold in celsius. Returns TYPE — 0 for success, less than 0 for failure. set_cpu_high_temp_threshold ( threshold) Sets the HSM CPU high temperature threshold. (Supported Devices: HSM6, Secure Compute Module).\nThis function sets the threshold at which if the on-board HSM CPU’s tempreature rises above, the action set by set_cpu_temp_action will be carried out. WARNING: You can lock yourself out in dev mode if you set a threshold below the CPU’s ambient temperature. The recommended setting is no less than 40C. If this function is never called, 65 degrees celsius is assumed.\nParameters threshold — The threshold in celsius. Returns TYPE — 0 for success, less than 0 for failure. set_supervised_boot_policy ( policy_id = 0) Sets the Supervised boot policy. (Supported Devices: Secure Compute Module).\nThis function sets the action policy to take when Supervised boot detects a file change during the boot process.\nParameters policy_id (int) — The actions to apply to the Supervised boot process: - 0 Do Nothing - 1 Self-Destruct - 2 Hold Chip in Reset Returns TYPE — 0 for success, less than 0 for failure. add_or_update_supervised_boot_file ( filepath = ’’, slot = 15) Update file manifest for Supervised boot to check. (Supported Devices: Secure Compute Module).\nThis function adds or updates a file in the file manifest to be checked by Supervised during the boot process.\nParameters slot (int) — The slot to sign the file with. filepath (str) — The file to be signed and checked by Supervised boot. Returns TYPE — 0 for success, less than 0 for failure. remove_supervised_boot_file ( filepath = ’’) Remove a file from file manifest for Supervised boot to check. (Supported Devices: Secure Compute Module).\nThis function removes a file in the file manifest to be checked by Supervised boot during the boot process.\nParameters filepath (str) — The file to be removed from the manifest. Returns TYPE — 0 for success, less than 0 for failure. get_supervised_boot_file_manifest () Get the file manifest for Supervised boot to check. (Supported Devices: Secure Compute Module).\nThis function gets a list of the files that are checked by Supervised boot during the boot process.\nReturns TYPE – 0 for success, less than 0 for failure. TYPE – File manifest to be checked by Supervised boot. class zymkey.RecoveryStrategy ( variant = ’’) The RecoveryStrategy class definition.\nThis class specifies the recovery strategy used for wallet generation within Python. Base class strategy is to do no recovery.\n__init__ ( variant = ’’) Initialize an instance of RecoveryStrategy.\nParameters variant — Variant of the key type. Currently only “cardano” for ed25519 is supported. class zymkey.RecoveryStrategyBIP39 ( variant = ’’, passphrase = ’’) The RecoveryStrategyBIP39 class definition.\nThis class specifies the BIP39 recovery strategy used for wallet generation within Python. Derived from RecoveryStrategy class.\n__init__ ( variant = ’’, passphrase = ’’) Initialize an instance of RecoveryStrategyBIP39.\nParameters variant — Variant of the key type. Currently only “cardano” for ed25519 is supported. passphrase — Passphrase used for BIP39 generation. Can be empty string. Must be b64 encoded. class zymkey.RecoveryStrategySLIP39 ( group_count, group_threshold, iteration_exponent, variant = ’’, passphrase = ’’) The RecoveryStrategySLIP39 class definition.\nThis class specifies the SLIP39 recovery strategy used for wallet generation within Python. Derived from RecoveryStrategy class.\n__init__ ( group_count, group_threshold, iteration_exponent, variant = ’’, passphrase = ’’) Initialize an instance of RecoveryStrategySLIP39.\nParameters group_count — Total number of group shares to generate [Max: 14 Groups]. group_threshold — Number of groups needed to restore a master seed with [threshold \u003c= group_count]. iteration_exponent — The higher the exponent the more PBKDF2 hashing is done. [Exponent: 0-5] variant — Variant of the key type. Currently only “cardano” for ed25519 is supported. passphrase — Passphrase used for BIP39 generation. Can be empty string. Must be b64 encoded. ","categories":"","description":"Python interface module to Zymkey Application Utilities Library.","excerpt":"Python interface module to Zymkey Application Utilities Library.","ref":"/api/python_api/","tags":"","title":"Python API Documentation"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/","tags":"","title":"Tags"},{"body":" Introduction This documentation contains a set of Python classes which intend to abstract away the technical complexities of using Zymbit's hardware wallet with various blockchains. The first iteration of the SDK encapsulates all wallet creation, management, and use (sending transactions and interacting with dApps) capabilities for Ethereum and EVM compatible chains.\nTo see examples of the Python SDK in use, check out this tutorial\nInstallation pip install zymbitwalletsdk High Level Overview Abstract Classes Account An abstract class which outlines the basic functionality for an account Keyring An abstract class which outlines the basic functionality required to be considered a keyring If you want your keyring to work with KeyringManager, your keyring implementation must be a subclass of keyring Classes EthAccount A subclass of Account which represents an Ethereum account in the context of Zymbit’s hardware wallet EllipticCurve An enum which represents the elliptic curves supported on Zymbit’s hardware wallet. ZymbitEthKeyring A subclass of Keyring which represents a keyring of Ethereum accounts Can be used to create, manage, use (sign transactions and messages), and delete Ethereum accounts KeyringManager A class used to create, manage, and delete multiple Keyrings (must be a subclass of Keyring) EthTransaction A class representing an unsigned EIP-1559 Ethereum transaction SignedEthTransaction A class representing a signed EIP-1559 Ethereum transaction EthConnect A class with an assortment of methods for interacting with Ethereum using ZymbitEthKeyring instances Zymbit Wallet SDK Classes class zymbitwalletsdk.EthAccount The EthAccount class definition\nThis class provides access to EthAccount within Python.\nEthAccount extends the Account abstract class.\n__init__ ( path, address, slot) Initialize an instance of an EthAccount context\nParameters path (str) — The BIP44 path of the Ethereum Account. Must be a child of m/44'/60'/0'/0 address (str) — The address of the Ethereum account. Must be a valid checksum address. slot (int) — The key slot that holds the private key for the account. Exceptions ValueError If the path, address, or slot is invalid serialize () Serialize the EthAccount object\nReturns dict — containing the path (str), address (hex encoded str), and slot (int) properties get_public_key () Retrieve the public key associated with the Ethereum account\nReturns str — hex encoded public key class zymbitwalletsdk.EllipticCurve The EllipticCurve class definition\nThis class represents an enumeration of elliptic curves available on Zymbit's hardware wallet and extends the Python Enum class.\nsecp256k1 An enumeration value representing the secp256k1 elliptic curve, used in Ethereum and Bitcoin.\nsecp256r1 An enumeration value representing the secp256r1 elliptic curve, also known as nist256 or prime256v1.\ned25519 An enumeration value representing the Ed25519 elliptic curve, used in Cardano, Solana, Polkadot, and Monero to name a few\nget_curve_type () Returns the string representation of the elliptic curve type.\nReturns str — The string representation of the elliptic curve type. Can return \"secp256k1\", \"secp256r1\", or \"ed25519\", depending on the enum's value. class zymbitwalletsdk.ZymbitEthKeyring The ZymbitEthKeyring class definition\nThis class provides access to ZymbitEthKeyring within Python.\nZymbitEthKeyring extends the Keyring abstract class.\nTYPE A class level variable set to \"ETH\" BASE_PATH A class level variable set to \"m/44'/60'/0'/0\" CURVE A class level variable set to EllipticCurve.secp256k1 __init__ ( wallet_name = None, master_slot = None) Initialize an instance of a ZymbitEthKeyring context. Internally calls deserialize(wallet_name, master_slot) and makes some basic checks.\nParameters wallet_name (str) — The name of the wallet associated with the keyring. master_slot (int) — The master slot number of the keyring, optional. Exceptions ValueError If the \"wallet_name\" or \"master_slot\" provided in options is invalid serialize () Serialize the ZymbitEthKeyring instance.\nReturns dict — A dictionary containing the serialized keyring's data including wallet_name (str), master_slot (int), type (\"ETH\"), curve (EllipticCurve.secp256k1), base_path (\"m/44'/60'/0'/0\"), base_slot (int), and accounts (list of serialized EthAccount instances). deserialize ( wallet_name = None, master_slot = None) Deserializes a keyring using either a wallet name or a master slot to restore an instance of a ZymbitEthKeyring context.\nParameters wallet_name (str) — The wallet name associated with the keyring. master_slot (int) — The master slot number of the keyring. Exceptions ValueError If neither wallet_name nor master_slot are provided ValueError If both wallet_name and master_slot are provided ValueError If the provided wallet_name or master_slot is invalid Returns bool — True if the keyring is successfully deserialized, otherwise an exception is raised. add_account (index = 0) Add an Ethereum account to the keyring at the specified index.\nParameters index (int) — The index at which to add the account Exceptions ValueError If the index is invalid or the account already exists in the keyring Returns EthAccount — The added Ethereum account add_accounts ( n = 1) Add multiple Ethereum accounts to the keyring.\nParameters n (int) — The number of accounts to add Exceptions ValueError If the number of accounts to add is invalid Returns list[EthAccount] — A list of added Ethereum accounts add_accounts_list ( index_list = []) Add Ethereum accounts to the keyring at specified indexes from a list.\nParameters index_list (list[int]) — A list of indexes at which to add the accounts Exceptions ValueError If the list of indexes is invalid or an account with the specified index already exists in the keyring Returns list[EthAccount] — A list of added Ethereum accounts get_accounts () Get a list of Ethereum accounts in the keyring.\nReturns list[EthAccount] — A list of Ethereum accounts in the keyring remove_account ( address = None, slot = None, path = None) Remove an Ethereum account from the keyring by its address, slot, or path.\nParameters address (str) — The address of the account to remove slot (int) — The slot of the account to remove path (int) — The path of the account to remove Exceptions ValueError If valid address, slot, or path is not provided Returns bool — True if the account is removed, False otherwise get_public_key ( address = None, slot = None, path = None) Retrieve the public key of an Ethereum account in the keyring by its address, slot, or path.\nParameters address (str) — The address of the account slot (int) — The slot of the account path (int) — The path of the account Exceptions ValueError If valid address, slot, or path is not provided ValueError If the account is not found in the keyring Returns str — The public key of the Ethereum account sign_transaction ( transaction, address = None, slot = None, path = None) Sign an Ethereum transaction using an account in the keyring by its address, slot, or path.\nParameters transaction (EthTransaction) — The transaction to be signed address (str) — The address of the account used to sign the transaction slot (int) — The slot of the account used to sign the transaction path (int) — The path of the account used to sign the transaction Exceptions ValueError If the transaction is not of type EthTransaction ValueError If valid address, slot, or path is not provided ValueError If the account does not exist in the keyring Returns SignedEthTransaction — The signed Ethereum transaction sign_message ( message, address = None, slot = None, path = None) Sign a message using an account in the keyring by its address, slot, or path.\nParameters message (Union[SHA256.SHA256Hash, keccak.Keccak_Hash]) — The message to be signed as a Crypto.Hash object address (str) — The address of the account used to sign the message slot (int) — The slot of the account used to sign the message path (int) — The path of the account used to sign the message Exceptions TypeError If the message is not an instance of either SHA256.SHA256Hash or keccak.Keccak_Hash Crypto.Hash object ValueError If the message is not a valid 256 bit digest in hex format ValueError If valid address, slot, or path is not provided ValueError If the account does not exist in the keyring Returns tuple[int, int, int] — A tuple containing the v, r, and s values of the signed message generate_eth_address ( slot) Generates an Ethereum address using the provided slot.\nParameters slot (int) — The slot to be used for generating the Ethereum address Returns str — The generated Ethereum address account_exists ( index) Checks if an account with the given index exists in the keyring.\nParameters index (int) — The index to be checked for the existence of an account in the keyring Returns bool — True if the account exists in the keyring, False otherwise digest_to_hex ( digest) Converts a given Crypto.Hash digest to its hexadecimal representation.\nParameters digest (Union[SHA256.SHA256Hash, keccak.Keccak_Hash]) — The digest to be converted to its hexadecimal representation Exceptions TypeError If the digest is not an instance of either SHA256.SHA256Hash or keccak.Keccak_Hash Crypto.Hash object Returns str — The hexadecimal representation of the given digest class zymbitwalletsdk.ZymbitKeyringManager The ZymbitKeyringManager class definition\nThis class provides access to ZymbitKeyringManager within Python.\n__init__ ( keyrings = []) Initializes an instance of a KeyringManager with an optional list of Keyring objects.\nParameters keyrings (list[Keyring]) — A list of Keyring objects to be managed by the KeyringManager Exceptions TypeError If any item in the keyrings list is not an instance of a subclass of the Keyring abstract class. create_keyring ( keyring_class, wallet_name, master_gen_key = bytearray()) Creates a new keyring of the specified type, associates it with a wallet name, and optionally initializes it with a master generation key.\nParameters keyring_class (Type[Keyring]) — The Keyring subclass representing the type of keyring to create wallet_name (str) — The name of the wallet associated with the keyring master_gen_key (bytearray) — The master generation key used for initializing the keyring, optional (default is an empty bytearray) Exceptions TypeError If keyring_class is not a subclass of Keyring ValueError If wallet_name is empty or not a string TypeError If master_gen_key is not a bytearray ValueError If the keyring creation fails Returns tuple[int, str] — A tuple containing the wallet's master key slot and the new wallet's mnemonic phrase (store safely for wallet recovery) add_keyring ( keyring) Adds a keyring instance to the list of keyrings\nParameters keyring (Keyring) — The keyring instance to be added Returns bool — True if the keyring was added successfully get_keyring ( wallet_name = None, master_slot = None) Retrieves a keyring instance from the list of keyrings by either the wallet name or the master slot.\nParameters wallet_name (str) — The wallet name associated with the keyring master_slot (int) — The master slot associated with the keyring Returns Keyring — The keyring instance corresponding to the provided wallet name or master slot get_keyrings () Retrieves the list of keyring instances stored in the KeyringManager.\nReturns list[Keyring] — The list of keyring instances stored in the KeyringManager remove_keyring ( wallet_name = None, master_slot = None, remove_master = False) Removes a keyring instance from the list of keyrings in the KeyringManager and deletes all related keys from the module by either the wallet name or the master slot. If the 'remove_master' flag is set to True, the method will also remove the master key associated with the keyring.\nParameters wallet_name (str) — The wallet name associated with the keyring master_slot (int) — The master slot associated with the keyring remove_master (bool) — Flag indicating whether to remove the master key associated with the keyring Returns bool — True if the keyring is successfully removed, False otherwise class zymbitwalletsdk.EthTransaction The EthTransaction class definition\nThis class represents an Ethereum transaction according to the EIP-1559 standard and extends the rlp.Serializable class.\ntransaction_type An integer value of 2, representing the EIP-1559 transaction type.\nfields A list of fields that are relevant to a raw EIP-1559 transaction. The fields are:\nchain_id: The chain ID of the Ethereum network the transaction is meant for. nonce: The nonce value for the sender's account, representing the number of transactions sent from the account. max_priority_fee_per_gas: The maximum fee per gas the sender is willing to pay for the transaction's priority. max_fee_per_gas: The maximum total fee per gas the sender is willing to pay, including both priority and base fees. gas: The amount of gas the sender is willing to allocate to the transaction. to: The recipient's address, or an empty address for contract creation transactions. value: The amount of Wei the sender is transferring to the recipient. data: The transaction data payload, typically used for contract interaction. access_list: A list of addresses and storage keys the transaction will access, used for EIP-2930 access list transactions. class zymbitwalletsdk.SignedEthTransaction The SignedEthTransaction class definition\nThis class represents a signed Ethereum transaction according to the EIP-1559 standard and extends the rlp.Serializable class.\ntransaction_type An integer value of 2, representing the EIP-1559 transaction type.\nfields A list of fields that are relevant to a raw EIP-1559 transaction. The fields are:\nchain_id: The chain ID of the Ethereum network the transaction is meant for. nonce: The nonce value for the sender's account, representing the number of transactions sent from the account. max_priority_fee_per_gas: The maximum fee per gas the sender is willing to pay for the transaction's priority. max_fee_per_gas: The maximum total fee per gas the sender is willing to pay, including both priority and base fees. gas: The amount of gas the sender is willing to allocate to the transaction. to: The recipient's address, or an empty address for contract creation transactions. value: The amount of Wei the sender is transferring to the recipient. data: The transaction data payload, typically used for contract interaction. access_list: A list of addresses and storage keys the transaction will access, used for EIP-2930 access list transactions. y_parity: The y-coordinate parity of the public key, used for signature validation. r: The r value of the ECDSA signature. s: The s value of the ECDSA signature. class zymbitwalletsdk.EthConnect The EthConnect class definition\nThis class contains an assortment of static methods which allow you to use the accounts in your ZymbitEthKeyring instances to sign Ethereum transactions and messages\ncreate_transaction ( chain_id = 1, nonce = 0, max_priority_fee_per_gas = 1, max_fee_per_gas = 10, gas = 21000, to = None, value = 0, data = “0x”, access_list = []) Create and return an EthTransaction object with the specified parameters.\nParameters chain_id (int) — The chain ID of the Ethereum network. Defaults to 1, the chainId of the main Ethereum network nonce (int) — The transaction nonce max_priority_fee_per_gas (int) — The maximum priority fee per gas unit max_fee_per_gas (int) — The maximum fee per gas unit gas (int) — The amount of gas units for the transaction to (str) — The recipient Ethereum address value (int) — The amount of Wei to be sent with the transaction data (str) — The transaction data in hexadecimal format access_list (list) — The access list for the transaction Exceptions ValueError If one or more parameter types are invalid ValueError If the 'to' field is not a valid checksum address Returns EthTransaction — An EthTransaction object with the specified parameters create_deploy_contract_transaction ( chain_id = 1, nonce = 0, max_priority_fee_per_gas = 1, max_fee_per_gas = 10, gas = 21000, value = 0, access_list = [], contract_bytecode_path = None, contract_abi_path = None, constructor_args = []) Create an EthTransaction object for deploying a smart contract with the provided parameters, bytecode, and ABI.\nParameters chain_id (int) — The chain ID of the Ethereum network. Defaults to 1, the chainId of the main Ethereum network nonce (int) — The transaction nonce max_priority_fee_per_gas (int) — The maximum priority fee per gas max_fee_per_gas (int) — The maximum fee per gas gas (int) — The gas limit for the transaction value (int) — The amount of Wei to be sent with the transaction access_list (list) — An access list for the transaction contract_bytecode_path (str) — The path to the file containing the contract bytecode. Should be a text file with the bytecode hex encoded. contract_abi_path (str) — The path to the file containing the contract ABI (Application Binary Interface). Should be a JSON file. constructor_args (list) — A list of arguments to pass to the contract constructor. Ordered from first parameter to last. Exceptions ValueError If one or more parameter types are invalid ValueError If the bytecode or ABI file paths do not exist Returns EthTransaction — An EthTransaction object for deploying the smart contract with the provided parameters, bytecode, and ABI create_execute_contract_transaction ( chain_id = 1, nonce = 0, max_priority_fee_per_gas = 1, max_fee_per_gas = 10, gas = 210000, contract_address = None, value = 0, access_list = [], contract_abi_path = None, function_name = None, args = []) Create a transaction to execute a function of a smart contract on an Ethereum network.\nParameters chain_id (int) — The chain ID of the Ethereum network. Defaults to 1, the chainId of the main Ethereum network nonce (int) — The transaction nonce max_priority_fee_per_gas (int) — The maximum priority fee per gas max_fee_per_gas (int) — The maximum fee per gas gas (int) — The gas limit for the transaction contract_address (str) — The address of the smart contract value (int) — The amount of Wei to be sent with the transaction access_list (list) — An access list for the transaction contract_abi_path (str) — The path to the file containing the contract ABI (Application Binary Interface). Should be a JSON file. function_name (str) — The name of the smart contract function to be executed args (list) — The arguments for the function to be executed. From first parameter to last. Exceptions ValueError If one or more parameter types are invalid, or if the provided contract address is not a valid checksum address, or if the ABI file path does not exist Returns EthTransaction — An EthTransaction object representing the contract execution transaction sign_transaction ( transaction, keyring, address = None, slot = None, path = None) Signs an Ethereum transaction using a Zymbit keyring.\nParameters transaction (EthTransaction) — The transaction to be signed keyring (ZymbitEthKeyring) — The Zymbit keyring to use for signing address (str) — The address of the account in the keyring used to sign the transaction slot (int) — The slot of the account in the keyring used to sign the transaction path (int) — The path of the account in the keyring used to sign the transaction Exceptions ValueError If the transaction is not of type EthTransaction ValueError If the keyring is not of type ZymbitEthKeyring ValueError If none of address, slot, or path are provided Returns SignedEthTransaction — A SignedEthTransaction object ready to be serialized and broadcasted to an Ethereum network rlp_serialize_transaction ( transaction) Serialize an EthTransaction or SignedEthTransaction object using RLP encoding.\nParameters transaction (Union[EthTransaction, SignedEthTransaction]) — The transaction to be serialized Exceptions ValueError If the transaction is neither of type EthTransaction nor SignedEthTransaction Returns bytes — The serialized transaction in bytes format rlp_deserialize_transaction ( encoded_transaction) Deserialize an RLP-encoded transaction to either an EthTransaction or a SignedEthTransaction object.\nParameters encoded_transaction (bytes) — The encoded transaction as bytes Exceptions ValueError If the encoded transaction is not a bytes object ValueError If the encoded transaction is not an EIP-1559 transaction (type 2) ValueError If the encoded transaction cannot be deserialized to an EthTransaction or a SignedEthTransaction object Returns Union[EthTransaction, SignedEthTransaction] — An EthTransaction or a SignedEthTransaction object representing the deserialized transaction create_message ( message) Create an Ethereum message to be signed. Prepends the message that is passed in with \"Ethereum Signed Message:\\n\"\nParameters message (str) — The message to be signed as a string Exceptions TypeError If the message is not a string Returns tuple[str, bytes] — A tuple containing the Ethereum message (str) and its corresponding bytes representation (bytes) sign_message ( message, keyring, address = None, slot = None, path = None) Sign a message using an account in the keyring by its address, slot, or path.\nParameters message (Union[SHA256.SHA256Hash, keccak.Keccak_Hash]) — The message to be signed as a Crypto.Hash object keyring (ZymbitEthKeyring) — The keyring object used to sign the message address (str) — The address of the account used to sign the message slot (int) — The slot of the account used to sign the message path (int) — The path of the account used to sign the message Exceptions TypeError If the message is not an instance of either SHA256.SHA256Hash or keccak.Keccak_Hash Crypto.Hash object ValueError If the message is not a valid 256 bit digest in hex format ValueError If the keyring is not an instance of ZymbitEthKeyring ValueError If valid address, slot, or path is not provided ValueError If the account does not exist in the keyring Returns str — The concatenated hex encoded ECDSA signature keccak256 ( str_data = None, bytes_data = None) Generate a Keccak256 hash digest from the given string or bytes data.\nParameters str_data (str) — String data to generate the Keccak256 hash digest from. bytes_data (bytes) — Bytes data to generate the Keccak256 hash digest from. Exceptions ValueError If both str_data and bytes_data are provided. ValueError If neither str_data nor bytes_data are provided. Returns keccak.Keccak_Hash — A Keccak256 hash digest as a Crypto.Hash.keccak.Keccak_Hash object. sha256 ( str_data = None, bytes_data = None) Generate a SHA256 hash digest from the given string or bytes data.\nParameters str_data (str) — String data to generate the SHA256 hash digest from. bytes_data (bytes) — Bytes data to generate the SHA256 hash digest from. Exceptions ValueError If both str_data and bytes_data are provided. ValueError If neither str_data nor bytes_data are provided. Returns SHA256.SHA256Hash — A SHA256 hash digest as a Crypto.Hash.SHA256.SHA256Hash object. eth_to_wei ( ether_amount= 0) Converts a given amount in Ether to its equivalent value in Wei.\nParameters ether_amount (float) — The amount of Ether to convert to Wei Returns int — The equivalent value in Wei as an integer. Additional Resources If you are a developer interested in creating your own custom implementations of Accounts and/or Keyrings to work with ZymbitKeyringManager, we encourage you to explore our Github repository. By extending the Account and Keyring Abstract Base Classes (ABCs), you can implement the required methods and any additional functionality as needed. The elliptic curves we support (secp256k1, secp256r1, and ed25519) are used by many major blockchains, including Bitcoin, Ethereum, Cardano, Solana, and Polkadot. Developing your own keyrings can be incredibly beneficial for a wide range of applications, such as key management or on-chain interactions like sending transactions or interacting with smart contracts.\n","categories":"","description":"Zymbit Wallet Python SDK","excerpt":"Zymbit Wallet Python SDK","ref":"/reference/zymbit-wallet-sdk/zymbit-wallet-sdk-py/","tags":"","title":"Zymbit Wallet Python SDK Documentation"}]