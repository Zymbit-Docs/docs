<!doctype html><html lang=en class=no-js><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.79.1"><meta name=ROBOTS content="NOINDEX, NOFOLLOW"><link rel="shortcut icon" href=/favicons/favicon.ico><link rel=apple-touch-icon href=/favicons/apple-touch-icon.png sizes=180x180><link rel=icon type=image/png href=/favicons/favicon-16x16.png sizes=16x16><link rel=icon type=image/png href=/favicons/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/favicons/android-chrome-192x192.png sizes=192x192><link rel=icon type=image/png href=/favicons/android-chrome-512x512.png sizes=512x512><title>How to Verify Signatures against Public Key on AWS and Other Devices |</title><meta name=description content><meta property="og:title" content="How to Verify Signatures against Public Key on AWS and Other Devices"><meta property="og:description" content="Introduction While Zymkey makes it trivial to verify data signed by A_Specific_Zymkey on the same A_Specific_Zymkey, verifying the signature of data on other devices using the exportable public key requires a little more explanation. Below is a simple code snippet to show how to verify the signature of locked data using Zymkey&rsquo;s Python API.
import zymkey #encrypt data then sign data = bytearray('hello world!') encrypted_payload = zymkey.client.lock(data) payload_sig = zymkey.client.sign(encrypted_payload) #verify signature matches encrypted data try: if zymkey."><meta property="og:type" content="article"><meta property="og:url" content="https://docs.zymbit.com/tutorials/aws-iot/verify-sigs/"><meta property="og:image" content="https://docs.zymbit.com/doks.png"><meta property="article:modified_time" content="2021-08-17T10:57:00-07:00"><meta property="og:site_name" content="Zymbit Documentation"><meta itemprop=name content="How to Verify Signatures against Public Key on AWS and Other Devices"><meta itemprop=description content="Introduction While Zymkey makes it trivial to verify data signed by A_Specific_Zymkey on the same A_Specific_Zymkey, verifying the signature of data on other devices using the exportable public key requires a little more explanation. Below is a simple code snippet to show how to verify the signature of locked data using Zymkey&rsquo;s Python API.
import zymkey #encrypt data then sign data = bytearray('hello world!') encrypted_payload = zymkey.client.lock(data) payload_sig = zymkey.client.sign(encrypted_payload) #verify signature matches encrypted data try: if zymkey."><meta itemprop=dateModified content="2021-08-17T10:57:00-07:00"><meta itemprop=wordCount content="2866"><meta itemprop=image content="https://docs.zymbit.com/doks.png"><meta itemprop=keywords content><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://docs.zymbit.com/doks.png"><meta name=twitter:title content="How to Verify Signatures against Public Key on AWS and Other Devices"><meta name=twitter:description content="Introduction While Zymkey makes it trivial to verify data signed by A_Specific_Zymkey on the same A_Specific_Zymkey, verifying the signature of data on other devices using the exportable public key requires a little more explanation. Below is a simple code snippet to show how to verify the signature of locked data using Zymkey&rsquo;s Python API.
import zymkey #encrypt data then sign data = bytearray('hello world!') encrypted_payload = zymkey.client.lock(data) payload_sig = zymkey.client.sign(encrypted_payload) #verify signature matches encrypted data try: if zymkey."><link rel=preload href=/scss/main.min.ce0d576b050c303c3365576158e2ded601d798b4493d903e7d9d7c9748c0a182.css as=style><link href=/scss/main.min.ce0d576b050c303c3365576158e2ded601d798b4493d903e7d9d7c9748c0a182.css rel=stylesheet integrity><script src=https://code.jquery.com/jquery-3.5.1.min.js integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin=anonymous></script></head><body class=td-page><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar"><a class=navbar-brand href=/><img class=navbar-logo src=https://docs.zymbit.com/Zymbit-Logo.gif></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"></ul></div><div class="navbar-nav d-none d-lg-block"></div></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><div class="col-12 col-md-4 col-xl-3 td-sidebar d-print-none"><div id=td-sidebar-menu class=td-sidebar__inner><form class="td-sidebar__search d-flex align-items-center"><button class="btn btn-link td-sidebar__toggle d-md-none p-0 ml-3 fas fa-bars" type=button data-toggle=collapse data-target=#td-section-nav aria-controls=td-docs-nav aria-expanded=false aria-label="Toggle section navigation"></button></form><nav class="collapse td-sidebar-nav" id=td-section-nav><ul class="td-sidebar-nav__section pr-md-3 ul-0"><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child active-path" id=m--li><a href=/ class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__section tree-root" id=m-><span>Welcome to Zymbit Documentation</span></a><ul class="pr-md-3 ul-1"><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child" id=m-quickstart-li><span class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__section"><span>QUICKSTART</span></span><ul class="pr-md-3 ul-2"><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child" id=m-quickstartgetting-started-li><a href=/quickstart/getting-started/ title="Getting Started with Zymbit Products" class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__section" id=m-quickstartgetting-started><i class="fas fa-caret-right"></i><span>Getting Started</span></a><ul class="pr-md-3 ul-3"><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child collapse" id=m-quickstartgetting-startedzymkey4-li><a href=/quickstart/getting-started/zymkey4/ title="Getting Started with Zymkey4" class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__page" id=m-quickstartgetting-startedzymkey4><span>ZYMKEY4</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child collapse" id=m-quickstartgetting-startedhsm4-li><a href=/quickstart/getting-started/hsm4/ title="Getting Started with HSM4" class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__page" id=m-quickstartgetting-startedhsm4><span>HSM4</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child collapse" id=m-quickstartgetting-startedhsm6-li><a href=/quickstart/getting-started/hsm6/ title="Getting Started with HSM6" class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__page" id=m-quickstartgetting-startedhsm6><span>HSM6</span></a></li></ul></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child" id=m-quickstartapi-li><a href=/quickstart/api/ title="API Documentation" class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__section" id=m-quickstartapi><i class="fas fa-caret-right"></i><span>API</span></a><ul class="pr-md-3 ul-3"><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child collapse" id=m-quickstartapic_api-li><a href=/quickstart/api/c_api/ class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__page" id=m-quickstartapic_api><span>C API Documentation</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child collapse" id=m-quickstartapicpp_api-li><a href=/quickstart/api/cpp_api/ class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__page" id=m-quickstartapicpp_api><span>C++ API Documentation</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child collapse" id=m-quickstartapipython_api-li><a href=/quickstart/api/python_api/ class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__page" id=m-quickstartapipython_api><span>Python API Documentation</span></a></li></ul></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child" id=m-quickstartfaq-li><a href=/quickstart/faq/ title="FAQ & Troubleshooting" class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__section" id=m-quickstartfaq><i class="fas fa-caret-right"></i><span>FAQ</span></a><ul class="pr-md-3 ul-3"><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child collapse" id=m-quickstartfaqzymkey4-li><a href=/quickstart/faq/zymkey4/ title="Zymkey4 FAQ & Troubleshooting" class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__page" id=m-quickstartfaqzymkey4><span>ZYMKEY4</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child collapse" id=m-quickstartfaqhsm4-li><a href=/quickstart/faq/hsm4/ title="HSM4 FAQ & Troubleshooting" class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__page" id=m-quickstartfaqhsm4><span>HSM4</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child collapse" id=m-quickstartfaqhsm6-li><a href=/quickstart/faq/hsm6/ title="HSM6 FAQ & Troubleshooting" class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__page" id=m-quickstartfaqhsm6><span>HSM6</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child collapse" id=m-quickstartfaqgeneral-li><a href=/quickstart/faq/general/ title="FAQ & Troubleshooting" class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__page" id=m-quickstartfaqgeneral><span>GENERAL</span></a></li></ul></li></ul></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child" id=m-reference-li><span class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__section"><span>REFERENCE</span></span><ul class="pr-md-3 ul-2"><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child" id=m-referencecad-li><a href=/reference/cad/ class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__section" id=m-referencecad><i class="fas fa-caret-right"></i><span>CAD</span></a><ul class="pr-md-3 ul-3"><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child collapse" id=m-referencecadzymkey4-li><a href=/reference/cad/zymkey4/ title="Zymkey4 CAD Files" class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__page" id=m-referencecadzymkey4><span>ZYMKEY4</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child collapse" id=m-referencecadhsm4-li><a href=/reference/cad/hsm4/ title="HSM4 CAD Files" class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__page" id=m-referencecadhsm4><span>HSM4</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child collapse" id=m-referencecadhsm6-li><a href=/reference/cad/hsm6/ title="HSM6 CAD Files" class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__page" id=m-referencecadhsm6><span>HSM6</span></a></li></ul></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child" id=m-referenceconformity-li><a href=/reference/conformity/ class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__section" id=m-referenceconformity><i class="fas fa-caret-right"></i><span>Conformity Documents</span></a><ul class="pr-md-3 ul-3"><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child collapse" id=m-referenceconformityzymkey4-li><a href=/reference/conformity/zymkey4/ title="Zymkey4 Conformity Documents" class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__page" id=m-referenceconformityzymkey4><span>ZYMKEY4</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child collapse" id=m-referenceconformityhsm4-li><a href=/reference/conformity/hsm4/ title="HSM4 Conformity Documents" class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__page" id=m-referenceconformityhsm4><span>HSM4</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child collapse" id=m-referenceconformityhsm6-li><a href=/reference/conformity/hsm6/ title="HSM6 Conformity Documents" class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__page" id=m-referenceconformityhsm6><span>HSM6</span></a></li></ul></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child" id=m-referenceknown-issues-li><a href=/reference/known-issues/ title="Dev Team: Known Issues" class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__section" id=m-referenceknown-issues><i class="fas fa-caret-right"></i><span>Known Issues</span></a><ul class="pr-md-3 ul-3"><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child collapse" id=m-referenceknown-issuescpu-scaling-li><a href=/reference/known-issues/cpu-scaling/ class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__page" id=m-referenceknown-issuescpu-scaling><span>CPU Scaling Governor</span></a></li></ul></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-referencepower-quality-li><a href=/reference/power-quality/ class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__section" id=m-referencepower-quality><i class="fas fa-genderless"></i><span>Power Quality Considerations</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child" id=m-referenceproduct-briefs-li><a href=/reference/product-briefs/ class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__section" id=m-referenceproduct-briefs><i class="fas fa-caret-right"></i><span>Product Briefs</span></a><ul class="pr-md-3 ul-3"><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child collapse" id=m-referenceproduct-briefszymkey4-li><a href=https://www.zymbit.com/datasheets/zymkey-4i target=_blank rel=noopener class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__page" id=m-referenceproduct-briefszymkey4><span>ZYMKEY4</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child collapse" id=m-referenceproduct-briefshsm4-li><a href=https://www.zymbit.com/datasheets/hsm4 target=_blank rel=noopener class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__page" id=m-referenceproduct-briefshsm4><span>HSM4</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child collapse" id=m-referenceproduct-briefshsm6-li><a href=https://www.zymbit.com/datasheets/hsm6 target=_blank rel=noopener class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__page" id=m-referenceproduct-briefshsm6><span>HSM6</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child collapse" id=m-referenceproduct-briefsmfg-app-li><a href=https://www.zymbit.com/datasheets/manufacturing-appliance-1 target=_blank rel=noopener class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__page" id=m-referenceproduct-briefsmfg-app><span>Manufacturing Appliance</span></a></li></ul></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-referencereal-time-clock-li><a href=/reference/real-time-clock/ class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__section" id=m-referencereal-time-clock><i class="fas fa-genderless"></i><span>Real Time Clock Operation</span></a></li></ul></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child active-path" id=m-tutorials-li><span class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__section"><span>TUTORIALS</span></span><ul class="pr-md-3 ul-2"><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-tutorialsalternative-gpio-li><a href=/tutorials/alternative-gpio/ title="Using an Alternative GPIO Pin" class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__section" id=m-tutorialsalternative-gpio><i class="fas fa-genderless"></i><span>Alternative GPIO Pin</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-tutorialsdigital-wallet-li><a href=/tutorials/digital-wallet/ class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__section" id=m-tutorialsdigital-wallet><i class="fas fa-genderless"></i><span>Digital Wallet</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child" id=m-tutorialsencrypt-rfs-li><a href=/tutorials/encrypt-rfs/ title="Encrypting your Root File System with dm-crypt and LUKS" class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__section" id=m-tutorialsencrypt-rfs><i class="fas fa-caret-right"></i><span>Encrypt Root File System</span></a><ul class="pr-md-3 ul-3"><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child collapse" id=m-tutorialsencrypt-rfszymkey4-li><a href=/tutorials/encrypt-rfs/zymkey4/ title="Encrypting Root File System with Zymkey4" class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__page" id=m-tutorialsencrypt-rfszymkey4><span>ZYMKEY4</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child collapse" id=m-tutorialsencrypt-rfshsm4-li><a href=/tutorials/encrypt-rfs/hsm4/ title="Encrypting Root File System with HSM4" class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__page" id=m-tutorialsencrypt-rfshsm4><span>HSM4</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child collapse" id=m-tutorialsencrypt-rfshsm6-li><a href=/tutorials/encrypt-rfs/hsm6/ title="Encrypting Root File System with HSM6" class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__page" id=m-tutorialsencrypt-rfshsm6><span>HSM6</span></a></li></ul></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-tutorialssensor-data-li><a href=/tutorials/sensor-data/ title="Encrypting & Decrypting Sensor Data on Disk" class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__section" id=m-tutorialssensor-data><i class="fas fa-genderless"></i><span>Encrypt Sensor Data</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child active-path" id=m-tutorialsaws-iot-li><a href=/tutorials/aws-iot/ title="AWS IoT Integrations & Client Certificates" class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__section" id=m-tutorialsaws-iot><i class="fas fa-caret-right"></i><span>Integrate Zymbit with AWS</span></a><ul class="pr-md-3 ul-3"><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-tutorialsaws-iotintegrate-li><a href=/tutorials/aws-iot/integrate/ title="How to Integrate Zymbit with AWS Credentials Provider" class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__page" id=m-tutorialsaws-iotintegrate><span>Integrate with AWS Credentials Provider</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-tutorialsaws-iotjitr-li><a href=/tutorials/aws-iot/jitr/ title="AWS IoT - Just in Time Registration of Client Certificates using Lambda functions" class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__page" id=m-tutorialsaws-iotjitr><span>Just In Time Registration</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-tutorialsaws-iottls-li><a href=/tutorials/aws-iot/tls/ title="AWS IoT - TLS Client Certificate Authentication" class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__page" id=m-tutorialsaws-iottls><span>Transport Level Security</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child active-path" id=m-tutorialsaws-iotverify-sigs-li><a href=/tutorials/aws-iot/verify-sigs/ title="How to Verify Signatures against Public Key on AWS and Other Devices" class="align-left pl-0 pr-2 active td-sidebar-link td-sidebar-link__page" id=m-tutorialsaws-iotverify-sigs><span class=td-sidebar-nav-active-item>Verify Signatures</span></a></li></ul></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child" id=m-tutorialsperimeter-detect-li><a href=/tutorials/perimeter-detect/ class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__section" id=m-tutorialsperimeter-detect><i class="fas fa-caret-right"></i><span>Perimeter Detect</span></a><ul class="pr-md-3 ul-3"><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child collapse" id=m-tutorialsperimeter-detectzymkey4-li><a href=/tutorials/perimeter-detect/zymkey4/ title="Perimeter Detect: ZYMKEY4" class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__page" id=m-tutorialsperimeter-detectzymkey4><span>ZYMKEY4</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child collapse" id=m-tutorialsperimeter-detecthsm4-li><a href=/tutorials/perimeter-detect/hsm4/ title="Perimeter Detect: HSM4" class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__page" id=m-tutorialsperimeter-detecthsm4><span>HSM4</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child collapse" id=m-tutorialsperimeter-detecthsm6-li><a href=/tutorials/perimeter-detect/hsm6/ title="Perimeter Detect: HSM6" class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__page" id=m-tutorialsperimeter-detecthsm6><span>HSM6</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child collapse" id=m-tutorialsperimeter-detectexamples-li><a href=/tutorials/perimeter-detect/examples/ title="Perimeter Detect Circuit Examples" class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__page" id=m-tutorialsperimeter-detectexamples><span>CIRCUIT EXAMPLES</span></a></li></ul></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-tutorialsprotokit-li><a href=/tutorials/protokit/ class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__section" id=m-tutorialsprotokit><i class="fas fa-genderless"></i><span>ProtoKit5</span></a></li></ul></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-forum-li><a href=https://community.zymbit.com/ target=_blank rel=noopener class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__section" id=m-forum><span>FORUM</span></a></li></ul></li></ul></nav></div></div><div class="d-none d-xl-block col-xl-2 td-toc d-print-none"><div class="td-page-meta ml-2 pb-1 pt-2 mb-0"></div><nav id=TableOfContents><ul><li><ul><li><a href=#introduction>Introduction</a></li></ul></li><li><a href=#prerequisites>Prerequisites</a><ul><li><a href=#simple-signature-validation-against-zymkey-public-key>Simple Signature Validation against Zymkey Public Key</a><ul><li><a href=#installing-python-ecdsa-library>Installing Python-Ecdsa library</a></li><li><a href=#simple-signature-verification-with-public-key>Simple Signature Verification with Public Key</a></li><li><a href=#signature-verification-on-another-device>Signature Verification on Another Device</a></li><li><a href=#generating-json-data-for-validation>Generating JSON Data for Validation</a></li></ul></li><li><a href=#validation-of-encrypted-sensor-signature-on-aws>Validation of Encrypted Sensor Signature on AWS</a><ul><li><a href=#collecting-temperature-data>Collecting Temperature Data</a></li><li><a href=#signing-temperature-data-and-packaging-in-json>Signing Temperature Data and Packaging in JSON</a></li><li><a href=#sending-encrypted-temperature-data-to-aws>Sending Encrypted Temperature Data to AWS</a></li><li><a href=#checking-data-is-being-published-to-aws-iot>Checking Data is being published to AWS IoT</a></li><li><a href=#verifying-signature-of-encrypted-data-with-zymkey-public-key-on-aws>Verifying Signature of Encrypted Data with Zymkey Public Key on AWS</a></li></ul></li></ul></li></ul></nav></div><main class="col-12 col-md-8 col-xl-7 pl-md-5" role=main><nav aria-label=breadcrumb class="d-none d-md-block d-print-none"><ol class="breadcrumb spb-1"><li class=breadcrumb-item><a href=https://docs.zymbit.com/tutorials/>TUTORIALS</a></li><li class=breadcrumb-item><a href=https://docs.zymbit.com/tutorials/aws-iot/>Integrate Zymbit with AWS</a></li><li class="breadcrumb-item active" aria-current=page><a href=https://docs.zymbit.com/tutorials/aws-iot/verify-sigs/>Verify Signatures</a></li></ol></nav><div class=td-content><h1>How to Verify Signatures against Public Key on AWS and Other Devices</h1><h3 id=introduction>Introduction</h3><p>While Zymkey makes it trivial to verify data signed by A_Specific_Zymkey on the same A_Specific_Zymkey, verifying the signature of data on other devices using the exportable public key requires a little more explanation. Below is a simple code snippet to show how to verify the signature of locked data using Zymkey&rsquo;s Python API.</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=kn>import</span> <span class=nn>zymkey</span>

<span class=c1>#encrypt data then sign</span>
<span class=n>data</span> <span class=o>=</span> <span class=nb>bytearray</span><span class=p>(</span><span class=s1>&#39;hello world!&#39;</span><span class=p>)</span>
<span class=n>encrypted_payload</span> <span class=o>=</span> <span class=n>zymkey</span><span class=o>.</span><span class=n>client</span><span class=o>.</span><span class=n>lock</span><span class=p>(</span><span class=n>data</span><span class=p>)</span>
<span class=n>payload_sig</span> <span class=o>=</span> <span class=n>zymkey</span><span class=o>.</span><span class=n>client</span><span class=o>.</span><span class=n>sign</span><span class=p>(</span><span class=n>encrypted_payload</span><span class=p>)</span>

<span class=c1>#verify signature matches encrypted data</span>
<span class=k>try</span><span class=p>:</span>
	<span class=k>if</span> <span class=n>zymkey</span><span class=o>.</span><span class=n>client</span><span class=o>.</span><span class=n>verify</span><span class=p>(</span><span class=n>encrypted_payload</span><span class=p>,</span> <span class=n>payload_sig</span><span class=p>):</span>
		<span class=k>print</span><span class=p>(</span><span class=s1>&#39;Signature signed correctly by Zymkey and matches encrypted payload.&#39;</span><span class=p>)</span>
<span class=k>except</span> <span class=ne>Exception</span> <span class=k>as</span> <span class=n>e</span><span class=p>:</span>
	<span class=k>print</span><span class=p>(</span><span class=s1>&#39;Signature invalid. Data not signed by Zymkey private key.&#39;</span><span class=p>)</span>
</code></pre></div><p>Since the IoT environment is all about communication among many devices, we will demonstrate how to verify A_Specific_Zymkey&rsquo;s ECDSA signature on other devices not bound to A_Specific_Zymkey using the public key corresponding to the signing device&rsquo;s private key (stored securely in A_Specific_Zymkey).</p><p>After showing how to do just signature verification, I will demonstrate how this can be used in a practical situation by collecting temperature data from a sensor, encrypting the data and signing it. I will then package the data in JSON format, a standard format for data communication over the internet using strings. This data will then be published to AWS IoT, where it will be routed, via a Rule, to a lambda function that will validate the data based on the public key. <strong>From there a user can rout their data to any service they desire, this post will just demonstrate how to validate the signatures of all data sent to AWS before they are proccessed by another service</strong>.</p><p>Futhermore, all data published to AWS will be authenticated against a Zymkey device certificate which validates against Zymkey&rsquo;s private key without exporting said key. We will do this by making HTTPS requests to AWS IoT using PyCurl. This serves as client authentication when connecting to AWS IoT; AWS IoT enforces this policy to make sure the device publishing data is an authorized one.</p><p>All these examples will be done via Python using the Python-ECDSA library, a future post will extend all these functions to C/C++.</p><h2 id=prerequisites>Prerequisites</h2><ol><li>Follow the <a href=https://docs.zymbit.com/quickstart/getting-started/>Getting Started guide</a> first, installing all baseline software.</li><li>If you wish to try Signature validation on AWS, you need a <a href=https://docs.zymbit.com/tutorials/aws-iot/tls/>valid device certificate</a> attached to your AWS account.</li><li>The device certificate needs to have a policy attached giving it permission to publish data.</li></ol><h3 id=simple-signature-validation-against-zymkey-public-key>Simple Signature Validation against Zymkey Public Key</h3><h4 id=installing-python-ecdsa-library>Installing Python-Ecdsa library</h4><p>For the verification of ECDSA-NIST256 signatures, we will be using the <a href=https://github.com/warner/python-ecdsa>Python-ECDSA library</a>. Using Pip, the library can be installed simply by running the following command:</p><pre><code>sudo pip install ecdsa
</code></pre><p>Otherwise you can clone the repository into a directory like this:</p><pre><code>git clone https://github.com/warner/python-ecdsa.git
</code></pre><p>Run the following command the repo directory:</p><pre><code>python setup.py install
</code></pre><p>You may need to update your version of <strong>Six</strong> if you get a naming error. Otherwise, you can always build the required directory with this command:</p><pre><code>python setup.py build
</code></pre><p>Now under your <strong>build directory</strong>, and in <strong>one of the two directories depending on your hardware</strong>, there will be an <strong>ecdsa</strong> directory. Any code you write in the same directory will be able to import the module correctly.</p><h4 id=simple-signature-verification-with-public-key>Simple Signature Verification with Public Key</h4><p>Below is a simple Python program demonstrating how to verify A_Specific_Zymkey signature with a public key hosted on a device bound to A_Specific_Zymkey. All data passed to the ECDSA verifying function is in bytearray format. The function is validating against the default signing hash function Zymkey uses, <strong>sha256</strong>, and returns a boolean indicating whether the signature matches the public key and data. Public key for Zymkey is exported as bytearray using the API function <strong>get_ecdsa_public_key()</strong>.</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=kn>import</span> <span class=nn>zymkey</span>
<span class=kn>import</span> <span class=nn>ecdsa</span>
<span class=kn>import</span> <span class=nn>hashlib</span>

<span class=c1>#Function to verify ECDSA signatures, all arguments must be in bytearray format. Validating against Zymkey signing&#39;s default hashing function, sha256 but this can be modified.</span>
<span class=k>def</span> <span class=nf>verify_ecdsa_signature</span><span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=n>sig</span><span class=p>,</span> <span class=n>pub_key</span><span class=p>):</span>
	<span class=n>vk</span> <span class=o>=</span> <span class=n>ecdsa</span><span class=o>.</span><span class=n>VerifyingKey</span><span class=o>.</span><span class=n>from_string</span><span class=p>(</span><span class=n>pub_key</span><span class=p>,</span> <span class=n>ecdsa</span><span class=o>.</span><span class=n>NIST256p</span><span class=p>)</span>
	<span class=k>return</span> <span class=n>vk</span><span class=o>.</span><span class=n>verify</span><span class=p>(</span><span class=n>sig</span><span class=p>,</span> <span class=n>data</span><span class=p>,</span> <span class=n>hashfunc</span><span class=o>=</span><span class=n>hashlib</span><span class=o>.</span><span class=n>sha256</span><span class=p>)</span>

<span class=k>if</span> <span class=vm>__name__</span> <span class=o>==</span> <span class=s2>&#34;__main__&#34;</span><span class=p>:</span>
	<span class=c1>#exporting Zymkey public key as bytearray</span>
	<span class=n>pub_key</span> <span class=o>=</span> <span class=n>zymkey</span><span class=o>.</span><span class=n>client</span><span class=o>.</span><span class=n>get_ecdsa_public_key</span><span class=p>()</span>
	
	<span class=n>data</span> <span class=o>=</span> <span class=nb>bytearray</span><span class=p>(</span><span class=s1>&#39;hello world!&#39;</span><span class=p>)</span>
	<span class=n>encrypted_payload</span> <span class=o>=</span> <span class=n>zymkey</span><span class=o>.</span><span class=n>client</span><span class=o>.</span><span class=n>lock</span><span class=p>(</span><span class=n>data</span><span class=p>)</span>
	<span class=n>payload_sig</span> <span class=o>=</span> <span class=n>zymkey</span><span class=o>.</span><span class=n>client</span><span class=o>.</span><span class=n>sign</span><span class=p>(</span><span class=n>encrypted_payload</span><span class=p>)</span>

	<span class=k>if</span> <span class=n>verify_ecdsa_signature</span><span class=p>(</span><span class=n>data</span><span class=o>=</span><span class=n>encrypted_payload</span><span class=p>,</span> <span class=n>sig</span><span class=o>=</span><span class=n>payload_sig</span><span class=p>,</span> <span class=n>pub_key</span> <span class=o>=</span> <span class=n>pub_key</span><span class=p>):</span>
		<span class=k>print</span><span class=p>(</span><span class=s1>&#39;Signature matches data and public key pair.&#39;</span><span class=p>)</span>
	<span class=k>else</span><span class=p>:</span>
		<span class=k>print</span><span class=p>(</span><span class=s1>&#39;Signature is invalid; it does not correspond to the public key.&#39;</span><span class=p>)</span>
</code></pre></div><h4 id=signature-verification-on-another-device>Signature Verification on Another Device</h4><p>This next Python program will simulate signature verification on another device that receives the data in JSON format. The public key is hard coded into the program for the sake of a simple demonstration, but public key exchange between devices is up to the discretion of the user. The data payload and signature will be passed in a JSON string in the format of a hex string. Hex strings are simply representations of the underlying bytes in a human readable format.</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=kn>import</span> <span class=nn>json</span>
<span class=kn>import</span> <span class=nn>zymkey</span>
<span class=kn>import</span> <span class=nn>hashlib</span>
<span class=kn>import</span> <span class=nn>ecdsa</span>

<span class=k>def</span> <span class=nf>verify_ecdsa_signature</span><span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=n>sig</span><span class=p>,</span> <span class=n>pub_key</span><span class=p>):</span>
	<span class=n>vk</span> <span class=o>=</span> <span class=n>ecdsa</span><span class=o>.</span><span class=n>VerifyingKey</span><span class=o>.</span><span class=n>from_string</span><span class=p>(</span><span class=n>pub_key</span><span class=p>,</span> <span class=n>ecdsa</span><span class=o>.</span><span class=n>NIST256p</span><span class=p>)</span>
	<span class=k>return</span> <span class=n>vk</span><span class=o>.</span><span class=n>verify</span><span class=p>(</span><span class=n>sig</span><span class=p>,</span> <span class=n>data</span><span class=p>,</span> <span class=n>hashfunc</span><span class=o>=</span><span class=n>hashlib</span><span class=o>.</span><span class=n>sha256</span><span class=p>)</span>

<span class=s1>&#39;&#39;&#39; 
</span><span class=s1>The variable received_payload will be the JSON string sent over to this device from the Zymkey. It contains 1.the encrypted data and 2.the signature for this data.
</span><span class=s1>Here is how it will be formatted:
</span><span class=s1>	&#34;{
</span><span class=s1>		&#39;data&#39;: &#39;hex_string of data&#39;,
</span><span class=s1>		&#39;signature&#39;: &#39;hex_string of signature;
</span><span class=s1>	}&#34;
</span><span class=s1>&#39;&#39;&#39;</span>

<span class=k>if</span> <span class=vm>__name__</span> <span class=o>==</span> <span class=s2>&#34;__main__&#34;</span><span class=p>:</span>
	<span class=c1>#Zymkey public key in hex string format. Converted to byte_array, public key storage/exchange up to user. </span>
	<span class=n>pub_key</span> <span class=o>=</span> <span class=nb>bytearray</span><span class=o>.</span><span class=n>fromhex</span><span class=p>(</span><span class=s1>&#39;9929a80b1d2e1543992dc767f394d1859bc33e9b241203f53473d859e1506f7ee5593b53a7fe7014aecc1f14886e1440e6bde27571c596a7ae3d1573e4122d90&#39;</span><span class=p>)</span>

	<span class=c1>#Converting JSON string to Python dictionary for easier manipulation</span>
	<span class=n>payload_pydict</span> <span class=o>=</span> <span class=n>json</span><span class=o>.</span><span class=n>loads</span><span class=p>(</span><span class=n>received_payload</span><span class=p>)</span>

	<span class=c1>#Getting the hex_strings from the new Python dictionary</span>
	<span class=n>encrypted_payload</span> <span class=o>=</span> <span class=n>payload_pydict</span><span class=p>[</span><span class=s1>&#39;data&#39;</span><span class=p>]</span>
	<span class=n>payload_sig</span> <span class=o>=</span> <span class=n>payload_pydict</span><span class=p>[</span><span class=s1>&#39;signature&#39;</span><span class=p>]</span>

	<span class=c1>#Validating signature against public key and data, converting all hex_strings to bytearrays.</span>
	<span class=k>if</span> <span class=n>verify_ecdsa_signature</span><span class=p>(</span><span class=n>data</span><span class=o>=</span><span class=nb>bytearray</span><span class=o>.</span><span class=n>fromhex</span><span class=p>(</span><span class=n>encrypted_payload</span><span class=p>),</span> <span class=n>sig</span><span class=o>=</span><span class=nb>bytearray</span><span class=o>.</span><span class=n>fromhex</span><span class=p>(</span><span class=n>payload_sig</span><span class=p>),</span> <span class=n>pub_key</span><span class=o>=</span><span class=n>pub_key</span><span class=p>):</span>
		<span class=k>print</span><span class=p>(</span><span class=s1>&#39;Signature matches data and public key pair.&#39;</span><span class=p>)</span>
	<span class=k>else</span><span class=p>:</span>
		<span class=k>print</span><span class=p>(</span><span class=s1>&#39;Signature is invalid; it does not correspond to the public key.&#39;</span><span class=p>)</span>
</code></pre></div><h4 id=generating-json-data-for-validation>Generating JSON Data for Validation</h4><p>The above code shows how to validate JSON strings where the data is being represented as hex strings. The JSON is represented above as the variable <strong>received_payload</strong>; I will show how to generate such JSON data that you can send over to be validated.</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=kn>import</span> <span class=nn>zymkey</span>
<span class=kn>import</span> <span class=nn>binascii</span>
<span class=kn>import</span> <span class=nn>json</span>

<span class=k>def</span> <span class=nf>create_signed_json</span><span class=p>():</span>
	<span class=c1>#Create data, encrypt then sign encrypted data</span>
	<span class=n>data</span> <span class=o>=</span> <span class=nb>bytearray</span><span class=p>(</span><span class=s1>&#39;hello world~&#39;</span><span class=p>)</span>
	<span class=n>encrypted_payload</span> <span class=o>=</span> <span class=n>zymkey</span><span class=o>.</span><span class=n>client</span><span class=o>.</span><span class=n>lock</span><span class=p>(</span><span class=n>data</span><span class=p>)</span>
	<span class=n>signature</span> <span class=o>=</span> <span class=n>zymkey</span><span class=o>.</span><span class=n>client</span><span class=o>.</span><span class=n>sign</span><span class=p>(</span><span class=n>encrypted_payload</span><span class=p>)</span>

	<span class=c1>#Store data in a python dictionary that represents JSON. Data is originally in bytearray form, but will be converted to hex_string</span>
	<span class=n>json_dictioanry</span> <span class=o>=</span> <span class=p>{</span><span class=s1>&#39;data&#39;</span><span class=p>:</span> <span class=n>binascii</span><span class=o>.</span><span class=n>hexlify</span><span class=p>(</span><span class=n>encrypted_payload</span><span class=p>),</span> <span class=s1>&#39;signature&#39;</span><span class=p>:</span> <span class=n>binascii</span><span class=o>.</span><span class=n>hexlify</span><span class=p>(</span><span class=n>signature</span><span class=p>)}</span>
	
	<span class=c1>#Convert python dictionary to JSON string format</span>
	<span class=n>received_payload</span> <span class=o>=</span> <span class=n>json</span><span class=o>.</span><span class=n>dumps</span><span class=p>(</span><span class=n>json_dictionary</span><span class=p>)</span>
	<span class=k>return</span> <span class=n>received_payload</span>
     
</code></pre></div><h3 id=validation-of-encrypted-sensor-signature-on-aws>Validation of Encrypted Sensor Signature on AWS</h3><p>This example will be using a DS18B20 OneWire probe to collect temperature data.</p><p>For the purpose of this tutorial I will not be going over the circuit setup and one-wire configuration. That is adequately covered <a href=https://learn.adafruit.com/adafruits-raspberry-pi-lesson-11-ds18b20-temperature-sensing/hardware>here</a>.</p><p>If you don&rsquo;t wish to use a real temperature probe, you can always generate random values as temperature data to test.</p><h4 id=collecting-temperature-data>Collecting Temperature Data</h4><p>Here&rsquo;s the code to collect Temperature data from the probe. It is just a simple program that reads from a file thtat the probes deposit temperature data to. <strong>Simply use the function read_temp() which will return an array containing temp_c and temp_f, whenever you need to read temperature from the probes.</strong></p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=n>os</span><span class=o>.</span><span class=n>system</span><span class=p>(</span><span class=s1>&#39;modprobe w1-gpio&#39;</span><span class=p>)</span>
<span class=n>os</span><span class=o>.</span><span class=n>system</span><span class=p>(</span><span class=s1>&#39;modprobe w1-therm&#39;</span><span class=p>)</span>
<span class=n>base_dir</span> <span class=o>=</span> <span class=s1>&#39;/sys/bus/w1/devices/&#39;</span>
<span class=n>device_folder</span> <span class=o>=</span> <span class=n>glob</span><span class=o>.</span><span class=n>glob</span><span class=p>(</span><span class=n>base_dir</span> <span class=o>+</span> <span class=s1>&#39;28*&#39;</span><span class=p>)[</span><span class=mi>0</span><span class=p>]</span>
<span class=n>device_file</span> <span class=o>=</span> <span class=n>device_folder</span> <span class=o>+</span> <span class=s1>&#39;/w1_slave&#39;</span>

<span class=k>def</span> <span class=nf>read_temp</span><span class=p>():</span>
	<span class=n>lines</span> <span class=o>=</span> <span class=n>read_temp_raw</span><span class=p>()</span>
	<span class=k>while</span> <span class=n>lines</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=o>.</span><span class=n>strip</span><span class=p>()[</span><span class=o>-</span><span class=mi>3</span><span class=p>:]</span> <span class=o>!=</span> <span class=s1>&#39;YES&#39;</span><span class=p>:</span>
		<span class=n>time</span><span class=o>.</span><span class=n>sleep</span><span class=p>(</span><span class=mf>0.2</span><span class=p>)</span>
		<span class=n>lines</span> <span class=o>=</span> <span class=n>read_temp_raw</span><span class=p>()</span>
	<span class=n>equals_pos</span> <span class=o>=</span> <span class=n>lines</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span><span class=o>.</span><span class=n>find</span><span class=p>(</span><span class=s1>&#39;t=&#39;</span><span class=p>)</span>
	<span class=k>if</span> <span class=n>equals_pos</span> <span class=o>!=</span> <span class=o>-</span><span class=mi>1</span><span class=p>:</span>
		<span class=n>temp_string</span> <span class=o>=</span> <span class=n>lines</span><span class=p>[</span><span class=mi>1</span><span class=p>][</span><span class=n>equals_pos</span><span class=o>+</span><span class=mi>2</span><span class=p>:]</span>
		<span class=n>temp_c</span> <span class=o>=</span> <span class=nb>float</span><span class=p>(</span><span class=n>temp_string</span><span class=p>)</span> <span class=o>/</span> <span class=mf>1000.0</span>
		<span class=n>temp_f</span> <span class=o>=</span> <span class=n>temp_c</span> <span class=o>*</span> <span class=mf>9.0</span> <span class=o>/</span> <span class=mf>5.0</span> <span class=o>+</span> <span class=mf>32.0</span>
		<span class=k>return</span> <span class=n>temp_c</span><span class=p>,</span> <span class=n>temp_f</span>
</code></pre></div><h4 id=signing-temperature-data-and-packaging-in-json>Signing Temperature Data and Packaging in JSON</h4><p>Next we will show how to read the temperature data and package it in JSON format, so that we can send it up to AWS IoT. <strong>Note that the above code also needs to be appended to this so that the read_temp function is defined.</strong></p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=kn>import</span> <span class=nn>zymkey</span>
<span class=kn>import</span> <span class=nn>binascii</span>
<span class=kn>import</span> <span class=nn>json</span>

<span class=s1>&#39;&#39;&#39;
</span><span class=s1>Note that JSON data needs to be in this format:
</span><span class=s1>	&#34;{
</span><span class=s1>		&#39;data&#39;: &#39;hex_string of data&#39;,
</span><span class=s1>		&#39;signature&#39;: &#39;hex_string of signature;
</span><span class=s1>	}&#34;
</span><span class=s1>If you wish to use a different JSON format, you can always modify the lambda function.
</span><span class=s1>&#39;&#39;&#39;</span>

<span class=k>while</span> <span class=bp>True</span><span class=p>:</span>
	<span class=n>temp</span> <span class=o>=</span> <span class=n>read_temp</span><span class=p>()</span>
	<span class=n>temp_F</span> <span class=o>=</span> <span class=n>temp</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=n>temp_C</span> <span class=o>=</span> <span class=n>temp</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
	<span class=n>deviceID</span> <span class=o>=</span> <span class=mi>1</span><span class=p>,</span> <span class=n>myIP</span><span class=o>=</span> <span class=s1>&#39;169.231.116.56&#39;</span>
	
	<span class=c1>#Package the data in Python dictionary, then convert to JSON string.</span>
	<span class=n>data</span> <span class=o>=</span> <span class=p>{</span><span class=s1>&#39;temp_F&#39;</span><span class=p>:</span> <span class=n>temp_F</span><span class=p>,</span> <span class=s1>&#39;temp_C&#39;</span><span class=p>:</span> <span class=n>temp_C</span><span class=p>,</span> <span class=s1>&#39;deviceIP&#39;</span><span class=p>:</span> <span class=n>myIP</span><span class=p>,</span> <span class=s1>&#39;deviceID&#39;</span><span class=p>:</span> <span class=n>deviceID</span><span class=p>}</span>
	
	<span class=c1>#Encrypt the underlying bytes for the string and then sign it.</span>
	<span class=n>encrypted_data</span> <span class=o>=</span> <span class=n>zymkey</span><span class=o>.</span><span class=n>client</span><span class=o>.</span><span class=n>lock</span><span class=p>(</span><span class=nb>bytearray</span><span class=p>(</span><span class=n>json</span><span class=o>.</span><span class=n>dumps</span><span class=p>(</span><span class=n>data</span><span class=p>)))</span>
	<span class=n>signature</span> <span class=o>=</span> <span class=n>zymkey</span><span class=o>.</span><span class=n>client</span><span class=o>.</span><span class=n>sign</span><span class=p>(</span><span class=n>encrypted_data</span><span class=p>)</span>

	<span class=c1>#Make a new dictionary to hold the hex_strings of the encrypted data and signture, and then turn into JSON</span>
	<span class=n>json_data</span> <span class=o>=</span> <span class=n>json</span><span class=o>.</span><span class=n>dumps</span><span class=p>({</span><span class=s1>&#39;data&#39;</span><span class=p>:</span> <span class=n>binascii</span><span class=o>.</span><span class=n>hexlify</span><span class=p>(</span><span class=n>encrypted_data</span><span class=p>),</span> <span class=s1>&#39;signature&#39;</span><span class=p>:</span> <span class=n>binascii</span><span class=o>.</span><span class=n>hexlify</span><span class=p>(</span><span class=n>signature</span><span class=p>)})</span>
	
	<span class=c1>#10 seconds before reading temperature again</span>
	<span class=n>time</span><span class=o>.</span><span class=n>sleep</span><span class=p>(</span><span class=mi>10</span><span class=p>)</span>
</code></pre></div><h4 id=sending-encrypted-temperature-data-to-aws>Sending Encrypted Temperature Data to AWS</h4><p>Because AWS' sdk doesn&rsquo;t support TLS connection over OpenSSL engines, which is required since we don&rsquo;t keep the private key in the file system, we will be using CURL to make HTTPS requests to AWS using Zymkey&rsquo;s embedded private key. We will be using PyCurl to do this programatically, a future post will demonstrate this in C/C++.</p><p><strong>Installing PyCurl</strong></p><p>PyCurl is simply a wrapper on the libssl library for C/C++. So they must be installed and configured with OpenSSL, you can do this with the following commands.</p><pre><code>sudo apt-get install libcurl4-openssl-dev

sudo apt-get install libssl-dev

sudo pip install pycurl
</code></pre><p><strong>Registering Zymkey device Certificate</strong></p><p>Connecting to and Publishing data to AWS IoT requries you to present a valid certificate that has been regsitered with your AWS account. You can find how how to do this by following my <a href=https://docs.zymbit.com/tutorials/aws-iot/tls/>post here</a>. Make sure that the certificate has a policy attached to allow data publication on AWS, if you follow the post completely this should be done.</p><p>You don&rsquo;t need to specifically use your Zymkey public/private key pair for the device certificate, but it would be a good idea to do so to implement an extra layer of private key security.</p><p><strong>Publishing data to AWS IoT</strong></p><p>The following code will publish data to AWS IoT using PyCurl. It does the same thing as publishing data using CURL in my post on publishing data to AWS IoT, but let&rsquo;s you use Python to automate data publication.</p><p><strong>Make sure to find and change your AWS IoT endpoint in the following code, information on how to do this can be found in the tutorial linked above.</strong></p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=kn>import</span> <span class=nn>json</span>
<span class=kn>import</span> <span class=nn>ecdsa</span>
<span class=kn>import</span> <span class=nn>hashlib</span>
<span class=kn>import</span> <span class=nn>pycurl</span>
	
<span class=k>def</span> <span class=nf>ZK_AWS_Publish</span><span class=p>(</span><span class=n>url</span><span class=p>,</span> <span class=n>post_field</span><span class=p>,</span> <span class=n>CA_Path</span><span class=p>,</span> <span class=n>Cert_Path</span><span class=p>,):</span>
	<span class=c1>#Setting Curl to use zymkey_ssl engine</span>
	<span class=n>c</span> <span class=o>=</span> <span class=n>pycurl</span><span class=o>.</span><span class=n>Curl</span><span class=p>()</span>
	<span class=n>c</span><span class=o>.</span><span class=n>setopt</span><span class=p>(</span><span class=n>c</span><span class=o>.</span><span class=n>SSLENGINE</span><span class=p>,</span> <span class=s2>&#34;zymkey_ssl&#34;</span><span class=p>)</span>
	<span class=n>c</span><span class=o>.</span><span class=n>setopt</span><span class=p>(</span><span class=n>c</span><span class=o>.</span><span class=n>SSLENGINE_DEFAULT</span><span class=p>,</span> <span class=il>1L</span><span class=p>)</span>
	<span class=n>c</span><span class=o>.</span><span class=n>setopt</span><span class=p>(</span><span class=n>c</span><span class=o>.</span><span class=n>SSLVERSION</span><span class=p>,</span> <span class=n>c</span><span class=o>.</span><span class=n>SSLVERSION_TLSv1_2</span><span class=p>)</span>
	
	<span class=c1>#Settings certificates for HTTPS connection</span>
	<span class=n>c</span><span class=o>.</span><span class=n>setopt</span><span class=p>(</span><span class=n>c</span><span class=o>.</span><span class=n>SSLENGINE</span><span class=p>,</span> <span class=s2>&#34;zymkey_ssl&#34;</span><span class=p>)</span>
	<span class=n>c</span><span class=o>.</span><span class=n>setopt</span><span class=p>(</span><span class=n>c</span><span class=o>.</span><span class=n>SSLCERTTYPE</span><span class=p>,</span> <span class=s2>&#34;PEM&#34;</span><span class=p>)</span>
	<span class=n>c</span><span class=o>.</span><span class=n>setopt</span><span class=p>(</span><span class=n>c</span><span class=o>.</span><span class=n>SSLCERT</span><span class=p>,</span> <span class=n>Cert_Path</span><span class=p>)</span>
	<span class=n>c</span><span class=o>.</span><span class=n>setopt</span><span class=p>(</span><span class=n>c</span><span class=o>.</span><span class=n>CAINFO</span><span class=p>,</span> <span class=n>CA_Path</span>
	
	<span class=c1>#setting endpoint and HTTPS type, here it is a POST</span>
	<span class=n>c</span><span class=o>.</span><span class=n>setopt</span><span class=p>(</span><span class=n>c</span><span class=o>.</span><span class=n>URL</span><span class=p>,</span> <span class=n>url</span><span class=p>)</span>
	<span class=n>c</span><span class=o>.</span><span class=n>setopt</span><span class=p>(</span><span class=n>c</span><span class=o>.</span><span class=n>POSTFIELDS</span><span class=p>,</span> <span class=n>post_field</span><span class=p>)</span>
	
	<span class=c1>#Telling Curl to do client and host authentication</span>
	<span class=n>c</span><span class=o>.</span><span class=n>setopt</span><span class=p>(</span><span class=n>c</span><span class=o>.</span><span class=n>SSL_VERIFYPEER</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span>
	<span class=n>c</span><span class=o>.</span><span class=n>setopt</span><span class=p>(</span><span class=n>c</span><span class=o>.</span><span class=n>SSL_VERIFYHOST</span><span class=p>,</span> <span class=mi>2</span><span class=p>)</span>
	
	<span class=c1>#Turn on Verbose output and set key as placeholder, not actually a real file.</span>
	<span class=n>c</span><span class=o>.</span><span class=n>setopt</span><span class=p>(</span><span class=n>c</span><span class=o>.</span><span class=n>VERBOSE</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span>
	<span class=n>c</span><span class=o>.</span><span class=n>setopt</span><span class=p>(</span><span class=n>c</span><span class=o>.</span><span class=n>SSLKEYTYPE</span><span class=p>,</span> <span class=s2>&#34;ENG&#34;</span><span class=p>)</span>	
	<span class=n>c</span><span class=o>.</span><span class=n>setopt</span><span class=p>(</span><span class=n>c</span><span class=o>.</span><span class=n>SSLKEY</span><span class=p>,</span> <span class=s2>&#34;nonzymkey.key&#34;</span><span class=p>)</span>
	<span class=p>)</span>

	<span class=n>c</span><span class=o>.</span><span class=n>perform</span><span class=p>()</span>

<span class=k>if</span> <span class=n>name</span> <span class=o>==</span> <span class=s1>&#39;__main__&#39;</span><span class=p>:</span>
		<span class=s1>&#39;&#39;&#39;
</span><span class=s1>		Add the above two snippets of Python code so that we have temperature data formatted into JSON format. Then we will simply submit a HTTPS POST request to AWS IoT endpoint publishing the JSON string.
</span><span class=s1>		&#39;&#39;&#39;</span>
		
		<span class=s1>&#39;&#39;&#39;
</span><span class=s1>		json_data which is being published is the JSON string created in the previous code. Also make sure to point to correct certificate paths, they can be either absolute or relative.
</span><span class=s1>		&#39;&#39;&#39;</span>
		
		<span class=n>AWS_ENDPOINT</span> <span class=o>=</span> <span class=s1>&#39;https://ar21wpwmha9rv.iot.us-west-2.amazonaws.com:8443/topics/pub_key_validate?qos=1&#39;</span>
		<span class=n>ZK_AWS_Publish</span><span class=p>(</span><span class=n>url</span><span class=o>=</span><span class=n>AWS_ENDPOINT</span><span class=p>,</span> <span class=n>post_field</span><span class=o>=</span><span class=n>json_data</span><span class=p>,</span> <span class=n>CA_Path</span><span class=o>=</span><span class=s1>&#39;/home/pi/Desktop/AWS_CA.pem&#39;</span><span class=p>,</span> <span class=n>Cert_Path</span><span class=o>=</span><span class=s1>&#39;/home/pi/Desktop/zymkey.crt&#39;</span><span class=p>)</span>
</code></pre></div><h4 id=checking-data-is-being-published-to-aws-iot>Checking Data is being published to AWS IoT</h4><p>If all the previous steps have been done correctly, then you should be able to see the JSON string you published on the AWS IoT console. It will be published to the topic <strong>pub_key_validate</strong>. This is encoded in the endpoint link you can see in the code. The topic can be changed to whatever you want. <strong>Here&rsquo;s how to check the data from the AWS IoT console</strong> .</p><ol><li>From the <strong>AWS console</strong>, select <strong>AWS IoT</strong>.</li><li>On the <strong>left hand bar</strong>, select <strong>Test</strong>.</li><li>Under <strong>subscription topic</strong>, write <strong>pub_key_validate</strong> and hit <strong>subscribe</strong>.</li><li>You should see your data being shown as it is being published.</li></ol><h4 id=verifying-signature-of-encrypted-data-with-zymkey-public-key-on-aws>Verifying Signature of Encrypted Data with Zymkey Public Key on AWS</h4><p><strong>Signature Verification Lambda function</strong>
Below is the AWS Lambda function that will validate Zymkey signatures. An AWS Lambda function is simply code that will run on the cloud based on a configured trigger. For this demonstration, the trigger will be data published to a specific topic, pub_key_validate, on AWS IoT. From there the lambda function can validate signatures and talk with any other AWS service.</p><p>The function is written in terms of a lambda_handler. The <strong>event</strong> that it gets passed is simply the JSON string published to AWS IoT, the Python lambda context automatically converts <strong>event</strong> from a JSON string to Python dictionary.</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=kn>import</span> <span class=nn>ecdsa</span>
<span class=kn>import</span> <span class=nn>json</span>
<span class=kn>import</span> <span class=nn>hashlib</span>

<span class=k>def</span> <span class=nf>verify_ecdsa_signature</span><span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=n>sig</span><span class=p>,</span> <span class=n>pub_key</span><span class=p>):</span>
	<span class=n>vk</span> <span class=o>=</span> <span class=n>ecdsa</span><span class=o>.</span><span class=n>VerifyingKey</span><span class=o>.</span><span class=n>from_string</span><span class=p>(</span><span class=n>pub_key</span><span class=p>,</span> <span class=n>ecdsa</span><span class=o>.</span><span class=n>NIST256p</span><span class=p>)</span>
	<span class=k>return</span> <span class=n>vk</span><span class=o>.</span><span class=n>verify</span><span class=p>(</span><span class=n>sig</span><span class=p>,</span> <span class=n>data</span><span class=p>,</span> <span class=n>hashfunc</span><span class=o>=</span><span class=n>hashlib</span><span class=o>.</span><span class=n>sha256</span><span class=p>)</span>

<span class=k>def</span> <span class=nf>lambda_handler</span><span class=p>(</span><span class=n>event</span><span class=p>,</span> <span class=n>context</span><span class=p>):</span>
	<span class=c1>#event is already converted from json-&gt;python dict</span>
	<span class=n>pub_key_byte</span> <span class=o>=</span> <span class=nb>bytearray</span><span class=o>.</span><span class=n>fromhex</span><span class=p>(</span><span class=s1>&#39;9929a80b1d2e1543992dc767f394d1859bc33e9b241203f53473d859e1506f7ee5593b53a7fe7014aecc1f14886e1440e6bde27571c596a7ae3d1573e4122d90&#39;</span><span class=p>)</span>
	<span class=n>byte_data</span> <span class=o>=</span> <span class=nb>bytearray</span><span class=o>.</span><span class=n>fromhex</span><span class=p>(</span><span class=n>event</span><span class=p>[</span><span class=s1>&#39;data&#39;</span><span class=p>])</span>
	<span class=n>byte_signature</span> <span class=o>=</span> <span class=nb>bytearray</span><span class=o>.</span><span class=n>fromhex</span><span class=p>(</span><span class=n>event</span><span class=p>[</span><span class=s1>&#39;signature&#39;</span><span class=p>])</span>
	<span class=n>success_message</span> <span class=o>=</span> <span class=s1>&#39;Signature is authenticated against public key and data presented; it is valid.&#39;</span>
	<span class=n>fail_message</span> <span class=o>=</span> <span class=s1>&#39;Signature authentication has failed.&#39;</span>
	<span class=k>if</span> <span class=n>verify_ecdsa_signature</span><span class=p>(</span><span class=n>data</span><span class=o>=</span><span class=n>byte_data</span><span class=p>,</span> <span class=n>sig</span><span class=o>=</span><span class=n>byte_signature</span><span class=p>,</span> <span class=n>pub_key</span><span class=o>=</span><span class=n>pub_key_byte</span><span class=p>):</span>
	    <span class=k>print</span><span class=p>(</span><span class=n>success_message</span><span class=p>)</span>
	    <span class=k>return</span> <span class=n>success_message</span>
	<span class=k>else</span><span class=p>:</span>
	    <span class=k>print</span><span class=p>(</span><span class=n>fail_message</span><span class=p>)</span>
	    <span class=k>return</span> <span class=n>fail_message</span>
</code></pre></div><p><strong>Setting up Lambda function on AWS</strong></p><p>The lambda function is the python code that actually validates your Zymkey signature. The data in JSON format will be published to AWS IoT, and then routed to the lambda function. This is triggered by an IoT rule. This basic lambda function will take the JSON string, validate the data using the Python-ECDSA package, and then print and log its success status.</p><p><strong>To set up the lambda function on AWS, we must first package the code with the ECDSA package, since it is not part of the Python STL. To do this we zip up the lambda code with the ECDSA package in the build directory.</strong></p><p><strong>Packaging function with Python-ECDSA</strong></p><p>You can download a pre-configured zip file with Python-ECDSA included here. You can modify the lambda function however you want here, but make sure you change the public key in particular if you want to test out simple validation. <strong>If you change the lambda function make sure it is changed inside the zip file.</strong></p><p>Otherwise just <strong>zip up the lambda function</strong> with the <strong>ecdsa directory</strong> you made in the <strong>build directory</strong>. You can do this by first cloning the Github repository. Then build the project by running this build command while inside the project directory.</p><pre><code> python setup.py build
</code></pre><p>Find the <strong>ecdsa</strong> directory inside the <strong>build</strong> directory, and zip up that directory with your code.</p><p><strong>Now, follow these steps to upload and activate your code on AWS:</strong></p><ol><li>From the <strong>AWS Console</strong>, select <strong>Lambda</strong></li><li>Select the orange <strong>Create function</strong> button</li><li>Choose to <strong>Author from Scratch</strong></li><li>Click <strong>next</strong>, the trigger will be configured later.</li><li>Give the Lambda function an appropriate <strong>Name</strong> and <strong>Description</strong>. Select <strong>Python 2.7</strong> as the <strong>Runtime</strong>.</li><li>Under <strong>Code entry type</strong>, choose to <strong>Upload a .ZIP file</strong></li><li>Upload your <strong>Zip file</strong>, making sure you have <strong>adjusted the public key for the lambda</strong>.</li><li>For <strong>Handler</strong> make sure to change it to <strong>Signature_Validation_Lambda.lambda_handler</strong></li><li>Choose to <strong>Create A Role</strong> if you don&rsquo;t already have one with basic logging privileges.</li><li>Give it an appropriate name and choose a <strong>policy template</strong>, picking <strong>basicedgelambda</strong>.</li><li>Finally, click <strong>next</strong> and then <strong>create function</strong>.</li></ol><p><strong>Testing Lambda function is working properly</strong></p><p>AWS' lambda function can be given sample JSON input to test the function. So what we can do is create data and sign it with Zymkey then convert it to a hex string locally, and then copy these strings as input into the lambda function. If the public key in the lambda function you set up is the complement to your Zymkey, it will validate correctly. Here we will use python to print out the JSON string we need.</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=kn>import</span> <span class=nn>zymkey</span>
<span class=kn>import</span> <span class=nn>binascii</span>
<span class=kn>import</span> <span class=nn>json</span>

<span class=n>data</span> <span class=o>=</span> <span class=nb>bytearray</span><span class=p>(</span><span class=s1>&#39;hello world~&#39;</span><span class=p>)</span>
<span class=n>signature</span> <span class=o>=</span> <span class=n>zymkey</span><span class=o>.</span><span class=n>client</span><span class=o>.</span><span class=n>sign</span><span class=p>(</span><span class=n>data</span><span class=p>)</span>
<span class=n>python_dictionary</span> <span class=o>=</span> <span class=p>{</span><span class=s1>&#39;data&#39;</span><span class=p>:</span> <span class=n>data</span><span class=p>,</span> <span class=s1>&#39;signature&#39;</span><span class=p>:</span> <span class=n>signature</span><span class=p>}</span>
<span class=k>print</span><span class=p>(</span><span class=n>json</span><span class=o>.</span><span class=n>dumps</span><span class=p>(</span><span class=n>python_dictionary</span><span class=p>))</span>
</code></pre></div><p>Copy the output string, you will need to paste it onto the AWS test inputs. From the AWS Lambda console, select your lambda function and click <strong>Test</strong>. Paste your JSON string as the input. It should <strong>return and print a success message</strong>.</p><p><strong>Creating AWS IoT Rule</strong></p><p>The final step is to create a trigger for the Lambda function. Here we will make a Rule in AWS IoT, so that all data published to pub_key_readings are routed to and trigger your Lambda function.</p><ol><li>From your <strong>AWS Console</strong>, click on the <strong>AWS IoT service</strong>.</li><li>On the left hand side, select <strong>Rules</strong> and then click the blue <strong>Create button</strong>.</li><li>Give it an <strong>appropriate Name and Description</strong>.</li><li>Using <strong>SQL version 2016-03-23</strong> use the following settings:</li></ol><pre><code>Attribute: *
Topic Filter: pub_key_reading
</code></pre><p>Set it to trigger a lambda function, and select the lambda function you created for signature validation.</p><p><strong>Seeing it all in Action</strong>
The whole data pipeline goes like this:
<strong>python collects data -> zymkey signs data -> python packages data to json -> pycurl publish data to AWS IoT -> AWS IoT rule routs data and triggers lambda -> Lambda validates signature and logs the success/failure.</strong></p><p>If you&rsquo;ve tested that data is being published and the lambda function is working properly, it should all work when you run the program to publish data.</p><p>From your AWS Console, select <strong>CloudWatch</strong>. Under <strong>Logs</strong> you shoud see something like <strong>/aws/lambda/Signature_Validation</strong>. Check the logs for proper validation, if you have no logs chances are your AWS IoT rule is not routing the data properly. If data is being published and no logs appear, check your rule is configured properly.</p><div class="text-muted mt-5 pt-3 border-top"></div></div></main></div></div><footer class="bg-dark py-5 row d-print-none"><div class="container-fluid mx-sm-5"><div class=row><div class="col-6 col-sm-4 text-xs-center order-sm-2"></div><div class="col-6 col-sm-4 text-right text-xs-center order-sm-3"></div><div class="col-12 col-sm-4 text-center py-2 order-sm-2"></div></div></div></footer></div><script src=https://cdn.jsdelivr.net/npm/popper.js@1.16.1/dist/umd/popper.min.js integrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js integrity=sha384-+YQ4JLhjyBLPDQt//I+STsc9iw4uQqACwlvpslubQzn4u2UU2UFM80nGisd026JF crossorigin=anonymous></script><script src=/js/main.min.2ba2da7d2fe4be755f96e1f7760bcc4a769c4b9369d2356a8872050735635419.js integrity="sha256-K6LafS/kvnVfluH3dgvMSnacS5Np0jVqiHIFBzVjVBk=" crossorigin=anonymous></script></body></html>