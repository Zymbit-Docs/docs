[{"body":"Welcome to Zymbit’s Documentation Site! Here, you will find all the resources you need to learn about and to use all Zymbit products.\nNEWS 1/22/2023 - We recently pushed up a new, common code base (RC-23.01) that works for all Zymbit products. This adds support for our Secure Compute Module in the main code repository, as well as support for Bullseye 64-bit and Ubuntu 22.04LTS Jammy, and bug fixes, etc. Details can be found on the General Troubleshooting page.\n","categories":"","description":"","excerpt":"Welcome to Zymbit’s Documentation Site! Here, you will find all the …","ref":"/","tags":"","title":"Zymbit Documentation"},{"body":"","categories":"","description":"","excerpt":"","ref":"/getting-started/","tags":"","title":"Getting Started"},{"body":"The Zymkey App Utils library provides an API which allows user space applications to incorporate Zymkey’s cryptographic features, including:\nGeneration of random numbers Locking and unlocking of data objects ECDSA signature generation and verification In addition, the Zymkey App Utils library provides interfaces for administrative functions, such as:\nControl of the LED Setting the i2c address (i2c units only) Setting the tap detection sensitivity A Note About Files Some of the interfaces can take a filename as an argument. The following rules must be observed when using these interfaces:\nAbsolute path names must be provided. For destination filenames, the permissions of the path (or existing file) must be set: Write permissions for all. Write permissions for common group: in this case, user zymbit must be added to the group that has permissions for the destination directory path and/or existing file. Destination path must be fully owned by user and/or group zymbit. Similar rules exist for source filenames: Read permissions for all. Read permissions for common group: in this case, user zymbit must be added to the group that has permissions for the source directory path and/or existing file. Source path must be fully owned by user and/or group zymbit. Crypto Features Random Number Generation This feature is useful when the default host random number generator is suspected of having cryptographic weakness. It can also be used to supplement existing random number generation sources. Zymkey bases its random number generation on an internal TRNG (True Random Number Generator) and performs well under Fourmilab’s ent.\nData Locker Zymkey includes a feature, called Data Locking. This feature is essentially an AES encryption of the data block followed by an ECDSA signature trailer.\nData Locker Keys In addition to a unique ECDSA private/public key pair, each Zymkey has two unique AES keys that are programmed at the factory.\nECDSA Operations Each Zymkey comes out of the factory with three (Zymkey 4i/HSM4) or 12 (HSM6) unique ECDSA private/public key pairs. These private keys are randomly programmed within hardware at the time of manufacture and never exported. In fact, Zymbit doesn’t even know what the value of the private keys are.\nThere are three ECDSA operations available:\nGenerate signature: The Zymkey is capable of generating an ECDSA signature. Verification signature: The Zymkey is capable of verifying an ECDSA signature. Export the ECDSA public key: This saves the public key to a file in PEM format. This operation is useful for generating a Certificate Signing Request (CSR). Other Features LED The Zymkey has an LED which can be turned on, off or flashed at an interval.\ni2c Address For Zymkeys with an i2c interface, the base address can be changed to work around addressing conflicts. The default address is 0x30, but can be changed in the ranges 0x30 - 0x37 and 0x60 - 0x67.\nTap Sensitivity The Zymkey has an accelerometer which can perform tap detection. The sensitivity of the tap detection is configurable.\nProgramming Language Support Currently, C, C++ and Python are supported.\nBinding Before a Zymkey can be effectively used on a host computer, it must be “bound” to it. Binding is a process where a “fingerprint” is made which is composed of the host computer and its SD card serial numbers as well as the Zymkey serial number. If the host computer or SD card is changed from the time of binding, the Zymkey will refuse to accept commands.\nTo learn more about binding your zymkey, go to the Zymbit Community “Getting Started” page for your Zymkey model (e.g. Getting Started with ZYMKEY).\nHSM4 Soft Bind Lock Unlike Zymkey, HSM4 does not have a physical lock tab that is cut to lock the host binding. Instead, it has a software API for locking the binding to the host. See the soft bind lock API description for more information.\nHSM6 Soft Bind Lock See “HSM4: Soft Bind Lock” above.\nECDH ECDH with some Key Derivation Functions (KDFs) is available. The available KDFs include:\nnone: The raw pre-master secret is returned. rfc5869: This KDF can be invoked with SHA256 or SHA512 as the hashing function. pbkdf2: Like rfc5869, SHA256 or SHA512 can be specified. Koblitz Curve Support In addition to NIST P-256 which is available on Zymkey and HSM4, the Koblitz 256 bit curve is available as well.\nMore Key Slots HSM6 now has 12 factory pre-configured NIST P-256 key slots and 512 key pairs for generated key pair and digital wallet allocation for NIST P-256 or Koblitz 256. All of these key slots can be used for ECDSA as well as ECDH operations. It is also possible to remove the keys in the 512 key pair store and also prohibit public key export.\nForeign Public Keyring 128 public key slots are available to form a public key store for storing foreign party public keys. Like the 512 key pair store, public keys can be removed and prohibited from export.\nDigital Wallet HSM6 provides APIs which allow the creation of 1 or more digital wallets per BIP 32/39/44. The number of master seeds and child nodes is only limited by the number of key pairs provided for in the 512 byte key pair store. The BIP 39 feature provides the mnemonic sentence using the 2048 word English dictionary.\nBattery and Temperature Monitoring The HSM6 has APIs for reading the battery voltage as well as monitoring policies for taking action if certain thresholds are exceeded.\nBattery Monitoring The Battery Monitoring feature provides for 1 of 2 actions if the battery voltage below specified threshold (settable from 2.5V or lower via API).\nself-destruct:\nIf the battery voltage goes lower than the threshold, destroy all key material. Good for use cases where a low battery voltage is interpreted as an attempt to attack the low power tamper detect operation. sleep-until-battery-recovery:\nDo not permit full functionality until the battery has gone above the threshold. Good for use cases where battery replacement is desirable. Temperature Monitoring The Temperature Monitoring feature provides protection from attacks that are based on manipulation of temperature (e.g. memory freeze attacks). If invoked, the system may be configured to destroy keys if temperature thresholds are exceeded.\n","categories":"","description":"","excerpt":"The Zymkey App Utils library provides an API which allows user space …","ref":"/api/api_docs_intro/","tags":"","title":"Intro to Zymkey Application Utilities"},{"body":"Scope This section explains the perimeter detect feature on Zymkey4 and how to use it in your software application with a simple two wire loop physical configuration.\nFor alternative physical configurations and best practices: Learn more \u003e\nPerimeter Detect provides two additional layers of physical security that can be used to detect when the perimeter of your device is breached. This is an important feature when devices are deployed in the field, unattended or in high risk environments.\nZymkey4 includes two independent Perimeter Loops that can be configured to meet different applications.\nWhen a Perimeter Loop is breached, Zymkey4 can be configured (at time of binding) to respond with different “Actions”, depending upon your security policy.\nConnecting Perimeter Loop Circuits Zymkey4 uses a standard microUSB connector to interface to perimeter circuits 1 and 2. This is convenient for rapid prototyping and small scale production situations.\n(For high volume applications, different connector types are available. Contact Zymbit for more details.)\nUsing a Standard USB EXTENSION Cable for Perimeter Loop You can use a micro-usb EXTENSION cable, which carries all necessary signals, to connect to the perimeter detect. Here is one example of an extension cable that will work. (Remove the female connector to expose the flying leads as shown below, then connect your perimeter circuits - P1, P2 - to these)\nIMPORTANT: do NOT use standard micro-usb charging cable it will not work, because it does not have a wire on pin 4.\nElectrical Circuit Each perimeter loop should be connected with a 30 AWG wire or thicker and nominal length of 2 feet. For longer lengths contact Zymbit. The wire should be electrically insulated for all applications. A shielded cable may be necessary for electrically noisy or industrial applications.\nCustom flex PCBs and rigid PCBs may also be used to complete a perimeter loop circuit.\nPerimeter Breach Response Actions Prior to permanently binding your Zymkey to a specific host device, it can be configured through the API to respond to a perimeter breach event in one of three ways. After permanent binding is completed, the selected configuration is locked and immutable.\nResponse Choices A) Do nothing (disable) B) Notify host when perimeter breach occurs C) Destroy all key material (this essentially destroys any encrypted data or file system)\nRefer to API documentation for more details.\nTest Perimeter Detect Developer Mode only\nTo quickly test your perimeter detect setup, here are two samples of code using the Python and C API’s. Both programs will wait for one second to detect any perimeter breaches.\nPlease specify the channel (0 or 1) you are testing in either set_perimeter_event_actions or zkSetPerimeterEventAction. Currently the channel is set to 0. In the API, perimeter circuit 2 (as shown in the above images) is defined as channel 1 and perimeter circuit 1 is defined as channel 0.\nFor Python: import zymkey zymkey.client.set_perimeter_event_actions(0, action_notify=True, action_self_destruct=False) try: zymkey.client.wait_for_perimeter_event(timeout_ms=1000) perim_status_str = \"\" idx = 0 plst = zymkey.client.get_perimeter_detect_info() for p in plst: if p: perim_status_str += \"Channel %d breach timestamp = %d\\n\" % (idx, p) idx += 1 print(\"Perimeter breach detected!\\n\" + perim_status_str) except zymkey.exceptions.ZymkeyTimeoutError: print(\"No perimeter breach detected.\") zymkey.client.clear_perimeter_detect_info() For C: #include \u003cstdio.h\u003e #include \"zk_app_utils.h\" void check_code(int code, char* location) { if (code \u003c 0) { printf(\"FAILURE: %s - %d\\n\", location, code); } else if (code \u003e= 0) { printf(\"SUCCESS: %s - %d\\n\", location, code); } } int main() { zkCTX zk_ctx; int status = zkOpen(\u0026zk_ctx); check_code(status, \"zkOpen\"); status = zkSetPerimeterEventAction(zk_ctx, 0, ZK_PERIMETER_EVENT_ACTION_NOTIFY); check_code(status, \"zkSetPerimeterEventAction\"); int p_code = zkWaitForPerimeterEvent(zk_ctx, 1000); check_code(p_code, \"zkWaitForPerimeterEvent\"); uint32_t* timestamps_sec; int num_timestamps; status = zkGetPerimeterDetectInfo(zk_ctx, \u0026timestamps_sec, \u0026num_timestamps); check_code(status, \"zkGetPerimeterDetectInfo\"); //There was a perimeter event/breach. if (p_code == 0) { printf(\"Perimeter breach detected!\\n\"); for(int i=0; i\u003cnum_timestamps; i++) { printf(\"Channel %d breach timestamp = %d\\n\", i, timestamps_sec[i]); } printf(\"\\n\"); } status = zkClearPerimeterDetectEvents(zk_ctx); check_code(status, \"zkClearPerimeterDetectEvents\"); status = zkClose(zk_ctx); check_code(status, \"zkClose\"); return 0; } To compile\ngcc -I /usr/include/zymkey/ -l zk_app_utils \u003cYour Program\u003e If the perimeter is not breached, zkWaitForPerimeterEvent will return a failure code indicating a timeout occurred and no breach was detected.\nSUCCESS: zkOpen - 0 SUCCESS: zkSetPerimeterEventAction - 0 FAILURE: zkWaitForPerimeterEvent - -110 SUCCESS: zkGetPerimeterDetectInfo - 0 SUCCESS: zkClearPerimeterDetectEvents - 0 SUCCESS: zkClose - 0 Perimeter Detect Circuit Examples For best practices and examples of how to physically configure perimeter circuits: Learn more\u003e\nTroubleshooting Troubleshooting\nCommunity\n","categories":"","description":"","excerpt":"Scope This section explains the perimeter detect feature on Zymkey4 …","ref":"/tutorials/perimeter-detect/zymkey4/","tags":"","title":"Perimeter Detect: ZYMKEY4"},{"body":"The HSM4 is a ‘snap in’ security module designed for easy integration within a secure manufacturing environment. All connections are through a single, 30 pin connector that is hidden underneath the module. It is designed specifically to work with Raspberry Pi embedded applications. A PiZero HAT (Hardware Attached on Top) adapter is available for easy integration to the standard GPIO pins of the Pi.\nIn this Getting Started guide we describe how to install your HSM to a Raspberry Pi running Raspbian or Ubuntu. The installation process is the same for both of these Linux distributions.\nHSM4 Hardware Diagram of HSM placement on PiZero HAT\nSummary of Setup Steps Installing the Hardware Install the HSM on the PiZero HAT. Install the battery on the HAT. Connect the HAT to the host single-board computer. Establish an I2C connection Enable the I2C bus on the host device in order to be able to communicate with the HSM. Install the client software These utilities provided by Zymbit are necessary to interact with the hardware module. Test the installation Your HSM is now temporarily bound to your SBC and ready for use in developer mode. Installing the hardware HSM to PiZero HAT Fit your HSM onto the PiZero HAT (Hardware Attached on Top). The connector plugs into the pins on the board.\nBattery Installation Warning Battery installation is not required for the HSM to function, but it is highly recommended if your device is vulnerable to physical access! To maintain the real-time clock (RTC) and tamper detection features in the event of power loss, your PiZero HAT can be fitted with a 3V CR2032 coincell. This battery should last 3-5 years. We recommend using a high quality one like this.\nPrimary Battery Holder (Recommended) IMPORTANT: Note the correct polarity with +ve facing upwards !!\nOptional Battery Connector (Alternative) Caution: Ensure you select the right connector type– Molex 51021-0200-B (1.25mm Pitch). You can purchase the battery here.\nBattery should look like this: Mating component specifications: Plug wired CR2032 battery into optional battery connector, located below. Install Pi HAT with HSM (and battery) Danger Installing your hardware correctly is important to avoid destroying your SBC or PiHAT. Be sure to follow the instructions below carefully. In particular:\nPay close attention to the images below to ensure the SBC’s GPIO pins are properly aligned with the HAT’s header. Ensure that your Raspberry Pi is powered down before proceeding. Ensure that the coincell battery (if installed) is installed with the positive side (marked with +) facing upward. Before installing Power off your Raspberry Pi to ensure that neither the SBC or the PiHAT are damaged.\nAttach hardware Follow the below pictures to position the PiHAT onto your SBC. The HSM and battery should be facing the Raspberry Pi and concealed from view.\nBe sure all the GPIO pins are aligned and have a respective slot. If misaligned, this could cause damage to the HSM, PiHAT, and/or your host device. Once aligned properly, press firmly down onto the header. Your PiHAT should fit relatively snug.\nResources Using an Alternative GPIO Pin The default configuration uses GPIO4. This can be reconfigured to use another GPIO of your choice. Read article Power on and confirm operation Power up the Pi and you will see a blue LED blinking rapidly and consistently (5 blinks per second). This indicates the HSM is operational but not configured.\nIf the blue LED blinks erratically, or not at all, then there is an installation error and you should check your connections.\nResources Power Quality Considerations Power quality matters to the reliable and secure operation of your system and Zymkey. Read article Establish an I2C connection For Raspian-based operating systems, you must configure the state of the I2C.\nLog in to your Raspberry Pi and run sudo raspi-config. Navigate to Interfacing Options -\u003e I2C -\u003e Would you like the ARM I2C interface to be enabled? Select yes, and confirm this choice. Your I2C bus is now configured and ready to talk to the HSM. The default I2C address for the HSM is 0x30.\nResources HSM4 FAQ \u0026 Troubleshooting How do I set an alternative I2C address? The default I2C address for HSM is 0x30. If this conflicts with another device in your system, you can reconfigure the HSM4 to use another address of your choice. Read article Your I2C bus is now on and ready to talk to the HSM.\nNotice The default mode for the cpu scaling governor is ondemand. There have been some issues with the interaction between the HSM and the I2C bus, when the governor is set to ondemand. We highly recommend to switching the governor to performance to get the most out of the HSM.\nResources CPU Scaling Governor How to set cpu governor to performance. Read article Install the client software Login to your host device and follow these steps to install the HSM’s client software.\nThe HSM will require a number of packages to be installed from the Raspbian and Zymbit apt repositories. The following setup script will be install a number of files and software packages on your system, including:\nZymbit .service files located in the /etc/systemd/system directory pip Ensure that curl is installed on your host:\nsudo apt install curl\nDownload and install the necessary Zymbit services onto your device.\ncurl -G https://s3.amazonaws.com/zk-sw-repo/install_zk_sw.sh | sudo bash\nTest the installation When the software installation has completed, the script will automatically reboot your device. After the reboot has completed, the Pi will perform an operation that will temporarily bind the HSM to your SBC. Once the HSM is bound to the SBC, the HSM’s blue LED should blink slowly–once every 3 seconds–to indicate that the binding is complete.\nResources Binding, Device ID, and Authentication In production mode, HSM generates a unique Device ID by measuring certain attributes of the specific host and the HSM itself to permanently associate the two. Read article The quickest way to get started is to see the HSM’s various features at work by running these test scripts that were installed with the client software:\npython3 /usr/local/share/zymkey/examples/zk_app_utils_test.py python3 /usr/local/share/zymkey/examples/zk_crypto_test.py\nThe example scripts are missing in focal and bullseye distributions. You can get the example scripts from here:\nDownload example files\nNow you’re ready to start developing with HSM and Raspberry Pi. When it’s time to deploy your project, read our guide on enabling Production Mode:\nResources Enabling Production Mode - HSM4 To permanently bind the HSM to a host board, generates a unique Device ID by measuring certain attributes of the host and the HSM itself to associate the two devices. Read article ","categories":"","description":"","excerpt":"The HSM4 is a ‘snap in’ security module designed for easy integration …","ref":"/getting-started/hsm4/quickstart/","tags":"","title":"Quickstart - HSM4"},{"body":"The HSM6 is a ‘snap in’ security module designed for easy integration within a secure manufacturing environment. All connections are through a single, 30 pin connector that is hidden underneath the module. It is designed specifically to work with Raspberry Pi embedded applications. A PiZero HAT (Hardware Attached on Top) adapter is available for easy integration to the standard GPIO pins of the Pi.\nIn this Getting Started guide we describe how to install your HSM to a Raspberry Pi running Raspbian or Ubuntu. The installation process is the same for both of these Linux distributions.\nHSM6 Hardware Diagram of HSM placement on PiZero HAT\nSummary of Setup Steps Installing the Hardware Install the HSM on the PiZero HAT. Install the battery on the HAT. Connect the HAT to the host single-board computer. Establish an I2C connection Enable the I2C bus on the host device in order to be able to communicate with the HSM. Install the client software These utilities provided by Zymbit are necessary to interact with the hardware module. Test the installation Your HSM is now temporarily bound to your SBC and ready for use in developer mode. Installing the hardware HSM to PiZero HAT Fit your HSM onto the PiZero HAT (Hardware Attached on Top). The connector plugs into the pins on the board.\nBattery Installation Warning Battery installation is not required for the HSM to function, but it is highly recommended if your device is vulnerable to physical access! To maintain the real-time clock (RTC) and tamper detection features in the event of power loss, your PiZero HAT can be fitted with a 3V CR2032 coincell. This battery should last 3-5 years. We recommend using a high quality one like this.\nPrimary Battery Holder (Recommended) IMPORTANT: Note the correct polarity with +ve facing upwards !!\nOptional Battery Connector (Alternative) Caution: Ensure you select the right connector type– Molex 51021-0200-B (1.25mm Pitch). You can purchase the battery here.\nBattery should look like this: Mating component specifications: Plug wired CR2032 battery into optional battery connector, located below. Install Pi HAT with HSM (and battery) Danger Installing your hardware correctly is important to avoid destroying your SBC or PiHAT. Be sure to follow the instructions below carefully. In particular:\nPay close attention to the images below to ensure the SBC’s GPIO pins are properly aligned with the HAT’s header. Ensure that your Raspberry Pi is powered down before proceeding. Ensure that the coincell battery (if installed) is installed with the positive side (marked with +) facing upward. Before installing Power off your Raspberry Pi to ensure that neither the SBC or the PiHAT are damaged.\nAttach hardware Follow the below pictures to position the PiHAT onto your SBC. The HSM and battery should be facing the Raspberry Pi and concealed from view.\nBe sure all the GPIO pins are aligned and have a respective slot. If misaligned, this could cause damage to the HSM, PiHAT, and/or your host device. Once aligned properly, press firmly down onto the header. Your PiHAT should fit relatively snug.\nResources Using an Alternative GPIO Pin The default configuration uses GPIO4. This can be reconfigured to use another GPIO of your choice. Read article Power on and confirm operation Power up the Pi and you will see a blue LED blinking rapidly and consistently (5 blinks per second). This indicates the HSM is operational but not configured.\nIf the blue LED blinks erratically, or not at all, then there is an installation error and you should check your connections.\nResources Power Quality Considerations Power quality matters to the reliable and secure operation of your system and Zymkey. Read article Establish an I2C connection For Raspian-based operating systems, you must configure the state of the I2C.\nLog in to your Raspberry Pi and run sudo raspi-config. Navigate to Interfacing Options -\u003e I2C -\u003e Would you like the ARM I2C interface to be enabled? Select yes, and confirm this choice. Your I2C bus is now configured and ready to talk to the HSM. The default I2C address for the HSM is 0x30.\nResources HSM6 FAQ \u0026 Troubleshooting How do I set an alternative I2C address? The default I2C address for HSM is 0x30. If this conflicts with another device in your system, you can reconfigure the HSM6 to use another address of your choice. Read article Your I2C bus is now on and ready to talk to the HSM.\nNotice The default mode for the cpu scaling governor is ondemand. There have been some issues with the interaction between the HSM and the I2C bus, when the governor is set to ondemand. We highly recommend to switching the governor to performance to get the most out of the HSM.\nResources CPU Scaling Governor How to set cpu governor to performance. Read article Install the client software Login to your host device and follow these steps to install the HSM’s client software.\nThe HSM will require a number of packages to be installed from the Raspbian and Zymbit apt repositories. The following setup script will be install a number of files and software packages on your system, including:\nZymbit .service files located in the /etc/systemd/system directory pip Ensure that curl is installed on your host:\nsudo apt install curl\nDownload and install the necessary Zymbit services onto your device.\ncurl -G https://s3.amazonaws.com/zk-sw-repo/install_zk_sw.sh | sudo bash\nTest the installation When the software installation has completed, the script will automatically reboot your device. After the reboot has completed, the Pi will perform an operation that will temporarily bind the HSM to your SBC. Once the HSM is bound to the SBC, the HSM’s blue LED should blink slowly–once every 3 seconds–to indicate that the binding is complete.\nResources Binding, Device ID, and Authentication In production mode, HSM generates a unique Device ID by measuring certain attributes of the specific host and the HSM itself to permanently associate the two. Read article The quickest way to get started is to see the HSM’s various features at work by running these test scripts that were installed with the client software:\npython3 /usr/local/share/zymkey/examples/zk_app_utils_test.py python3 /usr/local/share/zymkey/examples/zk_crypto_test.py\nThe example scripts are missing in focal and bullseye distributions. You can get the example scripts from here:\nDownload example files\nNow you’re ready to start developing with HSM and Raspberry Pi. When it’s time to deploy your project, read our guide on enabling Production Mode:\nResources Enabling Production Mode - HSM6 To permanently bind the HSM to a host board, generates a unique Device ID by measuring certain attributes of the host and the HSM itself to associate the two devices. Read article ","categories":"","description":"","excerpt":"The HSM6 is a ‘snap in’ security module designed for easy integration …","ref":"/getting-started/hsm6/quickstart/","tags":"","title":"Quickstart - HSM6"},{"body":"Scope This describes the perimeter detect feature on HSM4.\nPerimeter Detect provides two additional layers of physical security that can be used to detect when the perimeter of your device is breached. This is an important feature when devices are deployed in the field, unattended or in high risk environments.\nHSM4 includes two independent Perimeter Loops that can be configured to meet different applications.\nWhen a Perimeter Loop is breached, HSM4 can be configured (at time of binding) to respond with different “Actions”, depending upon your security policy.\nConnecting Perimeter Loop Circuits HSM4 HAT provides four pin header and FPC connectors to interface to perimeter circuits 1 and 2. This is convenient for rapid prototyping and small scale production situations.\n(For high volume applications, different connector types are available. Contact Zymbit for more details.)\nElectrical Circuit Each perimeter loop should be connected with a 30 AWG wire or thicker and nominal length of 2 feet. For longer lengths contact Zymbit. The wire should be electrically insulated for all applications. A shielded cable may be necessary for electrically noisy or industrial applications.\nCustom flex PCBs and rigid PCBs may also be used to complete a perimeter loop circuit.\nPerimeter Breach Response Actions Prior to permanently binding your HSM4 to a specific host device, it can be configured through the API to respond to a perimeter breach event in one of three ways. After permanent binding is completed, the selected configuration is locked and immutable.\nResponse Choices A) Do nothing (disable) B) Notify host when perimeter breach occurs C) Destroy all key material (this essentially destroys any encrypted data or file system)\nTest Perimeter Detect Developer Mode only\nTo quickly test your perimeter detect setup, here are two samples of code using the Python and C API’s. Both programs will wait for ten seconds to detect any perimeter breaches. So before running this script, connect the circuits using either the FPC or Pin headers and during the ten second pause in the script, breach the perimeter by unplugging the circuit wires from the Hat. The wait function should immediately exit and the script will finish.\nPlease specify the channel (0 or 1) you are testing in either set_perimeter_event_actions or zkSetPerimeterEventAction. Currently the channel is set to 0. In the API, perimeter circuit 2 (as shown in the above images) is defined as channel 1 and perimeter circuit 1 is defined as channel 0.\nFor Python import zymkey zymkey.client.clear_perimeter_detect_info() zymkey.client.set_perimeter_event_actions(0, action_notify=True, action_self_destruct=False) zymkey.client.wait_for_perimeter_event(timeout_ms=10000) perim_status_str = \"\" idx = 0 plst = zymkey.client.get_perimeter_detect_info() for p in plst: if p: perim_status_str += \"Channel %d breach timestamp = %d\\n\" % (idx, p) idx += 1 print(\"Perimeter breach detected!\\n\" + perim_status_str) For C #include \u003cstdio.h\u003e #include \"zk_app_utils.h\" void check_code(int code, char* location) { if (code \u003c 0) { printf(\"FAILURE: %s - %d\\n\", location, code); } else if (code \u003e= 0) { printf(\"SUCCESS: %s - %d\\n\", location, code); } } int main() { zkCTX zk_ctx; int status = zkOpen(\u0026zk_ctx); check_code(status, \"zkOpen\"); status = zkClearPerimeterDetectEvents(zk_ctx); check_code(status, \"zkClearPerimeterDetectEvents\"); status = zkSetPerimeterEventAction(zk_ctx, 0, ZK_PERIMETER_EVENT_ACTION_NOTIFY); check_code(status, \"zkSetPerimeterEventAction\"); int p_code = zkWaitForPerimeterEvent(zk_ctx, 10000); check_code(p_code, \"zkWaitForPerimeterEvent\"); uint32_t* timestamps_sec; int num_timestamps; status = zkGetPerimeterDetectInfo(zk_ctx, \u0026timestamps_sec, \u0026num_timestamps); check_code(status, \"zkGetPerimeterDetectInfo\"); //There was a perimeter event/breach. if (p_code == 0) { printf(\"Perimeter breach detected!\\n\"); for(int i=0; i\u003cnum_timestamps; i++) { printf(\"Channel %d breach timestamp = %d\\n\", i, timestamps_sec[i]); } printf(\"\\n\"); } status = zkClose(zk_ctx); check_code(status, \"zkClose\"); return 0; } To compile\ngcc -I /usr/include/zymkey/ -l zk_app_utils \u003cYour Program\u003e If the perimeter is not breached, zkWaitForPerimeterEvent will return a failure code indicating a timeout occurred and no breach was detected.\nSUCCESS: zkOpen - 0 SUCCESS: zkSetPerimeterEventAction - 0 FAILURE: zkWaitForPerimeterEvent - -110 SUCCESS: zkGetPerimeterDetectInfo - 0 SUCCESS: zkClearPerimeterDetectEvents - 0 SUCCESS: zkClose - 0 Perimeter Detect Circuit Examples For best practices and examples of how to physically configure perimeter circuits: Learn more\u003e\nTroubleshooting Troubleshooting\nCommunity\n","categories":"","description":"","excerpt":"Scope This describes the perimeter detect feature on HSM4.\nPerimeter …","ref":"/tutorials/perimeter-detect/hsm4/","tags":"","title":"Perimeter Detect: HSM4"},{"body":"Scope This describes the perimeter detect feature on HSM6.\nPerimeter Detect provides two additional layers of physical security that can be used to detect when the perimeter of your device is breached. This is an important feature when devices are deployed in the field, unattended or in high risk environments.\nHSM6 includes two independent Perimeter Loops that can be configured to meet different applications.\nWhen a Perimeter Loop is breached, HSM6 can be configured (at time of binding) to respond with different “Actions”, depending upon your security policy.\nConnecting Perimeter Loop Circuits HSM6 HAT provides four pin header and FPC connectors to interface to perimeter circuits 1 and 2. This is convenient for rapid prototyping and small scale production situations.\n(For high volume applications, different connector types are available. Contact Zymbit for more details.)\nElectrical Circuit Each perimeter loop should be connected with a 30 AWG wire or thicker and nominal length of 2 feet. For longer lengths contact Zymbit. The wire should be electrically insulated for all applications. A shielded cable may be necessary for electrically noisy or industrial applications.\nCustom flex PCBs and rigid PCBs may also be used to complete a perimeter loop circuit.\nPerimeter Breach Response Actions Prior to permanently binding your HSM6 to a specific host device, it can be configured through the API to respond to a perimeter breach event in one of three ways. After permanent binding is completed, the selected configuration is locked and immutable.\nResponse Choices A) Do nothing (disable) B) Notify host when perimeter breach occurs C) Destroy all key material (this essentially destroys any encrypted data or file system)\nTest Perimeter Detect Developer Mode only\nTo quickly test your perimeter detect setup, here are two samples of code using the Python and C API’s. Both programs will wait for ten seconds to detect any perimeter breaches. So before running this script, connect the circuits using either the FPC or Pin headers and during the ten second pause in the script, breach the perimeter by unplugging the circuit wires from the Hat. The wait function should immediately exit and the script will finish.\nPlease specify the channel (0 or 1) you are testing in either set_perimeter_event_actions or zkSetPerimeterEventAction. Currently the channel is set to 0. In the API, perimeter circuit 2 (as shown in the above images) is defined as channel 1 and perimeter circuit 1 is defined as channel 0.\nFor Python import zymkey zymkey.client.clear_perimeter_detect_info() zymkey.client.set_perimeter_event_actions(0, action_notify=True, action_self_destruct=False) zymkey.client.wait_for_perimeter_event(timeout_ms=10000) perim_status_str = \"\" idx = 0 plst = zymkey.client.get_perimeter_detect_info() for p in plst: if p: perim_status_str += \"Channel %d breach timestamp = %d\\n\" % (idx, p) idx += 1 print(\"Perimeter breach detected!\\n\" + perim_status_str) For C #include \u003cstdio.h\u003e #include \"zk_app_utils.h\" void check_code(int code, char* location) { if (code \u003c 0) { printf(\"FAILURE: %s - %d\\n\", location, code); } else if (code \u003e= 0) { printf(\"SUCCESS: %s - %d\\n\", location, code); } } int main() { zkCTX zk_ctx; int status = zkOpen(\u0026zk_ctx); check_code(status, \"zkOpen\"); status = zkClearPerimeterDetectEvents(zk_ctx); check_code(status, \"zkClearPerimeterDetectEvents\"); status = zkSetPerimeterEventAction(zk_ctx, 0, ZK_PERIMETER_EVENT_ACTION_NOTIFY); check_code(status, \"zkSetPerimeterEventAction\"); int p_code = zkWaitForPerimeterEvent(zk_ctx, 10000); check_code(p_code, \"zkWaitForPerimeterEvent\"); uint32_t* timestamps_sec; int num_timestamps; status = zkGetPerimeterDetectInfo(zk_ctx, \u0026timestamps_sec, \u0026num_timestamps); check_code(status, \"zkGetPerimeterDetectInfo\"); //There was a perimeter event/breach. if (p_code == 0) { printf(\"Perimeter breach detected!\\n\"); for(int i=0; i\u003cnum_timestamps; i++) { printf(\"Channel %d breach timestamp = %d\\n\", i, timestamps_sec[i]); } printf(\"\\n\"); } status = zkClose(zk_ctx); check_code(status, \"zkClose\"); return 0; } To compile\ngcc -I /usr/include/zymkey/ -l zk_app_utils \u003cYour Program\u003e If the perimeter is not breached, zkWaitForPerimeterEvent will return a failure code indicating a timeout occurred and no breach was detected.\nSUCCESS: zkOpen - 0 SUCCESS: zkSetPerimeterEventAction - 0 FAILURE: zkWaitForPerimeterEvent - -110 SUCCESS: zkGetPerimeterDetectInfo - 0 SUCCESS: zkClearPerimeterDetectEvents - 0 SUCCESS: zkClose - 0 Perimeter Detect Circuit Examples For best practices and examples of how to physically configure perimeter circuits: Learn more\u003e\nAdditional Self Destruct Policies HSM6 has two additional self destruct policies, independent of Perimeter Detect– temperature and voltage level monitoring. For more information, visit Python documentation or C documentation.\nTroubleshooting Troubleshooting\nCommunity\n","categories":"","description":"","excerpt":"Scope This describes the perimeter detect feature on HSM6.\nPerimeter …","ref":"/tutorials/perimeter-detect/hsm6/","tags":"","title":"Perimeter Detect: HSM6"},{"body":"Scope This describes the perimeter detect feature on SCM.\nPerimeter Detect provides two additional layers of physical security that can be used to detect when the perimeter of your device is breached. This is an important feature when devices are deployed in the field, unattended or in high risk environments.\nThe SCM includes two independent Perimeter Loops that can be configured to meet different applications.\nWhen a Perimeter Loop is breached, SCM can be configured (at time of binding) to respond with different “Actions”, depending upon your security policy.\nConnecting Perimeter Loop Circuits When used in conjunction with the Zymbit SCM I/O motherboard, the first perimeter loop connects to the four switches on the bottom of the motherboard; the second perimeter loop is accessible off the two pins labeled Perimeter on the bottom of the motherboard.\nAlternatively, the SCM has a four pin connector to interface to perimeter circuits 1 and 2. Zymbit can provide an optional Perimeter Detect Cable as shown above for demo purposes. Removing and re-attaching the yellow and blue wires can be used to simulate perimeter events.\nElectrical Circuit Each perimeter loop should be connected with a 30 AWG wire or thicker and nominal length of 2 feet. For longer lengths contact Zymbit. The wire should be electrically insulated for all applications. A shielded cable may be necessary for electrically noisy or industrial applications.\nCustom flex PCBs and rigid PCBs may also be used to complete a perimeter loop circuit.\nPerimeter Breach Response Actions For released product, prior to permanently binding your SCM to a specific host device, it can be configured through the API to respond to a perimeter breach event in one of three ways. After permanent binding is completed, the selected configuration is locked and immutable.\nResponse Choices A) Do nothing (disable)\nB) Notify host when perimeter breach occurs (default as shipped for SCM Beta)\nC) Destroy all key material (this essentially destroys any encrypted data or file system.\nTest Perimeter Detect Developer Mode only\nTo quickly test your perimeter detect setup, here is sample code using the Python API. The program will wait for ten seconds to detect any perimeter breaches. Before running this script, connect the circuits with the provided yellow and blue wires and during the ten second pause in the script, breach the perimeter by unplugging the circuit wires. The wait function should immediately detect the event.\nIn the API, perimeter circuit 2 (as shown in the above images) is defined as channel 1 and perimeter circuit 1 is defined as channel 0. As noted, for SCM Beta, channel 0 and channel 1 have already been set to action_notify=True.\nExample for monitoring Perimeter Events:\nFor Python #!/usr/bin/python3 import zymkey from datetime import datetime import time # Get any existing events, including while powered down with battery in place print(\"Checking for existing events.\") plst = zymkey.client.get_perimeter_detect_info() print(\"Perimeter 1 Timestamp: \" + str(datetime.fromtimestamp(plst[0])) + \" [\" + str(plst[0]) + \"]\") print(\"Perimeter 2 Timestamp: \" + str(datetime.fromtimestamp(plst[1])) + \" [\" + str(plst[1]) + \"]\") # Clear the events print(\"Clearing perimeter detect info...\") zymkey.client.clear_perimeter_detect_info() time.sleep(2) # Loop waiting for events while up and running #while True: while input('Enter or (q)uit: ') != 'q': try: print(\"Waiting 10 secs for an event\") zymkey.client.wait_for_perimeter_event(timeout_ms=10000) plst = zymkey.client.get_perimeter_detect_info() print(\"Perimeter event detected!\") print(\"Perimeter 1 Timestamp: \" + str(datetime.fromtimestamp(plst[0])) + \" [\" + str(plst[0]) + \"]\") print(\"Perimeter 2 Timestamp: \" + str(datetime.fromtimestamp(plst[1])) + \" [\" + str(plst[1]) + \"]\") print(\"Clearing perimeter detect info...\") zymkey.client.clear_perimeter_detect_info() time.sleep(2) except zymkey.exceptions.ZymkeyTimeoutError: print(\"No perimeter event detected. (Timed out)\") Perimeter Detect Circuit Examples For best practices and examples of how to physically configure perimeter circuits: Learn more\u003e\nAdditional Self Destruct Policies SCM has additional self destruct policies independent of Perimeter Detect: Supervised Boot, Low/High Temperature and Low Voltage level monitoring. For more information, visit Python documentation or C documentation.\nTroubleshooting Troubleshooting\nCommunity\n","categories":"","description":"","excerpt":"Scope This describes the perimeter detect feature on SCM.\nPerimeter …","ref":"/tutorials/perimeter-detect/scm/","tags":"","title":"Perimeter Detect: SCM"},{"body":"Scope This describes the perimeter detect feature on the Secure Edge Node (SEN)\nPerimeter Detect provides two additional layers of physical security that can be used to detect when the perimeter of your device is breached. This is an important feature when devices are deployed in the field, unattended or in high risk environments. When a Perimeter Loop is breached, the Secure Edge Node can be configured to respond with different “Actions”, depending upon your security policy.\nConnecting Perimeter Loop Circuits Secure Compute Motherboard Perimeter Loop Circuits The Secure Edge Node includes two independent Perimeter Loops that can be configured to meet different applications. The first perimeter loop connects to the four switches on the bottom of the motherboard. The four switches are in a closed position when the Secure Edge Node enclosure is screwed tightly. Opening the Node will open the switches, opening the first perimeter loop.\nThere is also a four pin connector labeled “Perimeter” on the underside of the IO board. The first perimeter loop can be controlled by the two center pins of the header; the second perimeter loop can be controlled by the outside two pins of the header.\nAccess to the Perimeter Loop Circuits. Use a Torx-T10 screwdriver to loosen the six screws holding the Node enclosure together. Flip over and remove the bottom to access the Perimeter Loop circuits.\nElectrical Circuit Each perimeter loop should be connected with a 30 AWG wire or thicker and nominal length of up to 2 feet. For longer lengths contact Zymbit. The wire should be electrically insulated for all applications. A shielded cable may be necessary for electrically noisy or industrial applications.\nCustom flex PCBs and rigid PCBs may also be used to complete a perimeter loop circuit.\nPerimeter Breach Response Actions Prior to permanently binding your Secure Edge Node to a specific host device, it can be configured through the API to respond to a perimeter breach event in one of three ways. After permanent binding is completed, the selected configuration is locked and immutable.\nResponse Choices Do nothing (disable) Notify host when perimeter breach occurs (default as shipped) Destroy all key material (prevents access to encrypted data or root file system) Test Perimeter Detect Developer Mode only\nTo quickly test your perimeter detect setup, here is sample code using the Python API. The program will wait for ten seconds to detect any perimeter breaches. Before running this script, connect the circuits with the provided yellow and blue wires and during the ten second pause in the script, breach the perimeter by unplugging the circuit wires. The wait function should immediately detect the event.\nIn the API, perimeter circuit 2 (as shown in the above images) is defined as channel 1 and perimeter circuit 1 is defined as channel 0. As shipped, Channel 0 and Channel 1 have been set to action_notify=True.\nExample for monitoring Perimeter Events:\nFor Python #!/usr/bin/python3 import zymkey from datetime import datetime import time # Get any existing events, including while powered down with battery in place print(\"Checking for existing events.\") plst = zymkey.client.get_perimeter_detect_info() print(\"Perimeter 1 Timestamp: \" + str(datetime.fromtimestamp(plst[0])) + \" [\" + str(plst[0]) + \"]\") print(\"Perimeter 2 Timestamp: \" + str(datetime.fromtimestamp(plst[1])) + \" [\" + str(plst[1]) + \"]\") # Clear the events print(\"Clearing perimeter detect info...\") zymkey.client.clear_perimeter_detect_info() time.sleep(2) # Loop waiting for events while up and running #while True: while input('Enter or (q)uit: ') != 'q': try: print(\"Waiting 10 secs for an event\") zymkey.client.wait_for_perimeter_event(timeout_ms=10000) plst = zymkey.client.get_perimeter_detect_info() print(\"Perimeter event detected!\") print(\"Perimeter 1 Timestamp: \" + str(datetime.fromtimestamp(plst[0])) + \" [\" + str(plst[0]) + \"]\") print(\"Perimeter 2 Timestamp: \" + str(datetime.fromtimestamp(plst[1])) + \" [\" + str(plst[1]) + \"]\") print(\"Clearing perimeter detect info...\") zymkey.client.clear_perimeter_detect_info() time.sleep(2) except zymkey.exceptions.ZymkeyTimeoutError: print(\"No perimeter event detected. (Timed out)\") Perimeter Detect Circuit Examples For best practices and examples of how to physically configure perimeter circuits: Learn more\u003e\nAdditional Self Destruct Policies SCM has additional self destruct policies independent of Perimeter Detect: Supervised Boot, Low/High Temperature and Low Voltage level monitoring. For more information, visit Python documentation or C documentation.\nTroubleshooting Troubleshooting Community\n","categories":"","description":"","excerpt":"Scope This describes the perimeter detect feature on the Secure Edge …","ref":"/tutorials/perimeter-detect/sen/","tags":"","title":"Perimeter Detect: Secure Edge Node"},{"body":"ZYMKEY4 is the fourth generation of the Zymbit security module designed specifically to work with Raspberry Pi. It connects to the GPIO header of the SBC and uses the I2C bus and GPIO4 to communicate with the SBC CPU via an encrypted channel.\nIn this Getting Started guide we describe how to install your ZYMKEY4 to a Raspberry Pi running Raspberry PI OS or Ubuntu. The installation process is the same for both of these Linux distributions.\nThe ZYMKEY4 occupies 10 pins on the GPIO header. It can also be used with other GPIO devices attached, or other I2C devices attached. The correct address range and use of IO pins will be described in this guide as well.\nZYMKEY4 Hardware The top and bottom of the ZYMKEY4 hardware showing the location of the GPIO header and other connectors.\nZYMKEY4 Pinout The pinout of the header of the ZYMKEY4. ZYMKEY4 requires exclusive access to GPIO4, which can be remapped to another GPIO pin. It also share the I2C bus with the default address of 0x30.\nSummary of Setup Steps Installing the hardware Install the battery on the ZYMKEY4, and connect it to the host single-board computer (SBC). Establish an I2C connection Enable the I2C bus on the host device in order to be able to communicate with the ZYMKEY4. Install the client software These utilities provided by Zymbit are necessary to interact with the hardware module. Test the installation Your ZYMKEY4 is now temporarily bound to your SBC and ready for use in developer mode. Installing the hardware Battery Installation Warning Battery installation is not required for the ZYMKEY4 to function, but it is highly recommended if your device is vulnerable to physical access! To maintain the real-time clock (RTC) and tamper detection features in the event of power loss, install a high quality 3V CR1025 coincell battery in the ZYMKEY4’s battery slot with +ve facing upward.\nHardware Installation Danger Installing your hardware correctly is important to avoid destroying your SBC or ZYMKEY4. Be sure to follow the instructions below carefully. In particular:\nPay close attention to the images below to ensure the SBC’s GPIO pins are properly aligned with the ZYMKEY4’s header. Ensure that your Raspberry Pi is powered down before proceeding. Ensure that the coincell battery (if installed) is installed with the positive side (marked with +) facing upward. Before installing Power off your Raspberry Pi to ensure that neither the SBC or the ZYMKEY4 are damaged.\nAttach hardware Hold the ZYMKEY4 with the LED and battery holder facing upward. Then, carefully align the ZYMKEY4’s connector with the first 10 GPIO pins of the Raspberry Pi.\nPress down firmly on the ZYMKEY4 to connect it to the GPIO pins of the Raspberry Pi. The ZYMKEY4 should fit relatively snug and maintain a tight interference fit around the pins.\nThe ZYMKEY4 occupies 10 pins on the GPIO header. If the header of the ZYMKEY4 isn’t properly aligned with the GPIO header of the Raspberry Pi, both devices could be damaged.\nResources Using an Alternative GPIO Pin The default configuration uses GPIO4. This can be reconfigured to use another GPIO of your choice. Read article Power on and confirm operation After you have connected the hardware and are sure that the pins are properly aligned, power up your Raspberry Pi. You should see a blue LED blinking rapidly and consistently (5 blinks per second). This confirms that your ZYMKEY4 is operation but unconfigured.\nIf the blue LED blinks erractically, or not at all, then there is an installation error and you should check the connections.\nResources Power Quality Considerations Power quality matters to the reliable and secure operation of your system and ZYMKEY4. Read article Establish an I2C connection For Raspian-based operating systems, you must configure the state of the I2C.\nLog in to your Raspberry Pi and run sudo raspi-config. Navigate to Interfacing Options -\u003e I2C -\u003e Would you like the ARM I2C interface to be enabled? Select yes, and confirm this choice. Your I2C bus is now configured and ready to talk to the ZYMKEY4. The default I2C address for the ZYMKEY4 is 0x30.\nResources ZYMKEY4 FAQ \u0026 Troubleshooting How do I set an alternative I2C address? The default I2C address for ZYMKEY4 is 0x30. If this conflicts with another device in your system, you can reconfigure the ZYMKEY4 to use another address of your choice. Read article Notice The default mode for the cpu scaling governor is ondemand. There have been some issues with the interaction between the zymkey and the I2C bus, when the governor is set to ondemand. We highly recommend to switching the governor to performance to get the most out of the zymkey.\nResources CPU Scaling Governor How to set cpu governor to performance. Read article Install the client software Login to your host device and follow these steps to install the ZYMKEY4’s client software.\nThe ZYMKEY4 will require a number of packages to be installed from the Raspbian and Zymbit apt repositories. The following setup script will be install a number of files and software packages on your system, including:\nZymbit .service files located in the /etc/systemd/system directory pip Ensure that curl is installed on your host:\nsudo apt install curl\nDownload and install the necessary Zymbit services onto your device.\ncurl -G https://s3.amazonaws.com/zk-sw-repo/install_zk_sw.sh | sudo bash\nTest the installation When the software installation has completed, reboot your device. After the reboot has completed, the Raspberry Pi will perform an operation that will temporarily bind the ZYMKEY4 to your SBC. Once the ZYMKEY4 is bound to the SBC, the ZYMKEY4’s blue LED should blink slowly–once every 3 seconds–to indicate that the binding is complete.\nResources Binding, Device ID, and Authentication In production mode, ZYMKEY4 generates a unique Device ID by measuring certain attributes of the specific host and the ZYMKEY4 itself to permanently associate the two. Read article The quickest way to get started is to see the ZYMKEY4’s various features at work by running these test scripts that were installed with the client software:\npython3 /usr/local/share/zymkey/examples/zk_app_utils_test.py\npython3 /usr/local/share/zymkey/examples/zk_crypto_test.py\nThe example scripts are missing in focal and bullseye distributions. You can get the example scripts from here:\nDownload example files\nNow you’re ready to start developing with ZYMKEY4 and Raspberry Pi. When it’s time to deploy your project, read our guide on enabling Production Mode:\nResources Enabling Production Mode - ZYMKEY4 To permanently bind the ZYMKEY4 to a host board, generates a unique Device ID by measuring certain attributes of the host and the ZYMKEY4 itself to associate the two devices. Read article ","categories":"","description":"","excerpt":"ZYMKEY4 is the fourth generation of the Zymbit security module …","ref":"/getting-started/zymkey4/quickstart/","tags":"","title":"Quickstart - ZYMKEY4"},{"body":"EU Secure Compute Module - Declaration of Conformity\nFCC Secure Compute Module - Declaration of Conformity\nEU Secure Compute Motherboard - Declaration of Conformity\nFCC Secure Compute Motherboard - Declaration of Conformity\n","categories":"","description":"","excerpt":"EU Secure Compute Module - Declaration of Conformity\nFCC Secure …","ref":"/reference/conformity/scm/","tags":"","title":"Secure Compute Family Conformity Documents"},{"body":"3D Step Model Zymkey 3D model\n2D Drawing GPIO Pinout ","categories":"","description":"","excerpt":"3D Step Model Zymkey 3D model\n2D Drawing GPIO Pinout ","ref":"/reference/cad/zymkey4/","tags":"","title":"Zymkey4 CAD Files"},{"body":"EU Declaration of Conformity\nFCC Declaration of Conformity\nRoHS/Reach Declaration of Conformity\nCalifornia Prop 65 Declaration of Conformity\n","categories":"","description":"","excerpt":"EU Declaration of Conformity\nFCC Declaration of Conformity\nRoHS/Reach …","ref":"/reference/conformity/zymkey4/","tags":"","title":"Zymkey4 Conformity Documents"},{"body":"Altium Zymbit HSM Library-Altium (728 KB)\nKiCAD (Version 6 only) Zymbit HSM4 Library-KiCAD 6 (221 KB)\n3D Step Model HSM4 Can Assembly REV D 1.1.4 STEP (1.1 MB)\nCAD Graphic Summary ","categories":"","description":"","excerpt":"Altium Zymbit HSM Library-Altium (728 KB)\nKiCAD (Version 6 only) …","ref":"/reference/cad/hsm4/","tags":"","title":"HSM4 CAD Files"},{"body":"EU Declaration of Conformity\nFCC Declaration of Conformity\nRoHS/Reach Declaration of Conformity\nCalifornia Prop 65 Declaration of Conformity\n","categories":"","description":"","excerpt":"EU Declaration of Conformity\nFCC Declaration of Conformity\nRoHS/Reach …","ref":"/reference/conformity/hsm4/","tags":"","title":"HSM4 Conformity Documents"},{"body":"Altium Zymbit HSM Library-Altium (728 KB)\nKiCAD (Version 6 only) Zymbit HSM6 Library-KiCAD 6 (221 KB)\n3D Step Model HSM6 Can Assembly REV D 1.1.4.STEP (1.3 MB)\nCAD Graphic Summary ","categories":"","description":"","excerpt":"Altium Zymbit HSM Library-Altium (728 KB)\nKiCAD (Version 6 only) …","ref":"/reference/cad/hsm6/","tags":"","title":"HSM6 CAD Files"},{"body":"EU Declaration of Conformity\nFCC Declaration of Conformity\nRoHS/Reach Declaration of Conformity\nCalifornia Prop 65 Declaration of Conformity\n","categories":"","description":"","excerpt":"EU Declaration of Conformity\nFCC Declaration of Conformity\nRoHS/Reach …","ref":"/reference/conformity/hsm6/","tags":"","title":"HSM6 Conformity Documents"},{"body":" Overview Secure Edge Node - Zymbit offers a standard baseline enclosure that accommodates Zymbit’s secure motherboard, Secure Compute Module and a choice of accessories.\nSecure Edge Node Feature Description Enclosure Standard Type D35 Enclosure. Fits into standard 3.5″ drive bay caddy Dimensions 1.04 x 3.95 x 5.80 inches, 26 x 100 x 148mm Power 12V Barrel Style (standard) PoE PD (optional) SATA (optional) LEDs CM4 PWR (red), CM4 Activity (green), SCM Status (blue) Front I/O 1x 1GbE LAN 1x HDMI 1x USB-A 2.0 Onboard Headers 1x AUX USB 2.0 2x CSI Camera 1x DSI Display 1x M.2 B-Key 1x 40-pin GPIO header 1x Micro SIM port. For use with compatible M.2 modules. Push-push type connector 1x Battery connector Molex 51021-0200-B (1.25mm Pitch) 1x Zymbit Security Module for HSM4/HSM6 1x 5V Fan Tamper Circuits 4x Switches complete Channel 1 tamper circuit Header pins for Channel 1 and Channel 2 tamper circuits Pre-installed OS Raspberry PI Bullseye Lite 64-bit (optional 32-bit) Operational Environment Temperature: 0-60 degrees C Configure and Setup your Secure Edge Node Power On Connect the included 12V Power Supply up to the front panel 12V barrel connector. Optionally, supply power via PoE to the ethernet connector, or via the SATA edge connector. Connect an ethernet cable to the front panel gigabit ethernet port. The unit is designed to run headless. You do not need a monitor, keyboard, or mouse. Tje only access is via SSH. Notice The Secure Edge Node includes pre-installed Raspberry PI Bullseye Lite 64-bit (or optionally 32-bit) and all necessary Zymbit software. No further installation is necessary. The pre-installed image is encrypted and cannot be replaced via rpiboot in the field. Please contact support@zymbit.com for assistance. Monitor the Blue LED on the Zymbit SCM module. The total boot time as configured should take approximately 90 seconds from power on. It will go through the following stages:\none slow blink: initializing the SCM one -\u003e two -\u003e three -\u003e four blinks: Supervised Boot is verifying the signed file information rapid blinking: Supervised Boot successfully completed, booting underway blinking stops: USB bus enumeration found SCM; may stay off for seconds one blink every 3 seconds: zkifc has loaded and the system is ready to go Example of Successful Supervised Boot LED Sequence (Click image for video) Login via SSH Once the boot sequence completes and the Blue LED is blinking once every three seconds, login remotely via SSH. As shipped, the hostname is zymbit-dev and a user named zymbit can be used for SSH login. The default password for SSH is zymbit. Please change your password once you login. Console login has been disabled.\nRun example code The quickest way to get started is to see the Secure Edge Node’s various features at work is by running these test scripts. You can get the example scripts from here:\nDownload example files\npython3 /usr/local/share/zymkey/examples/zk_app_utils_test.py\npython3 /usr/local/share/zymkey/examples/zk_crypto_test.py\nNow you’re ready to start developing with the Zymbit Secure Compute Module.\nSecure Compute Module Inside the Secure Edge Node is the Secure Compute Module: a Zymbit Security Module + Hardware Wallet + Raspberry Pi CM4 integrated into a secure, encapsulated module. Details of the SCM itself including any other Zymbit specific cofigurations can be found here:\nUsing Secure Edge Node/SCM: API and Examples See API Documentation Working with Supervised Boot Securing the SCM further with the example Sanitization Script Working with the HD Wallet Setting up Tamper Detect Support Release Notes Contact Support ","categories":"","description":"","excerpt":" Overview Secure Edge Node - Zymbit offers a standard baseline …","ref":"/getting-started/sen/quickstart/","tags":"","title":"Quickstart - Secure Edge Node"},{"body":" Overview The Zymbit Secure Compute Module (SCM) is an all-in-one Linux compute module - secured and ready to deploy into your IoT and edge applications : a Zymbit Security Module + Hardware Wallet + Raspberry Pi CM4 integrated into a secure encapsulated module.\nSCM Physical Architecture Configure and Setup your SCM Power On, Bootup, and SSH in Connect up the ethernet and 12V power. The unit is designed to run headless. You do not need a monitor, keyboard, or mouse. As shipped, the hostname is zymbit-dev and a user named zymbit can be used for SSH login. The default password for SSH is zymbit. Please change your password once you login. Console login has been disabled. Notice All necessary Zymbit software has been pre-installed. No further installation is necessary. The pre-installed image is encrypted and cannot be replaced via rpiboot in the field. Please contact support@zymbit.com for assistance. Monitor the Blue LED on the Zymbit SCM module. The total boot time as configured should take approximately 90 seconds from power on. It will go through the following stages: one slow blink: initializing the SCM one -\u003e two -\u003e three -\u003e four blinks: Supervised Boot is verifying the signed file information rapid blinking: Supervised Boot successfully completed, booting underway blinking stops: USB bus enumeration found SCM; may stay off for seconds one blink every 3 seconds: zkifc has loaded and the system is ready to go Example of Successful Supervised Boot LED Sequence (Click image for video) Updated release 1/13/2023 (RC-23.01) We’ve updated the SCM release to support the A1 release of the SCM hardware. Summary of changes:\nPre-loaded OS options Raspberry PI OS Lite 64-bit (Bullseye) - DEFAULT Raspberry PI OS Lite 32-bit (Bullseye) - OPTIONAL Modifications from previous beta Now allow initial SSH via password (use zymbit/zymbit). Please change once logged in. No longer providing SSH key on USB stick; as noted above, you can use password. No longer necessary to register product; no SSH key necessary so no need for key passphrase. sudo for user zymbit with password in standard PI OS manner allowed; no need to supply password every time. Changes FW 01.00.00 - Supports A1 revision of SCM FW 01.00.00 - Fixed: #117 Stored tamper event on shutdown has incorrect timestamp zkifc 1.2-36 - Fixed: #120 get_public_key() with a very large number crashes zkifc zkpkcs 11 1.0-3 - Fixed: #123 zk_pkcs11: Doesn’t work with 64-bit OS SCM Developer’s Kit The SCM Developer’s kit provides all the hardware and software components required to evaluate the Zymbit Secure Compute Module.\nZymbit Secure Compute Module (Zymbit Security Module and CM4) Zymbit Secure Compute I/O Motherboard Zymbit Perimeter Detect Cable for Channel 2 Zymbit External Battery (optional) 12V Power Supply Contents of Dev Kit Secure Compute Module SCM Functional Architecture Highlights 100% pin compatible with RPi CM4, all configurations. 100% code compatible with RPi Easy to Scale Pre-fuzzed, pre-encrypted file system Notice The pre-installed image is encrypted and cannot be replaced via rpiboot in the field. Please contact support@zymbit.com for assistance. Pre-loaded Linux kernel (bullseye 64-bit or 32-bit) Optionally Pre-load with customer software Pre-defined file manifest \u0026 policies Custom MAC OUID blocks available Embedded hardware wallet with SLIP39-Shamir’s Secret Sharing Layers of Security Supervised boot Fully encapsulated Last gasp power defenses Tamper sense and response File system encryption Measured system identity \u0026 authentication Data encryption \u0026 signing Compute Options Broadcom BCM2711, Quad core Cortex-A72 (ARM v8) 64-bit SoC @ 1.5GHz LPDDR4 RAM: 1G to 8G, eMMC: 0G to 32G 2.4/5.0GHz Wi-Fi \u0026 Bluetooth Using SCM: API and Examples See API Documentation Working with Supervised Boot Securing the SCM further with the example Sanitization Script Working with the HD Wallet Setting up Tamper Detect Support Release Notes Contact Support ","categories":"","description":"","excerpt":" Overview The Zymbit Secure Compute Module (SCM) is an all-in-one …","ref":"/getting-started/scm/quickstart/","tags":"","title":"Quickstart - Secure Compute Module (SCM)"},{"body":"","categories":"","description":"","excerpt":"","ref":"/reference/product-briefs/zymkey4/","tags":"","title":"ZYMKEY4 Product Brief"},{"body":"The Zymkey App Utils library provides an API which allows user space applications to incorporate Zymkey’s cryptographic features, including:\nGeneration of random numbers Locking and unlocking of data objects ECDSA signature generation and verification In addition, the Zymkey App Utils library provides interfaces for administrative functions, such as:\nControl of the LED Setting the i2c address (i2c units only) Setting the tap detection sensitivity A Note About Files Some of the interfaces can take a filename as an argument. The following rules must be observed when using these interfaces:\nAbsolute path names must be provided. For destination filenames, the permissions of the path (or existing file) must be set: Write permissions for all. Write permissions for common group: in this case, user zymbit must be added to the group that has permissions for the destination directory path and/or existing file. Destination path must be fully owned by user and/or group zymbit. Similar rules exist for source filenames: Read permissions for all. Read permissions for common group: in this case, user zymbit must be added to the group that has permissions for the source directory path and/or existing file. Source path must be fully owned by user and/or group zymbit. Crypto Features Random Number Generation This feature is useful when the default host random number generator is suspected of having cryptographic weakness. It can also be used to supplement existing random number generation sources. Zymkey bases its random number generation on an internal TRNG (True Random Number Generator) and performs well under Fourmilab’s ent.\nData Locker Zymkey includes a feature, called Data Locking. This feature is essentially an AES encryption of the data block followed by an ECDSA signature trailer.\nData Locker Keys In addition to a unique ECDSA private/public key pair, each Zymkey has two unique AES keys that are programmed at the factory.\nECDSA Operations Each Zymkey comes out of the factory with three (Zymkey 4i/HSM4) or 12 (HSM6) unique ECDSA private/public key pairs. These private keys are randomly programmed within hardware at the time of manufacture and never exported. In fact, Zymbit doesn’t even know what the value of the private keys are.\nThere are three ECDSA operations available:\nGenerate signature: The Zymkey is capable of generating an ECDSA signature. Verification signature: The Zymkey is capable of verifying an ECDSA signature. Export the ECDSA public key: This saves the public key to a file in PEM format. This operation is useful for generating a Certificate Signing Request (CSR). Other Features LED The Zymkey has an LED which can be turned on, off or flashed at an interval.\ni2c Address For Zymkeys with an i2c interface, the base address can be changed to work around addressing conflicts. The default address is 0x30, but can be changed in the ranges 0x30 - 0x37 and 0x60 - 0x67.\nTap Sensitivity The Zymkey has an accelerometer which can perform tap detection. The sensitivity of the tap detection is configurable.\nProgramming Language Support Currently, C, C++ and Python are supported.\nBinding Before a Zymkey can be effectively used on a host computer, it must be “bound” to it. Binding is a process where a “fingerprint” is made which is composed of the host computer and its SD card serial numbers as well as the Zymkey serial number. If the host computer or SD card is changed from the time of binding, the Zymkey will refuse to accept commands.\nTo learn more about binding your zymkey, go to the Zymbit Community “Getting Started” page for your Zymkey model (e.g. Getting Started with ZYMKEY).\nHSM4 Soft Bind Lock Unlike Zymkey, HSM4 does not have a physical lock tab that is cut to lock the host binding. Instead, it has a software API for locking the binding to the host. See the soft bind lock API description for more information.\nHSM6 Soft Bind Lock See “HSM4: Soft Bind Lock” above.\nECDH ECDH with some Key Derivation Functions (KDFs) is available. The available KDFs include:\nnone: The raw pre-master secret is returned. rfc5869: This KDF can be invoked with SHA256 or SHA512 as the hashing function. pbkdf2: Like rfc5869, SHA256 or SHA512 can be specified. Koblitz Curve Support In addition to NIST P-256 which is available on Zymkey and HSM4, the Koblitz 256 bit curve is available as well.\nMore Key Slots HSM6 now has 12 factory pre-configured NIST P-256 key slots and 512 key pairs for generated key pair and digital wallet allocation for NIST P-256 or Koblitz 256. All of these key slots can be used for ECDSA as well as ECDH operations. It is also possible to remove the keys in the 512 key pair store and also prohibit public key export.\nForeign Public Keyring 128 public key slots are available to form a public key store for storing foreign party public keys. Like the 512 key pair store, public keys can be removed and prohibited from export.\nDigital Wallet HSM6 provides APIs which allow the creation of 1 or more digital wallets per BIP 32/39/44. The number of master seeds and child nodes is only limited by the number of key pairs provided for in the 512 byte key pair store. The BIP 39 feature provides the mnemonic sentence using the 2048 word English dictionary.\nBattery and Temperature Monitoring The HSM6 has APIs for reading the battery voltage as well as monitoring policies for taking action if certain thresholds are exceeded.\nBattery Monitoring The Battery Monitoring feature provides for 1 of 2 actions if the battery voltage below specified threshold (settable from 2.5V or lower via API).\nself-destruct:\nIf the battery voltage goes lower than the threshold, destroy all key material. Good for use cases where a low battery voltage is interpreted as an attempt to attack the low power tamper detect operation. sleep-until-battery-recovery:\nDo not permit full functionality until the battery has gone above the threshold. Good for use cases where battery replacement is desirable. Temperature Monitoring The Temperature Monitoring feature provides protection from attacks that are based on manipulation of temperature (e.g. memory freeze attacks). If invoked, the system may be configured to destroy keys if temperature thresholds are exceeded.\n","categories":"","description":"","excerpt":"The Zymkey App Utils library provides an API which allows user space …","ref":"/api/","tags":"","title":"API Documentation"},{"body":" Release Notes - Latest Release 1/13/2023 (RC-23.01) We updated the common Zymbit software release common to all products: ZYMKEY4, HSM4, HSM6, and the new SCM-based product line. Existing customers can do an update/upgrade to get the latest code.\nsudo apt-get update sudo apt-get upgrade -y sudo pip3 install zku --upgrade Zymbit Host Side Code Versions (view with dpkg -l | grep -i zym): libzk 1.1-22 libzymkeyssl 1.0-10 zkapputilslib 1.1-25 zkbootrtc 1.1-15 zkifc 1.2-36 zkpkcs11 1.0-3 zksaapps 1.0-16 zku 1.0.33 Changes Added support for Raspberry OS Bullseye 64-bit and Ubuntu 22.04 Jammy 32-bit and 64-bit Common code base supports across all products including SCM. See SCM release notes for details on SCM features. Fixed: #120 get_public_key() with a very large number crashes zkifc Fixed: #123 zk_pkcs11: Doesn’t work with 64-bit OS Fixed: #113 LED resets to default pattern after 5-10 minutes Fixed: #110 Fixed memory leak in zkifc which eventually could lead to zkifc crashing API functions that include Bip or Slip have been renamed to BIP and SLIP. See API docs for new syntax Issues and Solutions Expired GPG Key Preventing Access to Repository The Zymbit GPG key expired and was renewed on September 30, 2022. New installations should not have any problems. apt-get update may complain that the GPG key has expired. To update your local key, do the following:\nsudo su curl -L https://zk-sw-repo.s3.amazonaws.com/apt-zymkey-pubkey.gpg | apt-key add - CPU Scaling Governor We have seen some issues with the scaling cpu governor on the raspberry pi interfere with the i2c bus. This sometimes causes the zymkey to be put into a odd state or return failures from operations that get optimized out by the governor. The raspberry pi sets the scaling governor to be “ondemand” by default. We recommend switching this mode to “performance” to get the best out of the zymkey. Details:\nResources CPU Scaling Governor How to set cpu governor to performance. Read article Unattended-upgrades When encrypting your rootfs, we highly recommend turning off unattended-upgrades prior to the encryption process. In some cases primarily with Ubuntu 20.04, during an update/upgrade after encryption, the update-initramfs process may fail and leave the system unable to boot.\nTo mitigate this issue, remove the service unattended-upgrades:\nsystemctl stop unattended-upgrades\nsystemctl disable unattended-upgrades\nProducts Q: Where can I learn about and/or pre-order future products? Expand for Answer A: Sign up for our new product email updates at the bottom of Zymbit’s homepage.\nQ: What are the differences between Zymbit’s Products? Expand for Answer A: See the Product Comparison Matrix for the differences between Zymkey, HSM4, and HSM6. Please reach out with any further questions.\nQ: How much power do Zymbit products consume? Expand for Answer Zymkey-RPi (3.3V): idle approx. 1mA; max active \u003c 25mA with LED off, \u003c 35mA with LED on. Zymkey-USB (5V): idle approx. 1.5mA; max active \u003c 40mA with LEDs off, \u003c 60mA with LEDs on. See Power Quality for more information.\nQ: What is the expected battery life for Zymbit Products? Expand for Answer Compatibility Q: Which operating systems does Zymbit support? Expand for Answer Q: Which SBCs are compatible with Zymbit Products? Expand for Answer Electrically, the Zymkey-I2C will interface to any single board computer using I2C. Check compatibility with your particular Linux distribution. Raspberry Pi 3, 3B+, 4, Zero RPi Compute Module 3, 4 Q: Do Zymbit Products work with Arduino? Expand for Answer A: We have no plans to release an Arduino shield version. While we love Arduinos and use them all the time, they generally don’t have enough resources to handle cryptographic operations at this level.\nQ: Do Zymbit Products work with BeagleBone? Expand for Answer A: Zymbit does not officially support the BeagleBoard platform at this time.\n","categories":"","description":"","excerpt":" Release Notes - Latest Release 1/13/2023 (RC-23.01) We updated the …","ref":"/troubleshooting/general/","tags":"","title":"General FAQ \u0026 Troubleshooting"},{"body":"","categories":"","description":"","excerpt":"","ref":"/reference/product-briefs/","tags":"","title":"Product Briefs"},{"body":"","categories":"","description":"","excerpt":"","ref":"/getting-started/scm/","tags":"","title":"Secure Compute Module - SCM"},{"body":" Updated Software Release 1/13/2023 (RC-23.01) We’ve updated the SCM release to support the A1 release of the SCM hardware. Summary of changes:\nPre-loaded OS options Raspberry PI OS Lite 64-bit (Bullseye) - SHIPPED AS STANDARD Raspberry PI OS Lite 32-bit (Bullseye) - OPTIONAL, FACTORY CONFIGURED Modifications from previous beta Now allow initial SSH via password (use zymbit/zymbit). Please change once logged in. No longer providing SSH key on USB stick; as noted above, you can use password. No longer necessary to register product; no SSH key necessary so no need for key passphrase. sudo for user zymbit with password in standard PI OS manner allowed; no need to supply password every time. Changes FW 01.00.00 - Supports SCM hardware version A1 FW 01.00.00 - Fixed: #117 Stored tamper event on shutdown has incorrect timestamp zkifc 1.2-36 - Fixed: #120 get_public_key() with a very large number crashes zkifc zkpkcs 11 1.0-3 - Fixed: #123 zk_pkcs11: Doesn’t work with 64-bit OS Open Issues #122 - SCM: USB Isochronous mode data experiences delays while zkifc is running #119 - SCM: will not work with otg_mode=1, must set dtoverylay=dwc2,dr_mode=host. This can affect the ability for recognition of some other USB devices at boot time #126 - SCM: set_supervised_boot_policy not implemented. Currently, if there is an entry in the manifest, it is enabled. If no entry in manifest it is disabled. In Development mode it will flash 4-2 for failure. In Production mode, it self-destructs. There is no “held in reset” mode implemented. SCM Beta Release Oct 1, 2022\nChanges and Additions since Alpha program Numerous improvements in stability regarding tamper settings and events\nAdded permanent slots 14 and 15 as pre-configured ed25519 slots.\nAdded a default slot for Supervised Boot manifest using slot 15. Switched the order of the filename and slot to accommodate the default. Example for python:\nWas: add_or_update_supervised_boot_file(slot = 0 , filepath =\"\") Is: add_or_update_supervised_boot_file(filepath =\"\" , slot = 15)\nself-destruct now permanently destroys keys in Production Mode\nA system shutdown no longer reboots. It shuts down.\nStopping zkifc no longer disables all USB devices.\nIssues in 10/1/2022 Beta Release Issue #117 SCM: Stored tamper event on shutdown has incorrect timestamp. The status of an event (or no event) is always correct, just the timestamp value is incorrectly stored when powering down. Timestamps are correct for running systems and for events that happen while under battery. This does not affect the tamper detect functionality, only the timestamp.\nIssue #116 SCM: crypt unlock takes two tries. The first attempt times out while waiting for the SCM to come on line. If you have a console attached, you will see a message stating “No Zymkeys”, then the process will wait and unlock the LUKS key to gain access to the root file system.\nIssue #114 set_perimeter_event_actions() leaves the LED off. The LED will return to normal after the next zkifc Open Session after approximately one minute.\nFixed from Alpha to Beta - Issue #99 Minor: SCM: set_perimeter_event_actions() resets and can cause problems if another command is attempted for a period of seconds. A delay of 10 seconds after a set_perimeter_event_actions() will workaround the issue.\nFixed from Alpha to Beta - Issue #103 Major: SCM: Tamper Detect events occassionally resets the SCM and CM4. We are still investigating the root cause of this issue, but it happens quite often with tamper events. For Alpha, self-destruction is disabled for evaluation purposes which should prevent any loss of data. It will cause a reboot.\nFixed from Alpha to Beta - Issue #93: SCM: battery_voltage_threshold - bad window from 2.5V - 3.0V. Setting the low voltage threshold within the range of 2.5V to 3.0V should not be allowed but there is currently no check. Do not set the low voltage threshold to \u003e 2.5 volts.\nFixed from Alpha to Beta - Issue #90: SCM: zkifc stop/reset drops all USB devices except SCM. Causes problems when rebooting, setting tamper actions, and also during encryption. Workaround is to powercycle after any stop/reset of zkifc. Note: Configured headless precludes any issues that may surface with console I/O via a USB keyboard/mouse.\nFixed from Alpha to Beta - Issue #88: SCM: Master Wallet Seed remove times out from host side. Timeout can vary but happens with approximately 20 derived child key entries per wallet. Workaround for now is to limit individual wallet size / depth.\nFirmware: SCM: 00.00.51beta, 00.00.34beta Zymbit Host Side Code: libzk 1.1-22 libzymkeyssl 1.0-10 zkapputilslib 1.1-25 zkbootrtc 1.1-15 zkifc 1.2-35 zkpkcs11 1.0-2 zksaapps 1.0.-16 zku 1.0.33 Modifications from Standard Raspberry PI OS Lite The SCM ships with a pre-installed version of Raspberry PI OS Lite (bullseye 32bit) with a more secure configuration.\nNotice The pre-installed image is encrypted and cannot be replaced via rpiboot in the field. Please contact support@zymbit.com if you require a different image. The table below summarizes changes made to the standard image.\nDefault As Shipped Console login allowed Disabled SSH with password allowed Disabled. SSH must use keys Hostname is raspberrypi Hostname changed to zymbit-dev Default user of pi Default user is zymbit. User pi removed MAC with Pi OID MAC uses Zymbit OID sudo password free sudo requires a password (zymkey) SCM Beta Unlike the Alpha program, the Beta units allow the user to bind lock the unit in Production Mode and permanently destroy the keys. Beta units out in Production Mode will not be recoverable here at Zymbit if self-destruct has been triggered in the field.\nItem Beta in Development Mode Beta in Production Mode Tamper Detect Self-destruct mode does 6 flashes, 3 times and then recovers. Close loops to resume. Self-destruct will destroy all keys. No recovery possible. Supervised Boot Sign/Verify file integrity failure does 4 flashes followed by 2 flashes, 3 times and then recovers. Sign/Verify file integrity failure with execute policy to either hold in reset or self-destruct. No recovery possible. Last Gasp Battery Threshold action of self-destruct does 6 flashes, 3 times and recovers. Requires bind lock. Self-destruct action destroy all keys. No recovery possible. LED Reference Common LED patterns:\nOnce every 3 seconds\nThis indicates that your SCM is working and running. Three rapid blinks every 3 seconds\nThis indicates the SCM is in Production Mode and is working and running. Constant rapid blinking (waiting for host to connect)\nThis indicates that your SCM is operational but has not bound to the host. If the SCM continues to blink this pattern, it could mean that there is a problem with the host Pi or that the SCM is not seen by the Pi. Rapid blinking then LED off permanently\nThis indicates the SCM is in Production Mode but cannot bind with the RPi. In Production Mode the binding with a particular Pi becomes permanent. Most likely cause for this is that the SCM or the PI has been swapped out. Also can indicate an improper salt file. The Zymkey has the following fatal LED structure.\nPreamble: 10 very rapid flashes Off for 1 second Main code: a number of 0.5 second flashes which define the main code Off for 1 second Optional subcode: a number of 0.5 second flashes which define the subcode The fatal LED sequence is repeated 3 times, after which the SCM reboots.\nMain Code Sub Code Description 4 2 Supervised Boot failure: At least one Supervised Boot file failed signature check. 5 None ATECC Serial number mismatch. Usually the result of the keys being erased due to a tamper breach with self-destruct policy. 6 None Digest of keys area of SCM flash have failed. Could be caused by a tamper breach or a hardware failure. Also the result of Battery Voltage Threshold self_destruct action. 6 subcode Tamper detect event in self destruct mode while in developer mode. Subcode represents aggregate of all channels witnessed. 8 None SCM unable to send response back to host. Can be caused by overutilized host CPU which causes heartbeats to not be sent to SCM. 20 1 Temperature below low boundary in self destruct mode in developer mode. 20 2 Temperature above high boundary in self destruct mode in developer mode. 22 9 Supervised Boot failure: True failure in Supervised Boot process. ","categories":"","description":"","excerpt":" Updated Software Release 1/13/2023 (RC-23.01) We’ve updated the SCM …","ref":"/troubleshooting/scm/","tags":"","title":"SCM Troubleshooting/FAQ"},{"body":"","categories":"","description":"","excerpt":"","ref":"/getting-started/sen/","tags":"","title":"Secure Edge Node"},{"body":"Updated: 2022-04-18\nWhat is a Hardware Wallet? Zymbit’s Hardware Wallet conforms to BIP32, BIP39, BIP44 documents for Hierarchical Deterministic (HD) wallets. An HD wallet derives all new addresses/keys from a master seed, thus creating a hierarchical wallet structure. BIP32 is the first seed standard for HD wallets, while BIP39 is a standard that converts a mnemonic sentence (a sentence of random words) into a 512 bit seed used for Master Seed recovery. BIP44 allows for multiple accounts in the form of children derivations from the master seed.\nA Hardware Wallet, or cold storage wallet, allows you to connect online and access your digital assets, and then safely store the referenced asset in the hardware wallet. The asset does not need to be stored on online servers or platforms. The private keys of the Hardware wallet remain on the device and are never exposed.\nA Software Wallet, also known as a Soft Wallet or Desktop Wallet locally stores your keys on your desktop or in some other online location. The disadvantage of a Soft Wallet is that the presence of the keys online makes them far more susceptible to attacks.\nWhat is the Zymbit Embedded Hardware Wallet? Zymbit Embedded Hardware Wallet functionality is available in Zymbit products, HSM6 and SCM. These products are designed to easily integrate into IoT and blockchain appliances that manage large numbers of keys and/or participate in blockchain and crypto transactions.\nThe core features of Zymbit Embedded Hardware Wallets are:\nBIP32 – Hierarchical Deterministic Wallet BIP39 – Master Seed Mnemonic Code Generator BIP44 – Multi-Account Hierarchy Support SLIP39 – Shamirs Secret Sharing See example APIs for secure easy integration with host computer (Python, C, C++) Dedicated secure hardware with tamper protection and response. Why use a Hardware Wallet? To make secure crypto transactions, a user needs to have a public/private key pair. The public key is an address used for receiving incoming goods, while the private key is used for sending those goods. Losing this key pair will be disastrous, as this will effectively give someone access to the assets in that key pair. This is why for additional security it’s best practice to change addresses (keys) for every transaction. HD wallets automatically derive new addresses to use, thus eliminating the problem for the user to generate hundreds of keys on their own.\nManaging your Hardware Wallet and Security Awareness The master seed is where all new key pairs will be derived from. Each new child key pair is created based off a existing parent key pair in the wallet. If a child key pair ever becomes ‘compromised’, it can’t be tracked up the parent nodes. However this does warrant security awareness, that it will compromise all children key pairs derived from the stolen key pair.\nWarning For security reasons, the user is expected to keep track of all the key pairs via either the node address on the wallet or the slot it was allocated to on the Zymbit module. It’s better to lose a branch than a whole tree, so keep your master seed safe and locked away! Prerequisites Zymbit Modules that support this feature:\nHSM6 SCM Follow the Getting Started guide first, installing all baseline software.\nAll code snippets written in this article are written using python3. For more Zymbit API documentation (Python/C/C++) visit: API Documentation\nUsing the Zymbit Hardware Wallet: Example code snippet to show how to use the Zymbit wallet API\n#!/usr/bin/python3 import zymkey # Create a master seed and return the BIP39 mnemonic master_key_generator = bytearray(\"3xampleM@sterK3Y\", 'utf-8') wallet_name = \"MyExampleWallet\" # Use the BIP39 recovery strategy to tell zymkey to return a mnemonic. Takes a base 64 encoded string for a BIP39 passphrase. Can be empty string. use_BIP39_recovery = zymkey.RecoveryStrategyBIP39() master_slot, BIP39_mnemonic = zymkey.client.gen_wallet_master_seed(\"secp256k1\", master_key_generator, wallet_name, use_BIP39_recovery) print(\"Master Slot:%s\\nBIP39 mnemonic (write this down!):\\n%s\" % (master_slot, BIP39_mnemonic)) # Generate a child key from the master seed child_slot = zymkey.client.gen_wallet_child_key(master_slot, 3, True) child_pub_key = zymkey.client.get_public_key(child_slot) print(\"Child Slot:%s\\nChild Public Key:%s\" % (child_slot, child_pub_key)) # Get node address of the child key slot node_addr = zymkey.client.get_wallet_node_addr(child_slot) print(\"Node index:'%s' Wallet Name:'%s' Master Slot:'%s'\" % (node_addr[0], node_addr[1], node_addr[2])) # Get the key slot of the child key using our previous master key slot and wallet name key_slot = zymkey.client.get_wallet_key_slot(node_addr[0],wallet_name, master_slot) print(\"Key Slot:%s\" % (key_slot,)) # Remove the master seed zymkey.client.remove_key(master_slot) # Restore the master seed with our previous written down BIP39 mnemonic! restored_seed_slot = zymkey.client.restore_wallet_master_seed(\"secp256k1\", bytearray(\"3xampleM@sterK3Y\", 'utf-8'), wallet_name, use_BIP39_recovery, BIP39_mnemonic) print(\"Restored slot:%s\" % (restored_seed_slot,)) # Clean up the example slots zymkey.client.remove_key(master_slot) zymkey.client.remove_key(child_slot) Creating a master seed (new wallet) The Zymbit module with wallet support can have multiple master seeds be stored in its key store, allowing for management of a variety of keyrings to work with. Master seeds and its derivations are additionally backed by EC curve cryptography for an extra layer of encryption/security. The ec curves currently supported are nistp256, secp256r1, secp256k1. The master_key_generator is used to generate the BIP32 master seed, can be empty string. The RecoveryStrategy parameter dictates what recovery algorithm to return when generating the master seed. If the base RecoveryStrategy is used or none is specified, then no mnemonic will be returned. Current supported recovery strategies are none, BIP39. This example generates a master seed with the RecoveryStrategyBIP39. The BIP39 mnemonic is a 24 word string that can be used to restore or recreate a previous generated master seed. Note that a wallet name is also unique! There can not be multiple wallets with the same name.\nWarning Make sure to write the BIP39 mnemonic and store it somewhere safe! The master seed is the key to its kingdom. Don’t give it out to just anybody! The function gen_wallet_master_seed returns the allocated master seed slot and the BIP39 mnemonic if the bool flag is set True\n# Create a master seed and return the BIP39 mnemonic master_key_generator = bytearray(\"3xampleM@sterK3Y\", 'utf-8') wallet_name = \"MyExampleWallet\" # Use the BIP39 recovery strategy to tell zymkey to return a mnemonic. Takes a base 64 encoded string for a BIP39 passphrase. Can be empty string. use_BIP39_recovery = zymkey.RecoveryStrategyBIP39() master_slot, BIP39_mnemonic = zymkey.client.gen_wallet_master_seed(\"secp256k1\", master_key_generator, wallet_name, use_BIP39_recovery) print(\"Master Slot:%s\\nBIP39 mnemonic (write this down!):\\n%s\" % (master_slot, BIP39_mnemonic)) Generating a child Key Child key pairs are generated from both the slot and index of another key pair. BIP32 has two possible derivations hardened and non-hardened. Non-hardened key pairs can be linked back to its parent key pair with just its public key. Hardened key pairs cannot be linked back to its parent key. So for best security practices, it’s advised to generate hardened key pairs wherever possible.\nThe function gen_wallet_child_key returns allocated slot on success.\n# Generate a child key from the master seed child_slot = zymkey.client.gen_wallet_child_key(master_slot, 3, True) child_pub_key = zymkey.client.get_public_key(child_slot) print(\"Child Slot:%s\\nChild Public Key:%s\" % (child_slot, child_pub_key)) Node Address: The index parameter in the above example will add a new number 3 to the node address string in the wallet. Apostrophes after the number denote hardened keys. Below is an example node address string.\nm / 3' / 1' / 0' / 1 / 28\nGet a node address from a key slot If the user knows the key slot, they can get the node index and wallet name with this function.\nThe function get_wallet_node_addr(int slot) returns an array [node index string, wallet name, master seed slot number].\n# Get node address of the child key slot node_addr = zymkey.client.get_wallet_node_addr(child_slot) print(\"Node address:'%s' Wallet Name:'%s' Master Slot:'%s'\" % (node_addr[0], node_addr[1], node_addr[2])) Get a key slot from a wallet node address If the user knows the wallet node index string and either the master seed slot or the wallet name it belongs to, they can get the key slot with this function. Both master seed slot and wallet name are optional arguments, but if neither are filled, then it will throw an exception.\nThe function get_wallet_key_slot(string node_index, string wallet_name, int master_slot) returns the key slot on success.\n# Get the key slot of the child key using our previous master key slot and wallet name key_slot = zymkey.client.get_wallet_key_slot(node_addr[0],\"MyExampleWallet\", master_slot) print(\"Key Slot:%s\" % (key_slot,)) Restore a wallet master seed from a BIP39 mnemonic With the BIP39 mnemonic sentence, BIP39 passphrase, master generatorkey, and wallet name of a previously generated master seed, a user can restore a lost master seed or make a copy of the master seed on a different device.\nWarning Keep in mind that this only restores the master seed. The children nodes will have to be manually generated again. The function restore_wallet_master_seed returns the allocated key slot on success.\n# Remove the master seed zymkey.client.remove_key(master_slot) # Restore the master seed with our previous written down BIP39 mnemonic! use_BIP39_recovery = zymkey.RecoveryStrategyBIP39() restored_seed_slot = zymkey.client.restore_wallet_master_seed(\"secp256k1\", bytearray(\"3xampleM@sterK3Y\", 'utf-8'), \"MyExampleWallet\", use_BIP39_recovery, BIP39_mnemonic) print(\"Restored slot:%s\" % (restored_seed_slot,)) Troubleshooting Troubleshooting Community\n","categories":"","description":"","excerpt":"Updated: 2022-04-18\nWhat is a Hardware Wallet? Zymbit’s Hardware …","ref":"/tutorials/digital-wallet/wallet-example/","tags":"","title":"Working with the Zymbit Hardware Wallet"},{"body":"","categories":"","description":"","excerpt":"","ref":"/reference/product-briefs/hsm4/","tags":"","title":"HSM4 Product Brief"},{"body":"","categories":"","description":"","excerpt":"","ref":"/reference/cad/","tags":"","title":"CAD Files"},{"body":"","categories":"","description":"","excerpt":"","ref":"/troubleshooting/","tags":"","title":"FAQ and Troubleshooting"},{"body":"","categories":"","description":"","excerpt":"","ref":"/getting-started/zymkey4/","tags":"","title":"ZYMKEY4"},{"body":" Troubleshooting Troubleshooting Checklist Before contacting Zymbit with troubleshooting related questions, please read through the following troubleshooting checklist.\nPower supply. The recommended power for the PI4 is 5V and 3 amps. Most of the problems we see are from a poor power source. Start with a good power supply from the PI foundation or Canakit, not a phone charger. I2C enabled. Double check that you have enabled the I2C bus. An easy way to check is “ls -l /dev/i2c-1”. If /dev/i2c-1 exists, the I2C bus is enabled. apt update and upgrade. Be sure that your software is up to date. Installation. The curl script will reboot your system once completed. After the reboot, the blue LED on your Zymbit device should blink once every 3 seconds. You must get to this step before proceeding to encryption, etc. If your issue is not related to any of the above list, read through the FAQ below to see if your issue is answered. If you still do not see a solution to your problem, reach out on our Community Forum. Thank you!\nQ: Why does the LED continue to blink rapidly? It never blinks with the described pattern of once (in Development mode) or three times (in Production mode) every three seconds. Expand for Answer A: Check the following:\nCheck that the Raspberry Pi power is sufficient. The red LED on most Raspberry Pi models indicates if the Pi is being powered adequately. If it is not lit at all or flashes intermittently, try a different power supply or a different USB cable. For the RPi4, your power supply must provide at least 3 Amps.\nMake sure that you have enabled i2c support using raspi-config BEFORE your install the software. Also, when you enable i2c communications be sure to follow the enable-disable-enable sequence.\nIf i2c support has been enabled correctly and the Zymkey LED is still rapidly blinking, check proper physical installation of the Zymkey as detailed in this “Getting Started” guide.\nZymkey uses GPIO header pins 3 and 5 for i2c communications and pin 7 as an interrupt signal to the Pi. Pin 7 should preferably be dedicated exclusively to Zymkey. Other devices may share the i2c bus with Zymkey, but there may still be address conflicts. By default, Zymkey uses slave address 0x30. If the address conflict cannot be resolved on the other i2c devices, there is a way of changing the i2c address through an API call. Using this application, the Zymkey address can be changed anywhere in the ranges of 0x30-0x37 or 0x60-0x67.\nExpand for API information to change i2c address Python: set_i2c_address\nC: int zkSetI2CAddr ( zkCTX ctx, int addr)\nSee API Documentation\nOftentimes the 1-Wire interface relies on pin 7 (GPIO 4) for communication. If the 1-Wire interface is enabled, try disabling through raspi-config. If that resolves the problem take steps to either move the Zymkey interrupt signal from GPIO 4 or the 1-Wire interface from GPIO 4.\nif the directory at /var/lib/zymbit or any of the files and/or subdirectories are corrupted or deleted, the Zymkey will fail to work. IMPORTANT: if this happens when the Zymkey is locked (i.e. Production Mode), the Zymkey can never be used again.\nQ: The LED blinks rapidly when booting, but eventually turns off. It doesn’t blink once or three times every 3 seconds as described. Expand for Answer A: This issue could be caused by the same issues described in the first question (Why does the LED continue to blink rapidly?). Additionally, this can be caused if a locked (Production Mode) Zymkey is moved to another Pi.\nQ: What do the different LED blinking patterns mean? Expand for Answer 1 second very rapid flash, 1 second off, 8 slow blinks This indicates interrupted communications. 1 second very rapid flash, 1 second off, 5 slow blinks This indicates a failure to communicate with ATECC. The most likely cause is the Zymkey is in Production Mode, tamper detect was set to self-destruct, and a tamper detect event caused the Zymkey to self-destruct. If tamper detect is not armed, this indicates a hardware problem. Constant rapid blinking (waiting for host to connect) This indicates that you Zymkey is operational but has not bound to the host. If the Zymkey continues to blink this pattern, it could mean that there is a problem with the host Pi or that the i2c is not configured or that the i2c and wake pins are not making contact. Once every 3 seconds This indicates that your Zymkey is working and running. Three rapid blinks every 3 seconds This indicates the Zymkey is in Production Mode and is working and running. Rapid blinking then LED off permanently This indicates the Zymkey is in Production Mode but cannot bind with the RPi / SD card pair. In Production Mode the binding with a particular Pi and SD card becomes permanent. Most likely cause for this is that the Zymkey, the SD card, or the PI has been swapped out. Q: How do I set an alternative I2C address? Expand for Answer A: You can change the I2C address through our standard APIs:\nC: int zkSetI2CAddr ( zkCTX ctx, int addr) Python: set_i2c_address The I2C communication between the Zymkey and the Host is encrypted, but will not interfere with other devices on the same bus (assuming there is no address conflict).\nSee API Documentation\nQ: Why does my Zymkey fail to restart after cycling power? Expand for Answer A: Zymkey monitors the quality of 5V power coming into the host computer. If the voltage drops below a specified limit, even momentarily, then Zymkey will disable all security services to the host. This is a security feature to prevent power cycle and brown-own attacks. If you are powering a display, modem, or other power-hungry device from your Pi, then check the capacity and quality of your power supply. Learn more \u003e\nQ: Why is my Zymkey “invisible” to the i2c-tools suite? Expand for Answer A: Some people have become accustomed to using i2c-detect to do a first level check for correct installation and baseline functionality of i2c devices. However, these tools only really work if the i2c device communicates via a protocol that sits on top of i2c called SMBus or SMB (System Management Bus). Instead, Zymkey communicates to the host at a much more fundamental level, in part because the Zymkey protocol traffic is encrypted.\nYou can tell if you successfully installed it by observing the blue LED. If it is flashing once every 3 seconds, then binding completed. You can also use the systemctl command. It should say “active (running)”:\nsystemctl status zkifc\nQ: If the install fails, can I run it more than once? Expand for Answer A: Yes, you should have no problem running it multiple times if it were to fail.\nEncrypting Root File System Summary of steps Start with a blank USB device. USB storage should be twice the size of the SD card. The process for encrypting the SD card stops zkifc. The blue LED will flash rapidly during the encryption process. It will return to blinking once every 3 seconds when complete. The process will automatically do two reboots. Be patient. If the encryption process does not complete, it’s best to start fresh and try again. Q: How can I check if the system matches the default parameters? Expand for Answer A: lsblk will show you the partitions. Look for the name of your / partition (default is mmcblk0p2) and the USB device (default is sda). Example output:\nNAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT mmcblk0 179:0 0 14.9G 0 disk |-mmcblk0p1 179:1 0 256M 0 part /boot `-mmcblk0p2 179:2 0 14.6G 0 part / sda 8:0 0 32.0G 0 disk |_sda1 8:1 0 32.0G 0 part Q: How can I monitor the status after phase 1 reboot? Expand for Answer A: Once you get to the second phase and login, you can monitor progress with\njournalctl -fu cfg_SD_crfs\nThat will show you progress of the second half of the encryption process.\nQ: Can I re-run encryption with the same USB stick? Expand for Answer A: The script is designed to re-use information on the USB stick to encrypt a “golden” image in production on more than one device. If the file original_zk_root.tgz exists on the USB stick, it will use that file and skip the step of creating a whole new tarball of the rootfs. If you truly want to start over, start by reformatting/erasing your USB stick.\nQ: If my PI automounts the USB device, will that interfere with the process? Expand for Answer A: The script attempts to unmount the external device, but in some cricumstances the device may stay mounted and the process will fail. You will get a message either on your screen or in journalctl -fu cfg_SD_crfs during the second phase indicating the drive was already mounted. Unmount the drive and try again.\n# Check /dev/sda* mount points for devices mounted to /media/* lsblk # if mounted, unmount sudo umount /media* # re-run service sudo systemctl restart # monitor progress journalctl -fu cfg_SD_crfs Q: How can I confirm my file system is encrypted and protected? Expand for Answer A: Since zkifc is stopped during the process, the blue LED will flash rapidly until the whole process completes. Once both of the automautic reboots are completed, the blue LED will return to flashing once every 3 seconds.\nlsblk will show you that you now have a “cryptrfs” partition under your mmcblk0p2 (default)\ndf -h will also show “/dev/mapper/cryptrfs” for the “/” file system.\nIf your system reboots twice, the LED returns to flashing once every 3 seconds, and lsblk displays a “cryptrfs” partition, you can be confident your system is encrypted and protected.\nFor more help, see Zymbit’s Community Forum. Features Q: What curves are supported for Zymbit products? Expand for Answer Zymkey and HSM4: NIST P-256 and secp256r1\nHSM6: NIST P-256, secp256r1, secp256k1, X25519, ED25519\nQ: How do I use HSM6’s store_foreign_public_key function to store a Zymkey or HSM4 public key on HSM6? Expand for Answer A: The easiest way is to save the HSM4 key directly to a binary file, copy that file to the HSM6 and read in the binary file.\nHSM4 side:\n#!/usr/bin/python3 import zymkey # Get the public key from slot 0 and save it in a file pub_key_file = '/tmp/pub_key_slot0' slot = 0 key = zymkey.client.get_public_key(slot) with open(pub_key_file, \"wb\") as f: f.write(key) copy /tmp/pub_key_slot0 over to the HSM6 PI\nHSM6 side:\n#!/usr/bin/python3 import zymkey key_file = \"/tmp/pub_key_slot0\" key = open(key_file, \"rb\").read() # Store the key in the foreign key store foreign_slot = zymkey.client.store_foreign_public_key('secp256r1', key) Q: How can I reset the clock to the current timestamp? Expand for Answer A: The clock will sync to the current timestamp once the Pi has achieved NTP sync. This requires you to have access to the Internet.\nQ: How do I access the devices (RTC, accelerometer, crypto) on Zymkey? Expand for Answer A: For Zymkey and HSMs, kernel drivers and libraries for all of the devices are included in the Zymkey software package via the APIs.\nQ: My GPG Key expired and I cannot access the Zymkey Repository. How do I update the Key? Expand for Answer A: You can update your existing key with the following command:\ncurl -L https://zk-sw-repo.s3.amazonaws.com/apt-zymkey-pubkey.gpg | apt-key add -\nQ: Can the Zymkey detect if the SD card has been removed? Expand for Answer A: No, but perimeter detect can be configured to prevent access to the SD card. When a tamper event is detected, the Zymkey will, when properly configured via the API, destroy all critical key material and the root fs will fail to be decrypted upon boot.\nBattery \u0026 Power Questions Q: Should I use an external battery on my Zymkey or HSM? Expand for Answer A: The following table compares Zymkey and HSM operational modes while connected to Main Power, Battery Power, and No Power.\nThe battery is required to maintain the Real Time Clock and the perimeter detect circuits when the host power is removed. Without the battery, these two functions will not be active when the host power is removed.\nQ: What happens when the battery dies? How can I change the battery when it dies, without self-destructing my device? Expand for Answer A: If the battery dies and the host is not connected to power, some features will go out, such as Perimeter Detect and Real Time Clock. See the table below for more information.\nWith Zymkey and HSM4, if tamper detect is enabled and the battery dies or is removed, the device will self-destruct. This is an intentional security feature. If tamper detect is NOT enabled, you should connect the host device to power to change the battery.\nHSM6 has a battery monitoring feature to help the user prevent the battery from dying. If the battery dies, HSM6 users have the ability to choose whether the device should self-destruct or hold in reset mode until the battery is changed.\nKernel \u0026 Kernel Boot Questions Q: Can you tell the kernel not to run a shell? Expand for Answer A: Someone could easily replace the kernel and, while it is possible to configure initramfs to not permit the busybox shell to, that can be sidestepped as well. Even if you hack your own changes to the kernel to ignore the init option, someone could replace your kernel. Also, kernel updates would have to be done manually and the updates from the apt repo would have to be blacklisted.\nQ: Can you tell the kernel to ignore cmdline.txt? Expand for Answer A: There are many reasons why this is infeasible, but the main one is that, since the GPU initially functions as a bootloader processor during boot and since Broadcom has not made the GPU compiler publicly available as well as the source code for the bootloader, one cannot simply compile their own code that would ignore cmdline.txt.\nQ: Is it possible to encrypt the boot partition? Expand for Answer A: No because the GPU bootloader does not have encryption features implemented and, even in lieu of that, it does not know how to communicate with Zymkey. The best solution, then, would be to implement an independent secure boot procedure. As mentioned above, we are currently working on adding this feature in a future product.\nProduction (“self-destruct”) Mode Questions Q: When using the perimeter-detect feature, does the “self-destruct” mode work (destroy all of its key material) even when the Lock Tab hasn’t been cut? Expand for Answer A: Self-destruct mode works only after the Lock Tab has been cut.\nQ: Is there a way to turn off “self-destruct” mode? Expand for Answer A: No, once turned on, “self-destruct” mode is permanent.\nQ: If my Zymkey does “self-destruct,” can I create new keys and reuse the hardware? Expand for Answer The SBC and SD card hardware will be reusable. Because the SD card contents are encrypted and the decryption key was destroyed, the data is lost. The Zymkey will not be reusable because the key slots will be destroyed. Q: If I cut the Lock-Tab on a Zymkey, can I move that Zymkey to another Pi or change the SD card? Expand for Answer A: No. Cutting the Lock-Tab permanently binds that instance of Zymkey to the specific instances of host computer and SD card. This is a security feature to prevent credentials being moved from one host to another. DO NOT cut the Lock-Tab if you are still in development and expect to change the host or SD cards.\nQ: Will Zymkey still self-destruct, even when my SBC is powered off? Expand for Answer A: Yes, because Zymkey is battery powered. As long as the battery is sufficiently charged, it will still self-destruct.\nOther Q: Where can I learn about and/or pre-order future products? Expand for Answer A: Sign up for our new product email updates at the bottom of Zymbit’s homepage.\nQ: Which SBCs are compatible with Zymkey? Expand for Answer Electrically, the Zymkey-I2C will interface to any single board computer using I2C. Check compatibility with your particular Linux distribution. Raspberry Pi 3, 3B+, 4, Zero RPi Compute Module 3, 4 Q: Does Zymkey work with Arduino? Expand for Answer A: We have no plans to release an Arduino shield version. While we love Arduinos and use them all the time, they generally don’t have enough resources to handle cryptographic operations at this level.\nQ: Does Zymkey work with BeagleBone? Expand for Answer A: Zymbit does not officially support the BeagleBoard platform at this time.\nQ: Which operating systems does Zymkey support? Expand for Answer Q: How much power does Zymkey consume? Expand for Answer Zymkey-RPi (3.3V): idle approx. 1mA; max active \u003c 25mA with LED off, \u003c 35mA with LED on. Zymkey-USB (5V): idle approx. 1.5mA; max active \u003c 40mA with LEDs off, \u003c 60mA with LEDs on. See Power Quality for more information.\n","categories":"","description":"","excerpt":" Troubleshooting Troubleshooting Checklist Before contacting Zymbit …","ref":"/troubleshooting/zymkey4/","tags":"","title":"ZYMKEY4 FAQ \u0026 Troubleshooting"},{"body":"","categories":"","description":"","excerpt":"","ref":"/reference/product-briefs/hsm6/","tags":"","title":"HSM6 Product Brief"},{"body":"","categories":"","description":"","excerpt":"","ref":"/reference/conformity/","tags":"","title":"Conformity Documents"},{"body":"","categories":"","description":"","excerpt":"","ref":"/getting-started/hsm4/","tags":"","title":"HSM4"},{"body":" Troubleshooting Troubleshooting Checklist Before contacting Zymbit with troubleshooting related questions, please read through the following troubleshooting checklist.\nPower supply. The recommended power for the PI4 is 5V and 3 amps. Most of the problems we see are from a poor power source. Start with a good power supply from the PI foundation or Canakit, not a phone charger. I2C enabled. Double check that you have enabled the I2C bus. An easy way to check is “ls -l /dev/i2c-1”. If /dev/i2c-1 exists, the I2C bus is enabled. apt update and upgrade. Be sure that your software is up to date. Installation. The curl script will reboot your system once completed. After the reboot, the blue LED on your Zymbit device should blink once every 3 seconds. You must get to this step before proceeding to encryption, etc. If your issue is not related to any of the above list, read through the FAQ below to see if your issue is answered. If you still do not see a solution to your problem, reach out on our Community Forum. Thank you!\nQ: Why does the LED continue to blink rapidly? It never blinks with the described pattern of once (in Development mode) or three times (in Production mode) every three seconds. Expand for Answer A: Check the following:\nCheck that the Raspberry Pi power is sufficient. The red LED on most Raspberry Pi models indicates if the Pi is being powered adequately. If it is not lit at all or flashes intermittently, try a different power supply or a different USB cable. For the RPi4, your power supply must provide at least 3 Amps.\nMake sure that you have enabled i2c support using raspi-config BEFORE your install the software. Also, when you enable i2c communications be sure to follow the enable-disable-enable sequence.\nIf i2c support has been enabled correctly and the HSM4 LED is still rapidly blinking, check proper physical installation of the HSM4 as detailed in this “Getting Started” guide.\nHSM4 uses GPIO header pins 3 and 5 for i2c communications and pin 7 as an interrupt signal to the Pi. Pin 7 should preferably be dedicated exclusively to HSM4. Other devices may share the i2c bus with HSM4, but there may still be address conflicts. By default, HSM4 uses slave address 0x30. If the address conflict cannot be resolved on the other i2c devices, there is a way of changing the i2c address through an API call. Using this application, the HSM4 address can be changed anywhere in the ranges of 0x30-0x37 or 0x60-0x67.\nExpand for API information to change i2c address Python: set_i2c_address\nC: int zkSetI2CAddr ( zkCTX ctx, int addr)\nSee API Documentation\nOftentimes the 1-Wire interface relies on pin 7 (GPIO 4) for communication. If the 1-Wire interface is enabled, try disabling through raspi-config. If that resolves the problem take steps to either move the HSM4 interrupt signal from GPIO 4 or the 1-Wire interface from GPIO 4.\nif the directory at /var/lib/zymbit or any of the files and/or subdirectories are corrupted or deleted, the HSM4 will fail to work. IMPORTANT: if this happens when the HSM4 is locked (i.e. Production Mode), the HSM4 can never be used again.\nQ: The LED blinks rapidly when booting, but eventually turns off. It doesn’t blink once or three times every 3 seconds as described. Expand for Answer A: This issue could be caused by the same issues described in the first question (Why does the LED continue to blink rapidly?). Additionally, this can be caused if a locked (Production Mode) HSM4 is moved to another Pi.\nQ: What do the different LED blinking patterns mean? Expand for Answer 1 second very rapid flash, 1 second off, 8 slow blinks This indicates interrupted communications. 1 second very rapid flash, 1 second off, 5 slow blinks This indicates a failure to communicate with ATECC. The most likely cause is the HSM4 is in Production Mode, tamper detect was set to self-destruct, and a tamper detect event caused the HSM4 to self-destruct. If tamper detect is not armed, this indicates a hardware problem. Constant rapid blinking (waiting for host to connect) This indicates that you HSM4 is operational but has not bound to the host. If the HSM4 continues to blink this pattern, it could mean that there is a problem with the host Pi or that the i2c is not configured or that the i2c and wake pins are not making contact. Once every 3 seconds This indicates that your HSM4 is working and running. Three rapid blinks every 3 seconds This indicates the HSM4 is in Production Mode and is working and running. Rapid blinking then LED off permanently This indicates the HSM4 is in Production Mode but cannot bind with the RPi / SD card pair. In Production Mode the binding with a particular Pi and SD card becomes permanent. Most likely cause for this is that the HSM4, the SD card, or the PI has been swapped out. Q: How do I set an alternative I2C address? Expand for Answer A: You can change the I2C address through our standard APIs:\nC: int zkSetI2CAddr ( zkCTX ctx, int addr) Python: set_i2c_address The I2C communication between the Zymkey and the Host is encrypted, but will not interfere with other devices on the same bus (assuming there is no address conflict).\nSee API Documentation\nQ: Why does my HSM4 fail to restart after cycling power? Expand for Answer A: HSM4 monitors the quality of 5V power coming into the host computer. If the voltage drops below a specified limit, even momentarily, then HSM4 will disable all security services to the host. This is a security feature to prevent power cycle and brown-own attacks. If you are powering a display, modem, or other power-hungry device from your Pi, then check the capacity and quality of your power supply. Learn more \u003e\nQ: Why is my HSM4 “invisible” to the i2c-tools suite? Expand for Answer A: Some people have become accustomed to using i2c-detect to do a first level check for correct installation and baseline functionality of i2c devices. However, these tools only really work if the i2c device communicates via a protocol that sits on top of i2c called SMBus or SMB (System Management Bus). Instead, HSM4 communicates to the host at a much more fundamental level, in part because the HSM4 protocol traffic is encrypted.\nYou can tell if you successfully installed it by observing the blue LED. If it is flashing once every 3 seconds, then binding completed. You can also use the systemctl command. It should say “active (running)”:\nsystemctl status zkifc\nQ: If the install fails, can I run it more than once? Expand for Answer A: Yes, you should have no problem running it multiple times if it were to fail.\nEncrypting Root File System Summary of steps Start with a blank USB device. USB storage should be twice the size of the SD card. The process for encrypting the SD card stops zkifc. The blue LED will flash rapidly during the encryption process. It will return to blinking once every 3 seconds when complete. The process will automatically do two reboots. Be patient. If the encryption process does not complete, it’s best to start fresh and try again. Q: How can I check if the system matches the default parameters? Expand for Answer A: lsblk will show you the partitions. Look for the name of your / partition (default is mmcblk0p2) and the USB device (default is sda). Example output:\nNAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT mmcblk0 179:0 0 14.9G 0 disk |-mmcblk0p1 179:1 0 256M 0 part /boot `-mmcblk0p2 179:2 0 14.6G 0 part / sda 8:0 0 32.0G 0 disk |_sda1 8:1 0 32.0G 0 part Q: How can I monitor the status after phase 1 reboot? Expand for Answer A: Once you get to the second phase and login, you can monitor progress with\njournalctl -fu cfg_SD_crfs\nThat will show you progress of the second half of the encryption process.\nQ: Can I re-run encryption with the same USB stick? Expand for Answer A: The script is designed to re-use information on the USB stick to encrypt a “golden” image in production on more than one device. If the file original_zk_root.tgz exists on the USB stick, it will use that file and skip the step of creating a whole new tarball of the rootfs. If you truly want to start over, start by reformatting/erasing your USB stick.\nQ: If my PI automounts the USB device, will that interfere with the process? Expand for Answer A: The script attempts to unmount the external device, but in some cricumstances the device may stay mounted and the process will fail. You will get a message either on your screen or in journalctl -fu cfg_SD_crfs during the second phase indicating the drive was already mounted. Unmount the drive and try again.\n# Check /dev/sda* mount points for devices mounted to /media/* lsblk # if mounted, unmount sudo umount /media* # re-run service sudo systemctl restart # monitor progress journalctl -fu cfg_SD_crfs Q: How can I confirm my file system is encrypted and protected? Expand for Answer A: Since zkifc is stopped during the process, the blue LED will flash rapidly until the whole process completes. Once both of the automautic reboots are completed, the blue LED will return to flashing once every 3 seconds.\nlsblk will show you that you now have a “cryptrfs” partition under your mmcblk0p2 (default)\ndf -h will also show “/dev/mapper/cryptrfs” for the “/” file system.\nIf your system reboots twice, the LED returns to flashing once every 3 seconds, and lsblk displays a “cryptrfs” partition, you can be confident your system is encrypted and protected.\nFor more help, see Zymbit’s Community Forum. Features Q: What curves are supported for Zymbit products? Expand for Answer Zymkey and HSM4: NIST P-256 and secp256r1\nHSM6: NIST P-256, secp256r1, secp256k1, X25519, ED25519\nQ: How do I use HSM6’s store_foreign_public_key function to store a Zymkey or HSM4 public key on HSM6? Expand for Answer A: The easiest way is to save the HSM4 key directly to a binary file, copy that file to the HSM6 and read in the binary file.\nHSM4 side:\n#!/usr/bin/python3 import zymkey # Get the public key from slot 0 and save it in a file pub_key_file = '/tmp/pub_key_slot0' slot = 0 key = zymkey.client.get_public_key(slot) with open(pub_key_file, \"wb\") as f: f.write(key) copy /tmp/pub_key_slot0 over to the HSM6 PI\nHSM6 side:\n#!/usr/bin/python3 import zymkey key_file = \"/tmp/pub_key_slot0\" key = open(key_file, \"rb\").read() # Store the key in the foreign key store foreign_slot = zymkey.client.store_foreign_public_key('secp256r1', key) Q: How can I reset the clock to the current timestamp? Expand for Answer A: The clock will sync to the current timestamp once the Pi has achieved NTP sync. This requires you to have access to the Internet.\nQ: How do I access the devices (RTC, accelerometer, crypto) on HSM4? Expand for Answer A: For Zymkey and HSMs, kernel drivers and libraries for all of the devices are included in the Zymkey software package via the APIs.\nQ: My GPG Key expired and I cannot access the Zymkey Repository. How do I update the Key? Expand for Answer A: You can update your existing key with the following command:\ncurl -L https://zk-sw-repo.s3.amazonaws.com/apt-zymkey-pubkey.gpg | apt-key add -\nQ: Can the HSM4 detect if the SD card has been removed? Expand for Answer A: No, but perimeter detect can be configured to prevent access to the SD card. When a tamper event is detected, the HSM4 will, when properly configured via the API, destroy all critical key material and the root fs will fail to be decrypted upon boot.\nBattery \u0026 Power Questions Q: Should I use an external battery on my Zymkey or HSM? Expand for Answer A: The following table compares Zymkey and HSM operational modes while connected to Main Power, Battery Power, and No Power.\nThe battery is required to maintain the Real Time Clock and the perimeter detect circuits when the host power is removed. Without the battery, these two functions will not be active when the host power is removed.\nQ: What happens when the battery dies? How can I change the battery when it dies, without self-destructing my device? Expand for Answer A: If the battery dies and the host is not connected to power, some features will go out, such as Perimeter Detect and Real Time Clock. See the table below for more information.\nWith Zymkey and HSM4, if tamper detect is enabled and the battery dies or is removed, the device will self-destruct. This is an intentional security feature. If tamper detect is NOT enabled, you should connect the host device to power to change the battery.\nHSM6 has a battery monitoring feature to help the user prevent the battery from dying. If the battery dies, HSM6 users have the ability to choose whether the device should self-destruct or hold in reset mode until the battery is changed.\nKernel \u0026 Kernel Boot Questions Q: Can you tell the kernel not to run a shell? Expand for Answer A: Someone could easily replace the kernel and, while it is possible to configure initramfs to not permit the busybox shell to, that can be sidestepped as well. Even if you hack your own changes to the kernel to ignore the init option, someone could replace your kernel. Also, kernel updates would have to be done manually and the updates from the apt repo would have to be blacklisted.\nQ: Can you tell the kernel to ignore cmdline.txt? Expand for Answer A: There are many reasons why this is infeasible, but the main one is that, since the GPU initially functions as a bootloader processor during boot and since Broadcom has not made the GPU compiler publicly available as well as the source code for the bootloader, one cannot simply compile their own code that would ignore cmdline.txt.\nQ: Is it possible to encrypt the boot partition? Expand for Answer A: No because the GPU bootloader does not have encryption features implemented and, even in lieu of that, it does not know how to communicate with HSM4. The best solution, then, would be to implement an independent secure boot procedure. As mentioned above, we are currently working on adding this feature in a future product.\nProduction (“self-destruct”) Mode Questions Q: When using the perimeter-detect feature, does the “self-destruct” mode work (destroy all of its key material) even when the Lock Tab hasn’t been cut? Expand for Answer A: Self-destruct mode works only after the Lock Tab has been cut.\nQ: Is there a way to turn off “self-destruct” mode? Expand for Answer A: No, once turned on, “self-destruct” mode is permanent.\nQ: If my HSM4 does “self-destruct,” can I create new keys and reuse the hardware? Expand for Answer The SBC and SD card hardware will be reusable. Because the SD card contents are encrypted and the decryption key was destroyed, the data is lost. The HSM4 will not be reusable because the key slots will be destroyed. Q: If I cut the Lock-Tab on a HSM4, can I move that HSM4 to another Pi or change the SD card? Expand for Answer A: No. Cutting the Lock-Tab permanently binds that instance of HSM4 to the specific instances of host computer and SD card. This is a security feature to prevent credentials being moved from one host to another. DO NOT cut the Lock-Tab if you are still in development and expect to change the host or SD cards.\nQ: Will HSM4 still self-destruct, even when my SBC is powered off? Expand for Answer A: Yes, because HSM4 is battery powered. As long as the battery is sufficiently charged, it will still self-destruct.\nOther Q: Where can I learn about and/or pre-order future products? Expand for Answer A: Sign up for our new product email updates at the bottom of Zymbit’s homepage.\nQ: Which SBCs are compatible with HSM4? Expand for Answer Electrically, the Zymkey-I2C will interface to any single board computer using I2C. Check compatibility with your particular Linux distribution. Raspberry Pi 3, 3B+, 4, Zero RPi Compute Module 3, 4 Q: Does HSM4 work with Arduino? Expand for Answer A: We have no plans to release an Arduino shield version. While we love Arduinos and use them all the time, they generally don’t have enough resources to handle cryptographic operations at this level.\nQ: Does HSM4 work with BeagleBone? Expand for Answer A: Zymbit does not officially support the BeagleBoard platform at this time.\nQ: Which operating systems does HSM4 support? Expand for Answer Q: How much power does HSM4 consume? Expand for Answer HSM4-RPi (3.3V): idle approx. 1mA; max active \u003c 25mA with LED off, \u003c 35mA with LED on. HSM4-USB (5V): idle approx. 1.5mA; max active \u003c 40mA with LEDs off, \u003c 60mA with LEDs on. See Power Quality for more information.\n","categories":"","description":"","excerpt":" Troubleshooting Troubleshooting Checklist Before contacting Zymbit …","ref":"/troubleshooting/hsm4/","tags":"","title":"HSM4 FAQ \u0026 Troubleshooting"},{"body":"3D Step Model SCM 3D model\n2D Drawing ","categories":"","description":"","excerpt":"3D Step Model SCM 3D model\n2D Drawing ","ref":"/reference/cad/scm/","tags":"","title":"SCM CAD Files"},{"body":"Updated: 2022-09-30\nWhat is a Cryptographic ECDSA Signature? An ECDSA (Elliptic Curve Digital Signature Algorithm) signature is generated by a private key in the elliptic curve family. We use these signatures as proof of identity (private key owner) and proof that the message has not been tampered with during the journey.\nSignatures are effectively a user’s wax seal on an envelope. Signatures play a huge role at the low level in blockchain. All data must be signed before being transmitted to the blockchain.\nWhy use hardware wallets like our Zymbit modules? Hardware wallets are built to securely store private keys on their hardware. Hardware wallets are more secure and harder to penetrate than locally saved private keys on computers, as computers have a lot more attack vectors through user access, malware, network, etc.\nThe private keys stored in our modules are never exportable and are always hidden even from the user.\nUseful Resources: Ethereum Yellow Paper RLP (Recursive Length Prefix) Wiki Prerequisites Zymbit Modules that support this feature:\nHSM6 SCM Follow the Getting Started guide first, installing all baseline software.\nAll code snippets written in this article are written using python3. For more Zymbit API documentation (Python/C/C++) visit: API Documentation\nPython libraries used in this example:\nThis library is used for rlp encoding apt install pandoc This library is used for Crypto.Hash() functions. In this example we will be using keccak hashes. pip3 install pycryptodome Web3 for easy-to-use blockchain development. pip3 install web3 Setting up Infura project The quickest way to interact with the ethereum blockchain network is to use remote providers like: Infura, Alchemy, or QuickNode. For this example, we will use Infura to interact with our web3 code.\nCreate an Infura Account and log in. Create a new project this can be named anything you want. Go to project settings and change the endpoints dropdown from Mainnet-\u003eGoerli. Goerli is the test network we will be testing our transaction on. Write down the web link to our test project for web3 to communicate with. Warning If you are developing in Infura moving forward, make sure to not give out the project secret and project ID! Web3 Example Import the python libs we need: Import zymkey to open up a zymkey instance, so we can communicate to our zymbit products for key generation and ecdsa signatures. Import binascii for simple hexlify() and unhexlify() functions. Per Ethereum standards, import RLP for data compression and Keccak for hashing. Import Web3 for simple communication to Ethereum nodes. #!/usr/bin/python3 import zymkey import binascii import rlp from rlp.sedes import binary, Binary, big_endian_int, BigEndianInt, List, CountableList, boolean from Crypto.Hash import keccak from web3 import Web3 Open a Web3 instance: Using the endpoint link from our Infura project, open a Web3 instance object.\n# Create web3 instance, from infura project (node) connecting to Goerli test network w3 = Web3(Web3.HTTPProvider('https://goerli.infura.io/v3/9f06183d0529494792242beb59be4ad3')) Generating a secp256k1 key pair to be the sender: Ethereum network is based off the Koblitz curve “secp256k1”, so individual accounts are generated from secp256k1 public/private key pairs. The private key in the key pair is used to sign/encrypt data to be sent to the network or other users.\nThe public key in the key pair is used to verify the data owner’s identity and decrypt the data received. The public key can not be reverse engineered to get the private key. It is safe to send out the public key to other users.\nWarning Never send another user a private key! The Zymbit hardware wallet never exposes the private key. Generate a secp256k1 key pair and export the public key from the slot to use later.\n# Ethereum is based on secp256k1 (Koblitz curve). Generate a \"secp256k1\" key pair using Zymbit API functions. zymkey_pub_key_slot = zymkey.client.gen_key_pair(\"secp256k1\") pub_key = zymkey.client.get_public_key(zymkey_pub_key_slot) print(\"zymkey secp256k1 public key:\\n%s\" % pub_key) Generate the Ethereum public address/account from the secp256k1 public key The next step covers generating an Ethereum public address. An Ethereum address is akin to a user’s account number on the Ethereum network and will be used to identify your transactions. Ethereum addresses look like this: 0x15C25E6EB5dE729d7e310d059e59659cCB86E6f6.\nDetails on how the Ethereum standard formulates a checksum address (public address) from a secp256k1 public key.\n# Get ECDSA secp256k1 public key from zymkey and generate our Ethereum sender's checksum address # Keccak Hash the public key and save only the last 20 bytes of the hash. This is to prevent reverse-engineering # of the public address back to the original public key. keccak_hash = keccak.new(digest_bits=256) keccak_hash.update(pub_key) keccak_digest = keccak_hash.hexdigest() # Take the last 20 bytes wallet_len = 40 wallet_addr = \"0x\" + keccak_digest[-wallet_len:] We then need to randomize the capitalization of these values via EIP-55 standard.\n# A built-in EIP-55 easy one-liner from Web3 checksum = Web3.toChecksumAddress(wallet_addr) print(\"Eth Checksum:\\n%s\" % checksum) --OR–\n#Performing EIP-55 ourselves checksum = \"0x\" # Remove '0x' from the address address = wallet_addr[2:] address_byte_array = address.encode(\"utf-8\") keccak_hash = keccak.new(digest_bits=256) keccak_hash.update(address_byte_array) keccak_digest = keccak_hash.hexdigest() for i in range(len(address)): address_char = address[i] keccak_char = keccak_digest[i] if int(keccak_char, 16) \u003e= 8: checksum += address_char.upper() else: checksum += str(address_char) print(\"Eth Checksum:\\n%s\" % checksum) Verify this is a valid ethereum public address using web3:\nprint(\"Valid checksum:\\n%s\" % Web3.isAddress(checksum)) This is the ethereum public address of our sender. The sender signs the transaction and sends it out. Once the receiver gets the transaction they will see it was from this sender’s address.\nNotice To properly send out transaction to the Goerli test network with this sender’s address. We need funds in this address to pay for the fees required to send out this transaction.\nBecause Goerli is a test network for development, we can fund ethereum addresses for free with test ether. (Note: There is only one address per day limit).\nYou can do this here: Goerli Faucet\nCreating the transaction classes and making them rlp.serializable() RLP (Recursive Length Prefix) is a encoding method to compress binary and arrays of data. RLP is the official encoding method used on the ethereum network. So to abide by the standard we need to create a transaction class object, which have attributes that are rlp serializable. Thankfully the rlp library(pandoc) we installed earlier, lets us do this easily by subclassing rlp.serializable.\nAs of the london hard fork in august 2021, Ethereum Mainnet accepts multiple transaction types. There are currently three transaction types:\nTransaction Legacy [Type 0] Transaction EIP-2930 [Type 1] Transaction EIP-1559 [Type 2] All transactions are accepted by Mainnet and there will be more transaction types in the future. For this example, we will show generating and signing Transaction Legacy (it was used for a long period of time) and Transaction EIP-1559 (the current default transaction on Mainnet).\nCreate our rlp.serializable transaction classes (Order of attributes matter!):\n#------------------------------------Abstract Type Declaractions------------------------------------------------------------------------------------ # This is a rlp serializable type for accessList param in Transaction EIP-2930 and EIP-1559 access_list_sede_type = CountableList(List([Binary.fixed_length(20, allow_empty=False), CountableList(BigEndianInt(32)),]),) #------------------------------------Class Definitions---------------------------------------------------------------------------------------------- # Transaction Legacy class TransactionLegacy(rlp.Serializable): fields = [ (\"nonce\", big_endian_int), (\"gasPrice\", big_endian_int), (\"gasLimit\", big_endian_int), (\"to\", Binary.fixed_length(20, allow_empty=True)), (\"value\", big_endian_int), (\"data\", binary), (\"v\", big_endian_int), (\"r\", big_endian_int), (\"s\", big_endian_int), ] # Transaction EIP-1559 class RawTransactionType1559(rlp.Serializable): transaction_type = 2 fields = [ (\"chainId\", big_endian_int), (\"nonce\", big_endian_int), (\"maxPriorityFeePerGas\", big_endian_int), (\"maxFeePerGas\", big_endian_int), (\"gas\", big_endian_int), (\"to\", Binary.fixed_length(20, allow_empty=True)), (\"value\", big_endian_int), (\"data\", binary), (\"accessList\", access_list_sede_type), ] class SignedTransactionType1559(rlp.Serializable): transaction_type = 2 fields = [ (\"chainId\", big_endian_int), (\"nonce\", big_endian_int), (\"maxPriorityFeePerGas\", big_endian_int), (\"maxFeePerGas\", big_endian_int), (\"gas\", big_endian_int), (\"to\", Binary.fixed_length(20, allow_empty=True)), (\"value\", big_endian_int), (\"data\", binary), (\"accessList\", access_list_sede_type), (\"yParity\", boolean), (\"r\", big_endian_int), (\"s\", big_endian_int), ] Create the example transaction to send Create an example transaction to send out on the Goerli test network:\n# grab nonce value of sender's account. nonce = number of transactions nonce = w3.eth.getTransactionCount(checksum) print(\"Nonce value:\\n %i\" % nonce) # Example receiver's address receiver_addr = '0x15C25E6EB5dE729d7e310d059e59659cCB86E6f6' # Goerli chain ID is 3 chain_id = 3 # prepare the transaction, chainID 3 is goerli transaction_legacy = TransactionLegacy(nonce = nonce, gasPrice = 500000, gasLimit = 800000, to = binascii.unhexlify(receiver_addr.replace('0x', '')), value = 5, data = b'hello', v = chain_id, r = 0, s = 0) transaction_1559 = RawTransactionType1559(chainId = chain_id, nonce = nonce, maxPriorityFeePerGas = 150000, maxFeePerGas = 150000, gas = 210000, to = binascii.unhexlify(receiver_addr.replace('0x', '')), value = 10, data = b'world', accessList = []) Preparing our transaction to be signed by the Zymbit hardware So the two steps to prepare our transaction for signing:\nRLP encode the transaction Keccak Hash the RLP encoded transaction Per Ethereum standard the signature elements are generated for these transaction types via:\nTransaction Legacy The signature_r, signature_s elements of this transaction represent a secp256k1 signature over keccak256(rlp([nonce, gasPrice, gasLimit, to, value, data, v, r, s])) r,s are defaulted to 0 v will be the chain_id of the network signature_v follows EIP-155 Transaction EIP-1559 The signature_y_parity, signature_r, signature_s elements of this transaction represent a secp256k1 signature over keccak256(0x02 || rlp([chain_id, nonce, max_priority_fee_per_gas, max_fee_per_gas, gas_limit, destination, amount, data, access_list])) chain_id and y_parity are now seperate params. And because our transaction classes subclass rlp.serializable, we can simply rlp encode these class objects via:\n# RLP encode the transaction encoded_transaction_legacy = rlp.encode(transaction_legacy) print(\"encoded transaction:\\n%s\" % binascii.hexlify(encoded_transaction_legacy).decode(\"utf-8\")) # Transaction type is now a byte added to the front of the rlp encoded object encoded_transaction_1559 = bytes([2]) + rlp.encode(transaction_1559) print(\"encoded transaction:\\n%s\" % binascii.hexlify(encoded_transaction_1559).decode(\"utf-8\")) Next, step 2 is to keccak hash the rlp encoded transaction\n#Per Ethereum standards, Keccak hash rlp encoded transaction keccak_hash=keccak.new(digest_bits=256) keccak_hash.update(encoded_transaction) print(\"keccak_hash:\\n%s\" % keccak_hash.hexdigest()) Signing the transaction data with a private key stored on the Zymbit module. Sign this keccak hashed transaction with the private secp256k1 key we generated. This ECDSA signature we get will give us signature_r, signature_s, signature_v, and the y-parity.\nsignature_V is only required by TransactionLegacy and follow EIP-155.\nThe other transaction types split up chain ID and Y parity as separate parameters. # sign the transaction hash and calculate v, r, s values signature, y_parity = zymkey.client.sign_digest(keccak_hash, zymkey_pub_key_slot, return_recid=True) print (\"ECDSA Signature:\\n%s\" % signature) print(\"ECDSA Sig Length:\\n%s\" % len(signature)) # Verify the ECDSA signature. Make sure our public key can decrypt this signature. verify_sig = zymkey.client.verify_digest(keccak_hash, signature, True, zymkey_pub_key_slot, False) print(\"Verify sig:\\n%s\" % verify_sig) # Signature consists of a R, S, V # R is the first half of the signature converted to int # S is the second half of the signature converted to int # From EIP 155, V = chainId * 2 + 35 + recovery_id of public key # Per Ethereum yellow paper, if S * 2 \u003e= N, then S becomes N - S and Y-parity is flipped N = 115792089237316195423570985008687907852837564279074904382605163141518161494337 r = int.from_bytes(signature[:32], \"big\") s = int.from_bytes(signature[-32:], \"big\") y_parity = bool(y_parity.value) if((s*2) \u003e= N): y_parity = not y_parity s = N - s # EIP-155 V is only required in TransactionLegacy, as other transaction types split up chain_id and y_parity. v = chain_id * 2 + 35 + int(y_parity) print (\"R:\\n%s\" % r) print (\"S:\\n%s\" % s) print (\"V:\\n%s\" % v) print (\"Y Parity:\\n%s\" % y_parity) Adding our signature to our transaction class Transaction Legacy’s signature elements are:\nSignature_R Signature_S Signature_V # We create our TransactionLegacy again, except we fill our v, r, s fields with the appropriate values. signed_transaction_legacy = TransactionLegacy(transaction_legacy.nonce, transaction_legacy.gasPrice, transaction_legacy.gasLimit, transaction_legacy.to, transaction_legacy.value, transaction_legacy.data, v, r, s) Transaction EIP-1559’s signature elements are:\nSignature_R Signature_S Y-Parity of the Signature # We create our SignedTransactionType1559 from RawTransactionType1559, except we fill our yParity, r, s fields with the appropriate values. signed_transaction_1559 = SignedTransactionType1559(transaction_1559.chainId, transaction_1559.nonce, transaction_1559.maxPriorityFeePerGas, transaction_1559.maxFeePerGas, transaction_1559.gas, transaction_1559.to, transaction_1559.value, transaction_1559.data, transaction_1559.accessList, y_parity, r, s) One Last Step before send off. RLP encode the signed transaction. Same as the rlp encoding step before.\n# RLP encode the transaction encoded_transaction_legacy = rlp.encode(signed_transaction_legacy) print(\"encoded transaction:\\n%s\" % binascii.hexlify(encoded_transaction_legacy).decode(\"utf-8\")) # Transaction type is now a byte added to the front of the rlp encoded object encoded_transaction_1559 = bytes([2]) + rlp.encode(signed_transaction_1559) print(\"encoded transaction:\\n%s\" % binascii.hexlify(encoded_transaction_1559).decode(\"utf-8\")) We can also validate that this transaction can be broadcasted, by pasting that encoded transaction in the myCrypto broadcast tool.\nSend your transaction Broadcast the transaction through our web3 instance.\n# send raw transaction transaction_result_hash = w3.eth.sendRawTransaction(encoded_signed_transaction) print(\"Transaction broadcast hash:\\n%s\" % binascii.hexlify(transaction_result_hash).decode(\"utf-8\")) If successfully broadcasted, you should get a broadcast hash receipt back. You can view your transaction’s validation progress on the network by pasting that hash receipt here: https://goerli.etherscan.io/\nWarning If you get Error: “Not enough funds or gas”\nTo properly send out transaction to the Goerli test network with this sender’s address, there must be adequate funds in this address to pay for the fees required to send out this transaction. Because Goerli is a test network for development, we can fund ethereum addresses for free with test ether. There is a one IP address per day limit).\nYou can do this here: Goerli Faucet\nFull Example Code Below is the entire code used in the above examples.\n#!/usr/bin/python3 import zymkey import binascii import rlp from rlp.sedes import binary, Binary, big_endian_int, BigEndianInt, List, CountableList, boolean from Crypto.Hash import keccak from web3 import Web3 #------------------------------------Abstract Type Declaractions------------------------------------------------------------------------------------ # This is a rlp serializable type for accessList param access_list_sede_type = CountableList(List([Binary.fixed_length(20, allow_empty=False), CountableList(BigEndianInt(32)),]),) #------------------------------------Class Definitions---------------------------------------------------------------------------------------------- class TransactionLegacy(rlp.Serializable): fields = [ (\"nonce\", big_endian_int), (\"gasPrice\", big_endian_int), (\"gasLimit\", big_endian_int), (\"to\", Binary.fixed_length(20, allow_empty=True)), (\"value\", big_endian_int), (\"data\", binary), (\"v\", big_endian_int), (\"r\", big_endian_int), (\"s\", big_endian_int), ] class RawTransactionType1559(rlp.Serializable): transaction_type = 2 fields = [ (\"chainId\", big_endian_int), (\"nonce\", big_endian_int), (\"maxPriorityFeePerGas\", big_endian_int), (\"maxFeePerGas\", big_endian_int), (\"gas\", big_endian_int), (\"to\", Binary.fixed_length(20, allow_empty=True)), (\"value\", big_endian_int), (\"data\", binary), (\"accessList\", access_list_sede_type), ] class SignedTransactionType1559(rlp.Serializable): transaction_type = 2 fields = [ (\"chainId\", big_endian_int), (\"nonce\", big_endian_int), (\"maxPriorityFeePerGas\", big_endian_int), (\"maxFeePerGas\", big_endian_int), (\"gas\", big_endian_int), (\"to\", Binary.fixed_length(20, allow_empty=True)), (\"value\", big_endian_int), (\"data\", binary), (\"accessList\", access_list_sede_type), (\"yParity\", boolean), (\"r\", big_endian_int), (\"s\", big_endian_int), ] #------------------------------------------------------------------------------------------------------------------------------------------------------ # create web3 instance, from infura project (node) connecting to goerli test network w3 = Web3(Web3.HTTPProvider('https://goerli.infura.io/v3/9f06183d0529494792242beb59be4ad3')) # Example receiver's address receiver_addr = '0x15C25E6EB5dE729d7e310d059e59659cCB86E6f6' # Ethereum is based on secp256k1, so we generate a \"secp256k1\" key pair using zymbit libs. # Get ECDSA secp256k1 public key from zymkey and generate our Ethereum sender's checksum address zymkey_pub_key_slot = zymkey.client.gen_key_pair(\"secp256k1\") pub_key = zymkey.client.get_public_key(zymkey_pub_key_slot) print(\"zymkey secp256k1 public key:\\n%s\" % pub_key) keccak_hash = keccak.new(digest_bits=256) keccak_hash.update(pub_key) keccak_digest = keccak_hash.hexdigest() # Take the last 20 bytes wallet_len = 40 wallet_addr = \"0x\" + keccak_digest[-wallet_len:] # checksum = Web3.toChecksumAddress(wallet_addr) # How eip-55 calculates checksum checksum = \"0x\" # Remove ‘0x’ from the address address = wallet_addr[2:] address_byte_array = address.encode(\"utf-8\") keccak_hash = keccak.new(digest_bits=256) keccak_hash.update(address_byte_array) keccak_digest = keccak_hash.hexdigest() for i in range(len(address)): address_char = address[i] keccak_char = keccak_digest[i] if int(keccak_char, 16) \u003e= 8: checksum += address_char.upper() else: checksum += str(address_char) print(\"Eth Checksum:\\n%s\" % checksum) print(\"Valid checksum:\\n%s\" % Web3.isAddress(checksum)) # grab nonce value of sender's account. nonce = number of transactions nonce = w3.eth.getTransactionCount(checksum) print(\"Nonce value:\\n %i\" % nonce) # Goerli chain ID is 3 chain_id = 3 # prepare the transaction, chainID 3 is goerli transaction_legacy = TransactionLegacy(nonce = nonce, gasPrice = 500000, gasLimit = 800000, to = binascii.unhexlify(receiver_addr.replace('0x', '')), value = 5, data = b'hello', v = chain_id, r = 0, s = 0) transaction_1559 = RawTransactionType1559(chainId = chain_id, nonce = nonce, maxPriorityFeePerGas = 150000, maxFeePerGas = 150000, gas = 210000, to = binascii.unhexlify(receiver_addr.replace('0x', '')), value = 10, data = b'world', accessList = []) #----------------------------------------Send Transaction Legacy with zymkey signature----------------------------------------------------------------- # Sign a transaction with a signature generated by hsm6 # RLP encode the transaction encoded_transaction = rlp.encode(transaction_legacy) print(\"encoded transaction:\\n%s\" % binascii.hexlify(encoded_transaction).decode(\"utf-8\")) # Per Ethereum standards, Keccak hash rlp encoded transaction keccak_hash=keccak.new(digest_bits=256) keccak_hash.update(encoded_transaction) print(\"keccak_hash:\\n%s\" % keccak_hash.hexdigest()) # sign the transaction hash and calculate v, r, s values signature, y_parity = zymkey.client.sign_digest(keccak_hash, zymkey_pub_key_slot, return_recid=True) print (\"ECDSA Signature:\\n%s\" % signature) print(\"ECDSA Sig Length:\\n%s\" % len(signature)) print(\"ECDSA Sig Y Parity:\\n%s\" % y_parity.value) # Verify the ECDSA signature. verify_sig = zymkey.client.verify_digest(keccak_hash, signature, True, zymkey_pub_key_slot, False) print(\"Verify sig:\\n%s\" % verify_sig) # Signature consists of a R, S, V # R is the first half of the signature converted to int # S is the second half of the signature converted to int # From EIP 155, V = chainId * 2 + 35 + recovery_id of public key # Per Ethereum yellow paper, if S * 2 \u003e= N, then S becomes N - S and Y-parity is flipped N = 115792089237316195423570985008687907852837564279074904382605163141518161494337 r = int.from_bytes(signature[:32], \"big\") s = int.from_bytes(signature[-32:], \"big\") y_parity = bool(y_parity.value) if((s*2) \u003e= N): y_parity = not y_parity s = N - s v = chain_id * 2 + 35 + int(y_parity) print (\"R:\\n%s\" % r) print (\"S:\\n%s\" % s) print (\"V:\\n%s\" % v) # RLP encode the transaction along with the full signature signed_transaction = TransactionLegacy(transaction_legacy.nonce, transaction_legacy.gasPrice, transaction_legacy.gasLimit, transaction_legacy.to, transaction_legacy.value, transaction_legacy.data, v, r, s) encoded_signed_transaction = rlp.encode(signed_transaction) print(\"encoded signed transaction:\\n%s\" % binascii.hexlify(encoded_signed_transaction).decode(\"utf-8\")) # send raw transaction transaction_result_hash = w3.eth.sendRawTransaction(encoded_signed_transaction) print(\"Transaction broadcast hash:\\n%s\" % binascii.hexlify(transaction_result_hash).decode(\"utf-8\")) #----------------------------------------------------------------------------------------------------------------------------------------- #------------------------------Send Transaction Type EIP-1559 with zymkey signature------------------------------------------------------- # Sign a transaction with a signature generated by hsm6 # RLP encode the transaction. Eip-1559 transaction is assigned type_id \"2\". # So the payload is 0x02 || rlp([chain_id, nonce, max_priority_fee_per_gas, max_fee_per_gas, gas_limit, destination, amount, data, access_list, signature_y_parity, signature_r, signature_s]) encoded_transaction = bytes([2]) + rlp.encode(transaction_1559) print(\"encoded transaction:\\n%s\" % binascii.hexlify(encoded_transaction).decode(\"utf-8\")) # Per Ethereum standards, Keccak hash rlp encoded transaction keccak_hash=keccak.new(digest_bits=256) keccak_hash.update(encoded_transaction) print(\"keccak_hash:\\n%s\" % keccak_hash.hexdigest()) # sign the transaction hash and calculate y-parity, r, s values signature, y_parity = zymkey.client.sign_digest(keccak_hash, zymkey_pub_key_slot, return_recid=True) print (\"ECDSA Signature:\\n%s\" % signature) print(\"ECDSA Sig Length:\\n%s\" % len(signature)) print(\"ECDSA Sig Y Parity:\\n%s\" % y_parity.value) # Verify the ECDSA signature. verify_sig = zymkey.client.verify_digest(keccak_hash, signature, True, zymkey_pub_key_slot, False) print(\"Verify sig:\\n%s\" % verify_sig) # Signature consists of a R, S, Y-parity # R is the first half of the signature converted to int # S is the second half of the signature converted to int # Per Ethereum yellow paper, if S * 2 \u003e= N, then S becomes N - S and Y-parity is flipped N = 115792089237316195423570985008687907852837564279074904382605163141518161494337 r = int.from_bytes(signature[:32], \"big\") s = int.from_bytes(signature[-32:], \"big\") y_parity = bool(y_parity.value) if((s*2) \u003e= N): y_parity = not y_parity s = N - s print (\"R:\\n%s\" % r) print (\"S:\\n%s\" % s) print (\"y_parity:\\n%s\" % y_parity) # RLP encode the transaction along with the full signature signed_transaction = SignedTransactionType1559(transaction_1559.chainId, transaction_1559.nonce, transaction_1559.maxPriorityFeePerGas, transaction_1559.maxFeePerGas, transaction_1559.gas, transaction_1559.to, transaction_1559.value, transaction_1559.data, transaction_1559.accessList, y_parity, r, s) # Tack on the same transaction type byte to the final transaction before being sent out encoded_signed_transaction = bytes([2]) + rlp.encode(signed_transaction) print(\"encoded signed transaction:\\n%s\" % binascii.hexlify(encoded_signed_transaction).decode(\"utf-8\")) # send raw transaction transaction_result_hash = w3.eth.sendRawTransaction(encoded_signed_transaction) print(\"Transaction broadcast hash:\\n%s\" % binascii.hexlify(transaction_result_hash).decode(\"utf-8\")) #--------------------------------------------------------------------------------------------------------------------------------- ","categories":"","description":"","excerpt":"Updated: 2022-09-30\nWhat is a Cryptographic ECDSA Signature? An ECDSA …","ref":"/tutorials/digital-wallet/ethereum-signing-example/","tags":"","title":"Sending a Web3 Ethereum Transaction"},{"body":"","categories":"","description":"","excerpt":"","ref":"/getting-started/hsm6/","tags":"","title":"HSM6"},{"body":" Troubleshooting Troubleshooting Checklist Before contacting Zymbit with troubleshooting related questions, please read through the following troubleshooting checklist.\nPower supply. The recommended power for the PI4 is 5V and 3 amps. Most of the problems we see are from a poor power source. Start with a good power supply from the PI foundation or Canakit, not a phone charger. I2C enabled. Double check that you have enabled the I2C bus. An easy way to check is “ls -l /dev/i2c-1”. If /dev/i2c-1 exists, the I2C bus is enabled. apt update and upgrade. Be sure that your software is up to date. Installation. The curl script will reboot your system once completed. After the reboot, the blue LED on your Zymbit device should blink once every 3 seconds. You must get to this step before proceeding to encryption, etc. If your issue is not related to any of the above list, read through the FAQ below to see if your issue is answered. If you still do not see a solution to your problem, reach out on our Community Forum. Thank you!\nQ: Why does the LED continue to blink rapidly? It never blinks with the described pattern of once (in Development mode) or three times (in Production mode) every three seconds. Expand for Answer A: Check the following:\nCheck that the Raspberry Pi power is sufficient. The red LED on most Raspberry Pi models indicates if the Pi is being powered adequately. If it is not lit at all or flashes intermittently, try a different power supply or a different USB cable. For the RPi4, your power supply must provide at least 3 Amps.\nMake sure that you have enabled i2c support using raspi-config BEFORE your install the software. Also, when you enable i2c communications be sure to follow the enable-disable-enable sequence.\nIf i2c support has been enabled correctly and the HSM6 LED is still rapidly blinking, check proper physical installation of the HSM6 as detailed in this “Getting Started” guide.\nHSM6 uses GPIO header pins 3 and 5 for i2c communications and pin 7 as an interrupt signal to the Pi. Pin 7 should preferably be dedicated exclusively to HSM6. Other devices may share the i2c bus with HSM6, but there may still be address conflicts. By default, HSM6 uses slave address 0x30. If the address conflict cannot be resolved on the other i2c devices, there is a way of changing the i2c address through an API call. Using this application, the HSM6 address can be changed anywhere in the ranges of 0x30-0x37 or 0x60-0x67.\nExpand for API information to change i2c address Python: set_i2c_address\nC: int zkSetI2CAddr ( zkCTX ctx, int addr)\nSee API Documentation\nOftentimes the 1-Wire interface relies on pin 7 (GPIO 4) for communication. If the 1-Wire interface is enabled, try disabling through raspi-config. If that resolves the problem take steps to either move the HSM6 interrupt signal from GPIO 4 or the 1-Wire interface from GPIO 4.\nif the directory at /var/lib/zymbit or any of the files and/or subdirectories are corrupted or deleted, the HSM6 will fail to work. IMPORTANT: if this happens when the HSM6 is locked (i.e. Production Mode), the HSM6 can never be used again.\nQ: The LED blinks rapidly when booting, but eventually turns off. It doesn’t blink once or three times every 3 seconds as described. Expand for Answer A: This issue could be caused by the same issues described in the first question (Why does the LED continue to blink rapidly?). Additionally, this can be caused if a locked (Production Mode) HSM6 is moved to another Pi.\nQ: What do the different LED blinking patterns mean? Expand for Answer 1 second very rapid flash, 1 second off, 8 slow blinks This indicates interrupted communications. 1 second very rapid flash, 1 second off, 5 slow blinks This indicates a failure to communicate with ATECC. The most likely cause is the HSM6 is in Production Mode, tamper detect was set to self-destruct, and a tamper detect event caused the HSM6 to self-destruct. If tamper detect is not armed, this indicates a hardware problem. Constant rapid blinking (waiting for host to connect) This indicates that you HSM6 is operational but has not bound to the host. If the HSM6 continues to blink this pattern, it could mean that there is a problem with the host Pi or that the i2c is not configured or that the i2c and wake pins are not making contact. Once every 3 seconds This indicates that your HSM6 is working and running. Three rapid blinks every 3 seconds This indicates the HSM6 is in Production Mode and is working and running. Rapid blinking then LED off permanently This indicates the HSM6 is in Production Mode but cannot bind with the RPi / SD card pair. In Production Mode the binding with a particular Pi and SD card becomes permanent. Most likely cause for this is that the HSM6, the SD card, or the PI has been swapped out. Q: How do I set an alternative I2C address? Expand for Answer A: You can change the I2C address through our standard APIs:\nC: int zkSetI2CAddr ( zkCTX ctx, int addr) Python: set_i2c_address The I2C communication between the Zymkey and the Host is encrypted, but will not interfere with other devices on the same bus (assuming there is no address conflict).\nSee API Documentation\nQ: Why does my HSM6 fail to restart after cycling power? Expand for Answer A: HSM6 monitors the quality of 5V power coming into the host computer. If the voltage drops below a specified limit, even momentarily, then HSM6 will disable all security services to the host. This is a security feature to prevent power cycle and brown-own attacks. If you are powering a display, modem, or other power-hungry device from your Pi, then check the capacity and quality of your power supply. Learn more \u003e\nQ: Why is my HSM6 “invisible” to the i2c-tools suite? Expand for Answer A: Some people have become accustomed to using i2c-detect to do a first level check for correct installation and baseline functionality of i2c devices. However, these tools only really work if the i2c device communicates via a protocol that sits on top of i2c called SMBus or SMB (System Management Bus). Instead, HSM6 communicates to the host at a much more fundamental level, in part because the HSM6 protocol traffic is encrypted.\nYou can tell if you successfully installed it by observing the blue LED. If it is flashing once every 3 seconds, then binding completed. You can also use the systemctl command. It should say “active (running)”:\nsystemctl status zkifc\nQ: If the install fails, can I run it more than once? Expand for Answer A: Yes, you should have no problem running it multiple times if it were to fail.\nEncrypting Root File System Summary of steps Start with a blank USB device. USB storage should be twice the size of the SD card. The process for encrypting the SD card stops zkifc. The blue LED will flash rapidly during the encryption process. It will return to blinking once every 3 seconds when complete. The process will automatically do two reboots. Be patient. If the encryption process does not complete, it’s best to start fresh and try again. Q: How can I check if the system matches the default parameters? Expand for Answer A: lsblk will show you the partitions. Look for the name of your / partition (default is mmcblk0p2) and the USB device (default is sda). Example output:\nNAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT mmcblk0 179:0 0 14.9G 0 disk |-mmcblk0p1 179:1 0 256M 0 part /boot `-mmcblk0p2 179:2 0 14.6G 0 part / sda 8:0 0 32.0G 0 disk |_sda1 8:1 0 32.0G 0 part Q: How can I monitor the status after phase 1 reboot? Expand for Answer A: Once you get to the second phase and login, you can monitor progress with\njournalctl -fu cfg_SD_crfs\nThat will show you progress of the second half of the encryption process.\nQ: Can I re-run encryption with the same USB stick? Expand for Answer A: The script is designed to re-use information on the USB stick to encrypt a “golden” image in production on more than one device. If the file original_zk_root.tgz exists on the USB stick, it will use that file and skip the step of creating a whole new tarball of the rootfs. If you truly want to start over, start by reformatting/erasing your USB stick.\nQ: If my PI automounts the USB device, will that interfere with the process? Expand for Answer A: The script attempts to unmount the external device, but in some cricumstances the device may stay mounted and the process will fail. You will get a message either on your screen or in journalctl -fu cfg_SD_crfs during the second phase indicating the drive was already mounted. Unmount the drive and try again.\n# Check /dev/sda* mount points for devices mounted to /media/* lsblk # if mounted, unmount sudo umount /media* # re-run service sudo systemctl restart # monitor progress journalctl -fu cfg_SD_crfs Q: How can I confirm my file system is encrypted and protected? Expand for Answer A: Since zkifc is stopped during the process, the blue LED will flash rapidly until the whole process completes. Once both of the automautic reboots are completed, the blue LED will return to flashing once every 3 seconds.\nlsblk will show you that you now have a “cryptrfs” partition under your mmcblk0p2 (default)\ndf -h will also show “/dev/mapper/cryptrfs” for the “/” file system.\nIf your system reboots twice, the LED returns to flashing once every 3 seconds, and lsblk displays a “cryptrfs” partition, you can be confident your system is encrypted and protected.\nFor more help, see Zymbit’s Community Forum. Features Q: What curves are supported for Zymbit products? Expand for Answer Zymkey and HSM4: NIST P-256 and secp256r1\nHSM6: NIST P-256, secp256r1, secp256k1, X25519, ED25519\nQ: How do I use HSM6’s store_foreign_public_key function to store a Zymkey or HSM4 public key on HSM6? Expand for Answer A: The easiest way is to save the HSM4 key directly to a binary file, copy that file to the HSM6 and read in the binary file.\nHSM4 side:\n#!/usr/bin/python3 import zymkey # Get the public key from slot 0 and save it in a file pub_key_file = '/tmp/pub_key_slot0' slot = 0 key = zymkey.client.get_public_key(slot) with open(pub_key_file, \"wb\") as f: f.write(key) copy /tmp/pub_key_slot0 over to the HSM6 PI\nHSM6 side:\n#!/usr/bin/python3 import zymkey key_file = \"/tmp/pub_key_slot0\" key = open(key_file, \"rb\").read() # Store the key in the foreign key store foreign_slot = zymkey.client.store_foreign_public_key('secp256r1', key) Q: How can I reset the clock to the current timestamp? Expand for Answer A: The clock will sync to the current timestamp once the Pi has achieved NTP sync. This requires you to have access to the Internet.\nQ: How do I access the devices (RTC, accelerometer, crypto) on HSM6? Expand for Answer A: For Zymkey and HSMs, kernel drivers and libraries for all of the devices are included in the Zymkey software package via the APIs.\nQ: My GPG Key expired and I cannot access the Zymkey Repository. How do I update the Key? Expand for Answer A: You can update your existing key with the following command:\ncurl -L https://zk-sw-repo.s3.amazonaws.com/apt-zymkey-pubkey.gpg | apt-key add -\nQ: Can the HSM6 detect if the SD card has been removed? Expand for Answer A: No, but perimeter detect can be configured to prevent access to the SD card. When a tamper event is detected, the HSM6 will, when properly configured via the API, destroy all critical key material and the root fs will fail to be decrypted upon boot.\nBattery \u0026 Power Questions Q: Should I use an external battery on my Zymkey or HSM? Expand for Answer A: The following table compares Zymkey and HSM operational modes while connected to Main Power, Battery Power, and No Power.\nThe battery is required to maintain the Real Time Clock and the perimeter detect circuits when the host power is removed. Without the battery, these two functions will not be active when the host power is removed.\nQ: What happens when the battery dies? How can I change the battery when it dies, without self-destructing my device? Expand for Answer A: If the battery dies and the host is not connected to power, some features will go out, such as Perimeter Detect and Real Time Clock. See the table below for more information.\nWith Zymkey and HSM4, if tamper detect is enabled and the battery dies or is removed, the device will self-destruct. This is an intentional security feature. If tamper detect is NOT enabled, you should connect the host device to power to change the battery.\nHSM6 has a battery monitoring feature to help the user prevent the battery from dying. If the battery dies, HSM6 users have the ability to choose whether the device should self-destruct or hold in reset mode until the battery is changed.\nKernel \u0026 Kernel Boot Questions Q: Can you tell the kernel not to run a shell? Expand for Answer A: Someone could easily replace the kernel and, while it is possible to configure initramfs to not permit the busybox shell to, that can be sidestepped as well. Even if you hack your own changes to the kernel to ignore the init option, someone could replace your kernel. Also, kernel updates would have to be done manually and the updates from the apt repo would have to be blacklisted.\nQ: Can you tell the kernel to ignore cmdline.txt? Expand for Answer A: There are many reasons why this is infeasible, but the main one is that, since the GPU initially functions as a bootloader processor during boot and since Broadcom has not made the GPU compiler publicly available as well as the source code for the bootloader, one cannot simply compile their own code that would ignore cmdline.txt.\nQ: Is it possible to encrypt the boot partition? Expand for Answer A: No because the GPU bootloader does not have encryption features implemented and, even in lieu of that, it does not know how to communicate with HSM6. The best solution, then, would be to implement an independent secure boot procedure. As mentioned above, we are currently working on adding this feature in a future product.\nProduction (“self-destruct”) Mode Questions Q: When using the perimeter-detect feature, does the “self-destruct” mode work (destroy all of its key material) even when the Lock Tab hasn’t been cut? Expand for Answer A: Self-destruct mode works only after the Lock Tab has been cut.\nQ: Is there a way to turn off “self-destruct” mode? Expand for Answer A: No, once turned on, “self-destruct” mode is permanent.\nQ: If my HSM6 does “self-destruct,” can I create new keys and reuse the hardware? Expand for Answer The SBC and SD card hardware will be reusable. Because the SD card contents are encrypted and the decryption key was destroyed, the data is lost. The HSM6 will not be reusable because the key slots will be destroyed. Q: If I cut the Lock-Tab on a HSM6, can I move that HSM6 to another Pi or change the SD card? Expand for Answer A: No. Cutting the Lock-Tab permanently binds that instance of HSM6 to the specific instances of host computer and SD card. This is a security feature to prevent credentials being moved from one host to another. DO NOT cut the Lock-Tab if you are still in development and expect to change the host or SD cards.\nQ: Will HSM6 still self-destruct, even when my SBC is powered off? Expand for Answer A: Yes, because HSM6 is battery powered. As long as the battery is sufficiently charged, it will still self-destruct.\nOther Q: Where can I learn about and/or pre-order future products? Expand for Answer A: Sign up for our new product email updates at the bottom of Zymbit’s homepage.\nQ: Which SBCs are compatible with HSM6? Expand for Answer Electrically, the Zymkey-I2C will interface to any single board computer using I2C. Check compatibility with your particular Linux distribution. Raspberry Pi 3, 3B+, 4, Zero RPi Compute Module 3, 4 Q: Does HSM6 work with Arduino? Expand for Answer A: We have no plans to release an Arduino shield version. While we love Arduinos and use them all the time, they generally don’t have enough resources to handle cryptographic operations at this level.\nQ: Does HSM6 work with BeagleBone? Expand for Answer A: Zymbit does not officially support the BeagleBoard platform at this time.\nQ: Which operating systems does HSM6 support? Expand for Answer Q: How much power does HSM6 consume? Expand for Answer HSM6-RPi (3.3V): idle approx. 1mA; max active \u003c 25mA with LED off, \u003c 35mA with LED on. HSM6-USB (5V): idle approx. 1.5mA; max active \u003c 40mA with LEDs off, \u003c 60mA with LEDs on. See Power Quality for more information.\n","categories":"","description":"","excerpt":" Troubleshooting Troubleshooting Checklist Before contacting Zymbit …","ref":"/troubleshooting/hsm6/","tags":"","title":"HSM6 FAQ \u0026 Troubleshooting"},{"body":"","categories":"","description":"","excerpt":"","ref":"/reference/product-briefs/mfg-app/","tags":"","title":"Manufacturing Appliance"},{"body":"Applicable Products The information included in this post applies to all Zymbit security modules.\nPower \u0026 Security Poor power quality can result in unstable and potentially insecure operation of your single board computer (SBC), depending upon it’s design, operating conditions and related system and power components. In this post we will outline the important factors of power quality management and explain how Zymkey manages the security of your device when power quality is poor.\nPower Quality Management Unlike software which is digital, deterministic and repeatable, power is analog and subject to the laws of physics and electrical engineering. Fortunately, with good design and a basic understanding, power quality can also be deterministic and repeatable. We’ll use the Raspberry Pi 3 to explain the basic concepts.\nSafe operating zone The Raspberry Pi 3 is designed to operate of a 5V (nominal) power supply, delivering 2A or more. (more on current rating later). This voltage is widely used in USB and mobile devices, making it easy to buy a power supply (and more on that later). In reality, power supplies have a tolerance on the output voltage, typically ±5%, which means the output voltage can range from a low of 4.75V to a high of 5.25V. The Raspberry Pi is designed to operate reliably in this Safe Operating Zone.\nBrown out zone - symptoms If the supply voltage dips below the safe operating zone then this can put the SBC into a less determinstic state - commonly known as “brown out” zone. Symptoms of brown outs range from irritating to catostrophic, depending upon where in the brown zone your SBC is operating:\nApparently Benign BUT Significant\nRED PWR LED on RPI 3 is off or flickering Power Warning - thunderbolt on console GUI IMPORTANT: The low voltage warning system is designed to protect your application. Use it ! It will save you time and money in debugging erratic system behavior and potentially expensive field failures and recalls.\nErratic Behavior\nGPIO digital and serial bus signals behave inconsistently USB peripherals behave inconsistently Catostrophic Failures\nIrregular cycling through reset and reboot, at which time vulnerabilites in the boot sequence or memory write cycles might be exposed (more in a later post).\nRegular cycling through reset and reboot - this can happen when your application program calls up more resources that consume more power at regular times. For example turning on additional cores for intense image processing, or turning on a USB peripheral or LCD display.\nSD card failures, corrupted SD card contents\nWhy Good Power Design Matters A well designed SBC will include elements of power management that monitor what is happening to the input power supply using a layer of hardware protection and supervision. In the case of the Raspberry Pi 3, there is a voltage monitor circuit that triggers a ‘Low Voltage Warning’ event when the supply voltage dips below 4.63V ±0.07V. This Low Voltage event is used to warn your software application of a potential loss of power and perhaps initiate an orderly shutdown sequence before a hard reset of the CPU occurs. If a hard reset does occur it will literally force the hardware to reset giving no time to store data or program cached in memory. In the case of the Pi, a hardware reset occurs at ~3.2V.\nSecure Power Zone - Zymkey Power Quality Monitor Zymkey includes a similar power monitoring system although it’s purpose is slightly different: it’s purpose is to prevent access to cryptographic keys during unstable power conditions (resulting from an intentional power vector attack, or unintentional system failure).\nIn the event of poor power quality the Zymkey instantaneosly shuts down access to the security API and communication channels and retreats into sleep mode (no sleep mode on Zymkey 4i lite). In sleep mode the Zymkey continues to monitor the quality of the 5V power rail and when conditions have stabilized it reactivates the security API and communicaiton channels.\nOther Considerations Static \u0026 Dynamic Power Loads Most power supplies are simply specified in terms of Voltage and Current Ratings. Better ones will specify the output voltage at different current outputs. The ratings are helpful, but not enough to determine if you have a suitable power supply that will operate reliably over the long term under different system load conditions.\nReal systems include devices that turn on and off, sometimes quickly (eg LCD switched from black to white, or multiple I/O’s turning on simultaneously, or USB powered HDD spining up). In these situations, a device switching on will create a dynamic (quickly changing) load on the power supply which can cause a momentary dip in the voltage as it trys to deliver the required surge current.\nAverage power supplies often don’t have good dynamic load response and can dip momentarilly or intermittently below a recommended operating voltage (4.63V in the case of the RPi). Good quality power supplies have a better dynamic performance and can respond very quickly to changes in loads.\nQUESTIONS? Is my power supply good enough ? Don’t be in denial. Developers unfamiliar with embedded hardware may not have the necessary test equipment or experience to determine the quality of their power supply. But denying there might be a problem does not make it go away! So here are a few tips when checking power quality:\nA standard multimeter will NOT give you a good indication of power quality: most take average readings that filter out (not see) any potentially harmful transients or AC components.\nMonitor the power rail with an oscilloscope, during static and dynamic loads that you would expect to see when your product is deployed.\nThankfully the designers of Raspberry Pi have provided two very helpful diagnostic tools: A Red Power LED and a Low_Pwr warning symbol (thunderbolt icon) on the user display.\nIf the Red Power LED is not illuminated this means the supply voltage is inadequate, falling below 4.63V. (The newer Pi(s) have a well engineered power circuit, and may continue to function even if the input voltage is below spec; the same may not be true of peripherals). The GUI had an rainbow indicator (replaced by a lightning bolt) which comes up in the top right if the voltage is inadequate. This has a 3 second timer, and may display even if the LED appears to be lit. Check out the Raspberry Pi Stack Exchange for a more complete description of the Pi power system.\nCan I disable Zymkey power quality monitor? No, not for standard products. This is an intentional design feature that protects the security of your critical keys and intraboard communications. If your system requires a different behaviour then please Contact Zymbit engineering services.\nUseful References Raspberry Pi 3 schematic with power supply details ","categories":"","description":"","excerpt":"Applicable Products The information included in this post applies to …","ref":"/reference/power-quality/","tags":"","title":"Power Quality Considerations"},{"body":"Good security begins with assigning each device a unique and unalterable identity (Device ID), that is used to authenticate subsequent interactions with the device.\nZYMKEY generates a unique Device ID by measuring certain attributes of the specific host (Measurement), and then combining that Measurement with the unique ID of that specific ZYMKEY. The process of combing these identifiers uses a cryptographic function, and this process is generally termed binding.\nOn completion of the binding process, the ZYMKEY is said to be bound to the Pi.\nZYMKEY supports two operating modes: Developer Mode : Binding is temporary and the ZYMKEY can be used with a different host SBC and SD card in the future.\nProduction Mode : Binding in production mode is permanent! The ZYMKEY can NOT be moved to different host SBC or used with a different SD card.\nThe tables below summarize the actions in Development Mode vs Production Mode with an encrypted root filesystem.\nDeveloper vs Production Mode SD Card A′ - image copy of original, encrypted SD Card A\nDeveloper Mode\nSD Card ZYMKEY PI4 Locks/Unlocks A A A Unlocks A′ A A Unlocks A B A Locked A′ B A Locked A A B Unlocks A′ A B Unlocks A B B Locked A′ B B Locked Summary: Developer Mode is lenient and will accommodate an SD card change, or a PI4 change (or both). You cannot use a different ZYMKEY.\nYou also can always start over and re-use the ZYMKEY in a new setup\nProduction Mode\nSD Card ZYMKEY PI4 Locks/Unlocks A A A Unlocks A′ A A Locked A B A Locked A′ B A Locked A A B Locked A′ A B Locked A B B Locked A′ B B Locked Summary: Production Mode is strict and will not unlock an encrypted rootfs without the original SD card, original ZYMKEY and original PI. You cannot re-use that ZYMKEY in a different setup.\n","categories":"","description":"","excerpt":"Good security begins with assigning each device a unique and …","ref":"/reference/binding/","tags":"","title":"Binding, Device ID, and Authentication"},{"body":"","categories":"","description":"","excerpt":"","ref":"/reference/","tags":"","title":"Reference"},{"body":"The following is a list of reserved pins \u0026 services that cannot be used or are not available to the user (they are reserved for Zymbit SCM operation).\nPins that can be used but SCM has control USB2_N USB2_P Pins that can be used but SCM can monitor nEXTRST GPIO17 GPIO22 GPIO27 Pins that currently cannot be used, SCM has control (possible future use with firmware changes) RUN_PG nRPIBOOT USB_OTG_ID Not connected GPIO_VREF ","categories":"","description":"","excerpt":"The following is a list of reserved pins \u0026 services that cannot be …","ref":"/reference/reserved-pins/","tags":"","title":"SCM Reserved Pins"},{"body":"Issue: Cpu Scaling Governor We have seen some issues with the scaling cpu governor on the Raspberry PI interfere with the i2c bus. This sometimes causes the ZYMKEY to be put into a odd state or return failures from operations that get optimized out by the governor.\nWorkaround Solution We Recommend: The PI sets the scaling governor to be ondemand by default. We recommend switching this mode to performance to get the best out of the ZYMKEY.\nNote: Switching to performance will use more battery power.\nSet to performance for current boot; not persistent on reboot: Run as root:\nsudo su\necho performance \u003e /sys/devices/system/cpu/cpufreq/policy0/scaling_governor Set performance to be persistent on reboot with a systemd service: Create a .service file in /etc/systemd/system/. You can name it whatever you wish. We will use cpu-governor.service. Write this code to /etc/systemd/system/cpu-governor.service file: [Unit] Description=Set scaling governor to performance After=multi-user.target Before=zkbootrtc.service [Service] Type=oneshot ExecStart=/bin/sh -c \"echo performance \u003e /sys/devices/system/cpu/cpufreq/policy0/scaling_governor\" [Install] WantedBy=multi-user.target Enable the service: sudo systemctl enable cpu-governor Start the service: sudo systemctl start cpu-governor Verifying the setting You can use cat to verify the current setting. It should return performance.\nsudo cat /sys/devices/system/cpu/cpufreq/policy0/scaling_governor\n","categories":"","description":"","excerpt":"Issue: Cpu Scaling Governor We have seen some issues with the scaling …","ref":"/reference/cpu-scaling/","tags":"","title":"CPU Scaling Governor"},{"body":"Updated: 2022-02-14\nWhat is SLIP39 and Shamir’s Backup? An algorithm created by Adi Shamir coined Shamir’s Secret Sharing, provides a new way of backing up and recovering our private keys. This algorithm was proposed by SatoshiLabs to be accepted as new backup method for wallet keys and thus named SLIP39.\nWhy use SLIP39 recovery? If you are familiar with current wallets like MetaMask and Ledger, then you will notice that most of these wallets implement a backup strategy using BIP39. BIP39 is a 12 or 24 word unique sentence that can recreate private keys backed by this strategy . But this is only one shard, and puts responsibility on the owner to keep this one shard from falling into the wrong hands.\nSLIP39 allows the owner to backup their wallets with multiple shards using a committee-like approach. For example, we can generate 10 shards and require that 6 of these shards need to be present to recover a wallet. If the owner loses one shard to a thief then it becomes less of a concern as the thief would still need 5 other shards to get into the wallet. Furthermore the owner can store these 10 shards however he wants: give a shard to a friend, store a shard in safe, bury a shard in the backyard, etc.\nMaximum number of shards? SLIP39 generates groups and each of these groups can contain its own system of member shards.\nHSM6 supports up to 14 groups * 14 members per group = 196 shards total SCM supports up to 16 groups * 16 members per group = 256 shards total Useful Resources: SLIP39 Prerequisites Zymbit Modules that support this feature:\nHSM6 SCM Follow the Getting Started guide first, installing all baseline software.\nAll code snippets written in this article are written using python3. For more Zymbit API documentation (Python/C/C++) visit: API Documentation\nGenerating a master seed with SLIP39 recovery The next steps cover how to create a master seed and setup for recovery of the seed with SLIP39. The example python code is provided in its entirety at the end of the explaination of each portion of the code.\nOpening a master seed SLIP39 generating session Create the recovery strategy. The recovery strategy will detail the number of groups to track (group_count) and number of groups needed to recover the master seed (group_threshold).\niteration_exponent dictates how many hashes are done at cryptographic layer (takes integer 0-5). The higher this number is, the longer (exponentially) the module will take to churn out a shard.\nvariant is only for curve “ed25519”, we support the “cardano” variant for ed25519. Otherwise is empty string.\nSupported Curves Other supported variants Nistp256/Secp256r1 None Secp256k1 None Ed25519 Cardano passphrase is the password for generating/recovering the master generator key.\nuse_SLIP39_recovery = zymkey.RecoveryStrategySLIP39(group_count = 3, group_threshold = 2, iteration_exponent = 0, variant = \"\", passphrase = \"\") Next, start the shard generating SLIP39 session.\n# The master seed will not be generated until all groups are created. So the slot will not be returned until all shards are generated. # Opens a SLIP39 session successfully on return code 0 print(\"Starting SLIP39 shard generating session...\") return_code = zymkey.client.gen_wallet_master_seed(\"secp256k1\", \"\", \"MyExampleWallet\", use_SLIP39_recovery) print(\"Done! Return Code:%i\" % (return_code)) A return code of 0 means we successfully started an active SLIP39 session.\nWarning While a SLIP39 session is active for both generation or recovery, other wallet generation functions are locked up. This means we can’t generate other keys while a SLIP39 session. If anything ever goes wrong in the SLIP39 process, we can cancel an active SLIP39 session at any time.\n# cancel an active SLIP39 session (Generation/Recovery) zymkey.client.cancel_SLIP39_session() Setting up our Groups and their member shards Groups can also contain their own member shard system. We will need to set this configuration for each group we work on with set_gen_SLIP39_group_info. The group_index is the group id we will be working on. So if we asked for 3 groups in our recovery strategy, then the group indexes for these 3 groups are [0,1,2].\nThe member_count is the number of shards in the group.\nThe member_threshold is the number of member shards we required to reconstruct the group.\nadd_gen_SLIP39_member_pwd(string passphrase) will return a -1 and 33 word mnemonic sentence (shard). If we specified a member_count of three, then we will need to call this function 3 times to generate our 3 member shards. By default the function doesn’t attach a password to any of these shards. This function will return a -1 until all groups/members are generated.\nFor now, the first group will have 3 shards with a threshold of 2 shards required for reconstruction. These shards will also not have passwords attached to them.\n# First Group has been divided into three members. Will require two of these three members to reconstruct this group. # This group will have no passwords attached to the members # add_gen_SLIP39_member_pwd() will return a [-1, mnemonic_sentence]. -1 symbolizing that all shards haven't been generated yet. print(\"\\nSet our first example group configuration..\") zymkey.client.set_gen_SLIP39_group_info(group_index = 0, member_count = 3, member_threshold = 2) print(\"Generating 3 Shards for Group 0 (Shards required for recovering the group: 2)...\") group_0_shard_list = [] for i in range(3): ret, mnemonic_shard = zymkey.client.add_gen_SLIP39_member_pwd() group_0_shard_list.append(mnemonic_shard) print(\"Shard #%i , Mnemonic sentence:\\n%s\" % (i+1, group_0_shard_list[i])) For the second group, generate three total shards again, but this time with a threshold of 3 shards (all are required for reconstruction). These shards will have passwords attached to them this time.\n# Second Group has been divided into three members. Will require all three members to reconstruct this group. # This group will have passwords attached to the members print(\"\\nSet our second example group configuration..\") zymkey.client.set_gen_SLIP39_group_info(group_index = 1, member_count = 3, member_threshold = 3) print(\"Done!\") print(\"Generating 3 Shards for Group 1 (Shards required for recovering the group: 3)...\") group_1_shard_dict = {} group_1_pwd_list = [\"p@ssw0rd\", \"T3st\", \"h3LlO\"] for i in range(3): ret, mnemonic_shard = zymkey.client.add_gen_SLIP39_member_pwd(group_1_pwd_list[i]) group_1_shard_dict[group_1_pwd_list[i]] = mnemonic_shard print(\"Shard #%i , Mnemonic sentence(Password: %s):\\n%s\" % (i+1, group_1_pwd_list[i], group_1_shard_dict[group_1_pwd_list[i]])) For the third group we will have only one shard. To show that we do not have to always shard up our groups into multiple shards. Since this is the last group in the SLIP39 session, the master seed key’s slot number will be returned on the last shard generated by add_gen_SLIP39_member_pwd() instead of -1.\nWarning Although this shard may look like a BIP39 mnemonic sentence. They are NOT interchangeable. # Third Group has been divided into just one member (THIS IS NOT RECOMMENDED LEAST SECURE). Will require the only member to reconstruct this group. # This group will have no passwords attached to the members # This shard is not the same as a BIP39 shard! # Since this is the last group, on the very last shard the add_gen_SLIP39_member_pwd() will return the master seed slot it was generated in, instead of -1. print(\"\\nSet our third example group configuration..\") zymkey.client.set_gen_SLIP39_group_info(group_index = 2, member_count = 1, member_threshold = 1) print(\"Done!\") print(\"Generating 1 Shards for Group 2 (Shards required for recovering the group: 1)...\") master_seed_slot, last_shard = zymkey.client.add_gen_SLIP39_member_pwd() print(\"Shard #%i , Mnemonic sentence:\\n%s\" % (1, last_shard)) A master seed key pair has been generated with a SLIP39 backup strategy. For security, the master seed public key cannot be exported, but a child key can be generated and its public key can be exported.\nprint(\"\\nMaster Seed Slot: %i\" % (master_seed_slot)) child_slot = zymkey.client.gen_wallet_child_key(master_seed_slot, 0 , False) child_pub_key = zymkey.client.get_public_key(child_slot) print(\"Child Public Key: %s\" % (child_pub_key)) Next, recover this key pair with the SLIP39 shards just generated. Compare the children public keys to see if the correct master key pair was recovered.\nRecovering our master key with SLIP39 shards Delete the original master seed key pair. This will also delete any children keys generated from the master seed key pair.\n# Lets Remove that key we just generated and recover it. # Note! removing the master key will remove its children keys as well. print(\"\\nRemoving Master Key....\") zymkey.client.remove_key(master_seed_slot) print(\"Done!\") Opening a recovery SLIP39 session Start the SLIP39 recovery session. This must take in the same curve type, master key passphrase, wallet name, and recovery strategy. This session will return a -1, but this is not an error. A -1 is returned throughout the session to be ambiguous on how far along the recovery process we are. If there truly was an error, restore_wallet_master_seed() will return an exception instead.\n# Per Above example we need to restore two of the three groups in order to get our master seed back # Let's restore with group 0 and group 1 # Open a restore SLIP39 session, recovery_strategy will be the same as above # Return code will be -1, but this is due to security reasons. To not let users know how far along the recovery process is. # It will instead throw an exception if it fails. print(\"\\nStarting SLIP39 shard restoring session...\") return_code = zymkey.client.restore_wallet_master_seed(\"secp256k1\", \"\", \"MyExampleWallet\", use_SLIP39_recovery) print(\"Done! Return Code:%i\" % (return_code)) Remember from the earlier example we created three groups and require only two of these groups to be reconstructed to recover our key.\nGroup0 no passwords (3 members, threshold: 2) Group1 has passwords(3 members, threshold: 3) Group2 no password (1 member, threshold: 1) Since we only require two groups to recover our master key, the total number shards needed can differ.\nThese three ways will all recover the master key.\nGroup combination member thresholds Total shards needed Group0 + Group1 2 + 3 5 Group1 + Group2 3 + 1 4 Group2 + Group0 1 + 2 3 Now recover the master key using the group combination of Group0 + Group1. Shards are fed in one at a time and can be fed out of order as well. The module will auto reconstruct any groups as it gets more shards fed in. The module will return -1 until it successfully recreates all groups needed to generate the master key. If an incorrect shard is fed in, then it will still return -1. Remember we can always call cancel_SLIP39_session to stop our active SLIP39 session, if an incorrect shard is fed in.\n# Feed in the shards. The shards will be fed in one at a time, and can be fed in any order. # This function will keep returning -1, for security. To not let users know how far along the recovery process is. # The function will return the real slot number once all groups are reconstructed. # For this example we need to feed in a total of: group_0_threshold (2) + group_1_threshold (3) = 5 shards. # Feed group 0 shards, and for fun out of order. print(\"\\nFeeding Group 0 Shard#3 and Shard#1...\") zymkey.client.add_restore_SLIP39_mnemonic(mnemonic_sentence = group_0_shard_list[2]) zymkey.client.add_restore_SLIP39_mnemonic(mnemonic_sentence = group_0_shard_list[0]) print(\"Done!\") # group1 shards have passwords attached to them. So we need to feed in the correct passwords for these shards. print(\"\\nFeeding Group 1 Shards with their passwords...\") zymkey.client.add_restore_SLIP39_mnemonic(mnemonic_sentence = group_1_shard_dict.get(group_1_pwd_list[0]), passphrase = group_1_pwd_list[0]) zymkey.client.add_restore_SLIP39_mnemonic(mnemonic_sentence = group_1_shard_dict.get(group_1_pwd_list[2]), passphrase = group_1_pwd_list[2]) # Notice the last shard required for full master seed reconstruction will return the slot number instead of -1 master_seed_slot = zymkey.client.add_restore_SLIP39_mnemonic(mnemonic_sentence = group_1_shard_dict.get(group_1_pwd_list[1]), passphrase = group_1_pwd_list[1]) print(\"Done!\") The master key should now be sucessfully recovered. Verify that the master key is correctly recovered.\n# Check the public key and make sure its the same. # Checking if master_seed_pub_key = zymkey.client.get_public_key(master_seed_slot) print(\"\\nMaster Seed Slot: %i\" % (master_seed_slot)) child_slot = zymkey.client.gen_wallet_child_key(master_seed_slot, 0 , False) child_pub_key = zymkey.client.get_public_key(child_slot) print(\"Child Public Key: %s\" % (child_pub_key)) # Cleanup print(\"\\nRemoving Master Key....\") zymkey.client.remove_key(master_seed_slot) print(\"Done!\") The public key from the children key should match the public key we got before, proving the master key recovered matched the original master key.\nFull Code Example #!/usr/bin/python3 import zymkey wallet_name = \"MyExampleWallet\" # --------------------------------------Create a master seed using shamir's backup----------------------------------------------------------------------- # Use the SLIP39 recovery strategy to tell zymkey to open a SLIP39 shard generating session. # The recovery strategy will detail the number of Groups to track (group_count) and number of groups needed to recover the master seed (group_threshold) # iteration_exponent dictates how many hashes are done at cryptographic layer. # The master seed will not be generated until all groups are created. So the slot will not be returned until all shards are generated. # Opens a SLIP39 session successfully on return code 0 use_SLIP39_recovery = zymkey.RecoveryStrategySLIP39(group_count = 3, group_threshold = 2, iteration_exponent = 0, variant = \"\", passphrase = \"\") print(\"Starting SLIP39 shard generating session...\") return_code = zymkey.client.gen_wallet_master_seed(\"secp256k1\", \"\", wallet_name, use_SLIP39_recovery) print(\"Done! Return Code:%i\" % (return_code)) # First Group has been divided into three members. Will require two of these three members to reconstruct this group. # This group will have no passwords attached to the members # add_gen_SLIP39_member_pwd() will return a [-1, mnemonic_sentence]. -1 symbolizing that all shards haven't been generated yet. print(\"\\nSet our first example group configuration..\") zymkey.client.set_gen_SLIP39_group_info(group_index = 0, member_count = 3, member_threshold = 2) print(\"Generating 3 Shards for Group 0 (Shards required for recovering the group: 2)...\") group_0_shard_list = [] for i in range(3): ret, mnemonic_shard = zymkey.client.add_gen_SLIP39_member_pwd() group_0_shard_list.append(mnemonic_shard) print(\"Shard #%i , Mnemonic sentence:\\n%s\" % (i+1, group_0_shard_list[i])) # Second Group has been divided into three members. Will require all three members to reconstruct this group. # This group will have passwords attached to the members print(\"\\nSet our second example group configuration..\") zymkey.client.set_gen_SLIP39_group_info(group_index = 1, member_count = 3, member_threshold = 3) print(\"Done!\") print(\"Generating 3 Shards for Group 1 (Shards required for recovering the group: 3)...\") group_1_shard_dict = {} group_1_pwd_list = [\"p@ssw0rd\", \"T3st\", \"h3LlO\"] for i in range(3): ret, mnemonic_shard = zymkey.client.add_gen_SLIP39_member_pwd(group_1_pwd_list[i]) group_1_shard_dict[group_1_pwd_list[i]] = mnemonic_shard print(\"Shard #%i , Mnemonic sentence(Password: %s):\\n%s\" % (i+1, group_1_pwd_list[i], group_1_shard_dict[group_1_pwd_list[i]])) # Third Group has been divided into just one member (THIS IS NOT RECOMMENDED LEAST SECURE). Will require the only member to reconstruct this group. # This group will have no passwords attached to the members # This shard is not the same as a BIP39 shard! # Since this is the last group, on the very last shard the add_gen_SLIP39_member_pwd() will return the master seed slot it was generated in, instead of -1. print(\"\\nSet our third example group configuration..\") zymkey.client.set_gen_SLIP39_group_info(group_index = 2, member_count = 1, member_threshold = 1) print(\"Done!\") print(\"Generating 1 Shards for Group 2 (Shards required for recovering the group: 1)...\") master_seed_slot, last_shard = zymkey.client.add_gen_SLIP39_member_pwd() print(\"Shard #%i , Mnemonic sentence:\\n%s\" % (i+1, last_shard)) # master_seed_pub_key = zymkey.client.get_public_key(master_seed_slot) print(\"\\nMaster Seed Slot: %i\" % (master_seed_slot)) child_slot = zymkey.client.gen_wallet_child_key(master_seed_slot, 0 , False) child_pub_key = zymkey.client.get_public_key(child_slot) print(\"Child Public Key: %s\" % (child_pub_key)) # -------------------------------------------------------------------------------------------------------------------------------------------------------- # --------------------------------------Recover a master seed using shamir's backup----------------------------------------------------------------------- # Let's Remove that key we just generated and recover it. # Note! removing the master key will remove its children keys as well. print(\"\\nRemoving Master Key....\") zymkey.client.remove_key(master_seed_slot) print(\"Done!\") # Per Above example we need to restore two of the three groups in order to get our master seed back # Let's restore with group 0 and group 1 # Open a restore SLIP39 session, recovery_strategy will be the same as above # Return code will be -1, but this is due to security reasons. To not let users know how far along the recovery process is. # It will instead throw an exception if it fails. print(\"\\nStarting SLIP39 shard restoring session...\") return_code = zymkey.client.restore_wallet_master_seed(\"secp256k1\", \"\", wallet_name, use_SLIP39_recovery) print(\"Done! Return Code:%i\" % (return_code)) # Now we will feed in our shards. These will be fed in one at a time, and can be fed in any order. # This function will keep returning -1, for security. To not let users know how far along the recovery process is. # Will return the real slot number once all groups are reconstructed. # For this example we need to feed in a total of: group_0_threshold (2) + group_1_threshold (3) = 5 shards. #Feed group 0 shards, and for fun out of order. print(\"\\nFeeding Group 0 Shard#3 and Shard#1...\") zymkey.client.add_restore_SLIP39_mnemonic(mnemonic_sentence = group_0_shard_list[2]) zymkey.client.add_restore_SLIP39_mnemonic(mnemonic_sentence = group_0_shard_list[0]) print(\"Done!\") # group1 shards have passwords attached to them. So we need to feed in the correct passwords for these shards. print(\"\\nFeeding Group 1 Shards with their passwords...\") zymkey.client.add_restore_SLIP39_mnemonic(mnemonic_sentence = group_1_shard_dict.get(group_1_pwd_list[0]), passphrase = group_1_pwd_list[0]) zymkey.client.add_restore_SLIP39_mnemonic(mnemonic_sentence = group_1_shard_dict.get(group_1_pwd_list[2]), passphrase = group_1_pwd_list[2]) # Notice the last shard required for full master seed reconstruction will return the slot number instead of -1 master_seed_slot = zymkey.client.add_restore_SLIP39_mnemonic(mnemonic_sentence = group_1_shard_dict.get(group_1_pwd_list[1]), passphrase = group_1_pwd_list[1]) print(\"Done!\") # Let's Check the public key and make sure its the same. # master_seed_pub_key = zymkey.client.get_public_key(master_seed_slot) print(\"\\nMaster Seed Slot: %i\" % (master_seed_slot)) child_slot = zymkey.client.gen_wallet_child_key(master_seed_slot, 0 , False) child_pub_key = zymkey.client.get_public_key(child_slot) print(\"Child Public Key: %s\" % (child_pub_key)) print(\"\\nRemoving Master Key....\") zymkey.client.remove_key(master_seed_slot) print(\"Done!\") # ----------------------------------------------------------------------------------------------------------------------------------------------- ","categories":"","description":"","excerpt":"Updated: 2022-02-14\nWhat is SLIP39 and Shamir’s Backup? An algorithm …","ref":"/tutorials/digital-wallet/slip39-example/","tags":"","title":"SLIP39 and Shamir's Wallet Recovery Example"},{"body":"Applicable Products The information included in this post applies to ZYMKEY4, HSM4, and HSM6.\nStandard ZYMKEY4 and HSMs are supplied with a Real Time Clock (RTC). This capability can be useful for platforms which do not have a built-in RTC, such as Raspberry Pi, but rather depend on NTP for time-keeping.\nDependence on NTP may cause problems due to unscheduled power outages or unreliable WiFi connections. For example, if a deployed application that periodically collects sensor data experiences a power outage and is not able to restore a connection to any available networks upon boot up, the timestamps associated with any collected data would be incorrect. On Raspberry Pi, this will be approximate to the last valid timestamp when things were last running normally.\nWe can simulate this by disabling ntp.service comparing the system date to the time.nist.gov server. After only 12 hours, the system clock has drifted nearly 40 minutes!\nZymkey and HSM’s Real Time Clock is battery backed for reliable operation, which could be very valuable for significant power or network outages. Prior to starting NTP in the boot sequence, the Zymkey or HSM provides the current UTC timestamp to the host computer (e.g. Raspberry Pi). This means that, if access to a reliable network isn’t available, a reliable timestamp will be available for use by any running applications.\nWith a bound Zymbit Security Module installed and running zkbootrtc.service on the same system as above (ntp disabled), we can see the clock restored based on the Zymbit Security Module’s RTC. You will notice this message at boot:\nFeb 8 19:22:26 raspberrypi systemd[1]: Starting Restore System Clock from Zymkey… Feb 9 18:58:48 raspberrypi systemd[1]: Started Restore System Clock from Zymkey.\nAnd we can validate using the same test as above.\nThe time value is not settable directly by applications that are running on Pi. Instead RTC accuracy is monitored and maintained by the software suite.\nIn order for the RTC feature to be activated, the Zymkey/ HSM needs to have it’s clock checked and set occasionally, which is done by the HSM software, but this means that NTP must be running so that the Pi time is synchronized to an accurate clock source. To make sure that NTP is active, on later raspbian distributions, you’ll need to run sudo timedatectl set-ntp true and then reboot. In the case where a new coin cell has been installed, it may take a few minutes after the reboot for the HSM time to be synchronized.\nAccuracy of RTC ZYMKEY4 and HSMs with integrated RTC are supplied with Standard Accuracy calibration. This is generally suitable for commercial applications that are not exposed to extreme temperature ranges and not disconnected from NTP for months on end. (see specs below)\nAn optional High Accuracy RTC is available, providing additional stability over extended temperature ranges.\n","categories":"","description":"","excerpt":"Applicable Products The information included in this post applies to …","ref":"/reference/real-time-clock/","tags":"","title":"Real Time Clock Operation"},{"body":"Updated: 2022-02-22\nWhat is an oversight wallet? The zymbit oversight wallet is a read-only wallet. In the world of blockchain, accounts and the funds associated with them are public and able to be viewed. This is done by looking up the blockchain address associated with public keys. Read-only or receive-only wallets can’t send funds/assets out of the account. To send funds an account must be able to sign a fund transaction with a private key. So the oversight wallet is a wallet that doesn’t contain private keys, just the public key counterparts.\nWhy use oversight wallet? This can be useful for handing a copy of a wallet to a financial advisor or someone of a similar role. They would be able to track the history of that wallet, but wouldn’t have any power in changing the wallet in any kind of way.\nPrerequisites Zymbit Modules that support this feature:\nHSM6 SCM Follow the Getting Started guide first, installing all baseline software.\nAll code snippets written in this article are written using Python3. For more Zymbit API documentation (Python/C/C++) visit: API Documentation\nCreating an oversight wallet on the Zymbit module First create an example BIP32 master seed wallet as a reference for our oversight wallet.\n# Create our BIP32 master seed print(\"Create our normal wallet...\") master_seed_slot = zymkey.client.gen_wallet_master_seed(key_type = \"secp256k1\", master_gen_key = \"\", wallet_name = MyExampleWallet) print(\"Done! Master seed slot:%i\" % (master_seed_slot)) Next for this example, we create children keys and derive a wallet address “m/44/60/0/0’”. An oversight wallet is created by referencing the public key and chain code of the last hardened node of a wallet address. So in this example, grab the public key and chain code from the slot of the \" 0’ \" index.\n# Oversight wallet requires the public key and chain code of the last hardened node in a wallet address. # So for this example will use m/44/60/0/0' where the 0' is the last hardened node for our oversight wallet to start from. print(\"\\nCreate a wallet derivation path m/44/60/0/0' ..\") child_slot = zymkey.client.gen_wallet_child_key(parent_key_slot = master_seed_slot, index = 44, hardened = False) child_slot = zymkey.client.gen_wallet_child_key(parent_key_slot = child_slot, index = 60, hardened = False) child_slot = zymkey.client.gen_wallet_child_key(parent_key_slot = child_slot, index = 0, hardened = False) # Let's return the chain code of this hardened node to generate our oversight wallet later child_slot, chain_code = zymkey.client.gen_wallet_child_key(parent_key_slot = child_slot, index = 0, hardened = True, return_chain_code = True) hardened_node_pub_key = zymkey.client.get_public_key(child_slot) print(\"Done! m/44/60/0/0' slot:%i\" % (child_slot)) Now generate an oversight wallet from the public key and chain code:\n# Using the public key and chain code, create the oversight wallet. # Note that the oversight wallet can exist at the same time as our BIP32 wallet, but needs a different wallet name, as wallet names are unique. print(\"Create our oversight wallet...\") oversight_slot = zymkey.client.gen_oversight_wallet(key_type = \"secp256k1\", pub_key = hardened_node_pub_key, chain_code = chain_code, node_addr = \"m/44/60/0/0'\", wallet_name = \"Oversight_wallet\") print(\"Done! oversight_slot slot:%i\" % (oversight_slot)) The oversight wallet can generate child keys the same way as a normal BIP32 wallet. However this wallet contains no private keys, so no transaction will be able to be signed properly.\nAlso note that this oversight wallet starts from the \" 0’ \" index of the previous wallet. It has no insight about the “m/44/60/0” key pairs that came before it.\nFull Code Example #!/usr/bin/python3 import zymkey # -----------------------------Create a oversight wallet example------------------------------------------------------------- wallet_name = \"MyExampleWallet\" # Create our BIP32 master seed print(\"Create our normal wallet...\") master_seed_slot = zymkey.client.gen_wallet_master_seed(key_type = \"secp256k1\", master_gen_key = \"\", wallet_name=wallet_name) print(\"Done! Master seed slot:%i\" % (master_seed_slot)) # Oversight wallet requires the public key and chain code of the last hardened node in a wallet address. # So for this example will use m/44/60/0/0' where the 0' is the last hardened node for our oversight wallet to start from. print(\"\\nCreate a wallet derivation path m/44/60/0/0' ..\") child_slot = zymkey.client.gen_wallet_child_key(parent_key_slot = master_seed_slot, index = 44, hardened = False) child_slot = zymkey.client.gen_wallet_child_key(parent_key_slot = child_slot, index = 60, hardened = False) child_slot = zymkey.client.gen_wallet_child_key(parent_key_slot = child_slot, index = 0, hardened = False) # Let's return the chain code of this hardened node to generate our oversight wallet later child_slot, chain_code = zymkey.client.gen_wallet_child_key(parent_key_slot = child_slot, index = 0, hardened = True, return_chain_code = True) hardened_node_pub_key = zymkey.client.get_public_key(child_slot) print(\"Done! m/44/60/0/0' slot:%i\" % (child_slot)) # Now that we have the public key and chain code, can create the oversight wallet. # Note that the oversight wallet can exist at the same time as our BIP32 wallet. But needs a different wallet name, as wallet names are unique. print(\"Create our oversight wallet...\") oversight_slot = zymkey.client.gen_oversight_wallet(key_type = \"secp256k1\", pub_key = hardened_node_pub_key, chain_code = chain_code, node_addr = \"m/44/60/0/0'\", wallet_name = \"Oversight_wallet\") print(\"Done! oversight_slot slot:%i\" % (oversight_slot)) # ----------------------------------------------------------------------------------------------------------------------------- ","categories":"","description":"","excerpt":"Updated: 2022-02-22\nWhat is an oversight wallet? The zymbit oversight …","ref":"/tutorials/digital-wallet/oversight-example/","tags":"","title":"Creating an Oversight (Read Only) Wallet"},{"body":"","categories":"","description":"","excerpt":"","ref":"/reference/product-briefs/scm/","tags":"","title":"Secure Compute Modules"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tutorials/","tags":"","title":"Tutorials"},{"body":"If left in Development Mode, self-destruct events are simulated with LED flash sequences and recovery rather than destruction to allow for experimentation with the security functions. The LED sequence will repeat three times and then the system will recover.\nDESTRUCTIVE ACTION THE BINDING PROCESS IS PERMANENT AND CANNOT BE REVERSED. PAY ATTENTION TO THE FOLLOWING:\nIf you are using the Perimeter Detect features, then the sequence in which you arm and disarm this feature is very important. Be sure to carefully follow the process steps below. If you decide that you are not ready for permanent binding, leave the SCM in developer mode.\nDESTRUCTIVE ACTION The table below summarizes the differences between Development Mode (no Bind Lock) and Production Mode (Bind Locked)\nEvent Development Mode Production Mode Triggers Tamper Event 6 flash + channel sub-flash Destroy all keys Immediately Low Temp Threshold 20 flash + 1 sub-flash Do Not Boot Immediately High Temp Threshold 20 flash + 2 sub-flash Do Not Boot Immediately Low Battery Voltage Threshold 6 flash Two Policies: Prevent Boot or Destroy all keys Power Off Supervised Boot Failure 4 flash + 2 sub-flash Two Policies: Prevent Boot or Destroy all keys On Boot Once locked, setting the Event Action modes are limited in the following way:\nEvent Setting Tamper One time after locked Low Temp Threshold Must be set prior to locking High Temp Threshold Must be set prior to locking Low Battery Voltage Threshold Must be set prior to locking Supervised Boot Failure No limit When you have completed your development work with the SCM and are ready to deploy your system into the field, we recommend that you permanently bind your SCM to a specific host device.\nSummary of Steps Develop your application\n[ ] Ensure your host has all the necessary prerequisites in place to interface with the SCM and that it will be able to run your software application.\nActivate Production Mode\n[ ] Permanently bind your SCM to the host device.\nDevelop your application The following steps should be complete:\n[ ] Install a battery on the Zymbit SCM I/O board.\n[ ] Install all necessary software for your application on the host and establish temporary binding in development mode.\nAfter these steps have been completed, you are ready to prepare your device for permanent binding.\nPrepare Perimeter Detect The Perimeter Event Actions for your SCM should be set to none or notify only. If your SCM’s action mode is set to self_destruct, you might render your unit /c/Users/bobgu/OneDrive/Desktop/Atom.lnkuseless while attempting to activate Production Mode.\nResources Perimeter Detect: SCM Understand how to use the SCM’s perimeter detect features. Read article To do this quickly, with the SCM client libraries installed, you can run the following shell command to use the Python API to communicate with the SCM and set the Perimeter Event Actions to only Notify when triggered:\npython3 -c \"import zymkey; for ch in (0, 1): zymkey.client.set_perimeter_event_actions(ch, action_notify=True, action_self_destruct=False) zymkey.client.clear_perimeter_detect_info()\" Prepare your application You should then install your application on your host SBC. The SCM root partition is pre-encrypted and is secured by the SCM itself.\nTest, debug, and test again Danger DO NOT skip this step. If you encounter a major issue with your application after your SCM has been permanently bound to your device and armed, you may not be able to fix it. Test the functionality of your application thoroughly to ensure it is free of major defects that will prevent it from functioning properly. In Production Mode when Perimeter Detect features are in use, it may be difficult to make significant changes to your configuration without locking youself out of the SCM, depending on the nature of your application and its configuration.\nActivate Production Mode To put the SCM into Production Mode only requires a function call followed by a power cycle.\nThe API function lock_binding puts the SCM into Production Mode. Below are three examples which check the current binding info, lock the SCM binding, then check the current binding info again. Remove the comments around the lock binding function to move to Production Mode.\nC - zkLockBinding // gcc example_binding.c -I /usr/include/zymkey -l zk_app_utils -o example_binding #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \"zk_app_utils.h\" #include \"zk_b64.h\" void check_code(int code, char* location){ if (code \u003c 0) { fprintf(stderr, \"FAILURE: %s - %s\\n\", location, strerror(code)); } else if (code \u003e= 0) { fprintf(stdout, \"SUCCESS: %s - %d\\n\", location, code); } } void HSM_soft_bind(zkCTX zk_ctx) { bool binding_is_locked = false; bool is_bound = false; int ret = zkGetCurrentBindingInfo(zk_ctx, \u0026binding_is_locked, \u0026is_bound); check_code(ret, \"zkGetCurrentBindingInfo\"); printf(\"Binding is locked: \"); printf(binding_is_locked ? \"true\" : \"false\"); printf(\"\\n\"); printf(\"SCM is bound: \"); printf(is_bound ? \"true\" : \"false\"); printf(\"\\n\\n\"); //ret = zkLockBinding(zk_ctx); //if(binding_is_locked \u0026\u0026 is_bound) //{ // check_code(ret, \"zkLockBinding - Already Bound\"); //} //else //{ // check_code(ret, \"zkLockBinding\"); //} //printf(\"\\n\"); ret = zkGetCurrentBindingInfo(zk_ctx, \u0026binding_is_locked, \u0026is_bound); check_code(ret, \"zkGetCurrentBindingInfo\"); printf(\"Binding is locked: \"); printf(binding_is_locked ? \"true\" : \"false\"); printf(\"\\n\"); printf(\"SCM is bound: \"); printf(is_bound ? \"true\" : \"false\"); printf(\"\\n\\n\"); } int main() { zkCTX zk_ctx; int status = zkOpen(\u0026zk_ctx); check_code(status, \"zkOpen\"); printf(\"\\n\\n\"); HSM_soft_bind(zk_ctx); status = zkClose(zk_ctx); check_code(status, \"zkClose\"); printf(\"\\n\"); return 0; } C++ - lockBinding #include \u003cstdio.h\u003e #include \u003czkAppUtilsClass.h\u003e using namespace std; using namespace zkAppUtils; void HSM_soft_bind(zkClass* zk_inst) { bool binding_is_locked = false; bool is_bound = false; zk_inst-\u003egetCurrentBindingInfo(binding_is_locked, is_bound); printf(\"Binding is locked: \"); printf(binding_is_locked ? \"true\" : \"false\"); printf(\"\\n\"); printf(\"SCM is bound: \"); printf(is_bound ? \"true\" : \"false\"); printf(\"\\n\"); //zk_inst-\u003elockBinding(); //printf(\"lockBinding successful\\n\"); zk_inst-\u003egetCurrentBindingInfo(binding_is_locked, is_bound); printf(\"Binding is locked: \"); printf(binding_is_locked ? \"true\" : \"false\"); printf(\"\\n\"); printf(\"SCM is bound: \"); printf(is_bound ? \"true\" : \"false\"); printf(\"\\n\"); } int main() { zkClass* zk_inst; zk_inst = new zkClass(); HSM_soft_bind(zk_inst); delete zk_inst; return 0; } Python - lock_binding import zymkey tup = zymkey.client.get_current_binding_info() print(\"SCM is bound: \" + str(tup[1])) print(\"Binding is locked: \" + str(tup[0])) #zymkey.client.lock_binding() tup = zymkey.client.get_current_binding_info() print(\"SCM is bound: \" + str(tup[1])) print(\"Binding is locked: \" + str(tup[0])) Warning Do not proceed without completing the steps outlined above, including setting the Perimeter Event Actions to none or notify. Prior to setting the Bind Lock. Finalize your device for deployment After using the APIs to lock binding, reboot. The blink pattern on the SCM will change to 3 rapid blinks once every 3 seconds to indicate that SCM has bound to the host in Production Mode.\nIf you are using the Perimeter Detect features, close your perimeter circuits (for example, by closing the enclosure’s lid), and then clear any Perimeter Detect Events using the API:\npython3 -c \"import zymkey; idx = 0; zymkey.client.clear_perimeter_detect_info() for p in zymkey.client.get_perimeter_detect_info(): if p: print(f'Channel {idx} has a detected breach event. Clear the Perimeter Detect Events again.') idx += 1 else: print('No perimeter breach detected.')\" If you get a message that a breach event was detected from the above command, run it again to ensure all events have been cleared.\nWarning You only get one chance to set Perimeter Event Actions once you are in Production Mode! When it confirms that no breach events have been detected, it is then safe to arm the system by setting the Perimeter Event Actions to notify or selfdestruct, if desired.\nYour system is now armed and ready to be used in the field!\n","categories":"","description":"","excerpt":"If left in Development Mode, self-destruct events are simulated with …","ref":"/getting-started/scm/production-mode/","tags":"","title":"Enabling Production Mode - SCM"},{"body":"If left in Development Mode, self-destruct events are simulated with LED flash sequences and recovery rather than destruction to allow for experimentation with the security functions. The LED sequence will repeat three times and then the system will recover.\nDESTRUCTIVE ACTION THE BINDING PROCESS IS PERMANENT AND CANNOT BE REVERSED. PAY ATTENTION TO THE FOLLOWING:\nIf you are using the Perimeter Detect features, then the sequence in which you arm and disarm this feature is very important. Be sure to carefully follow the process steps below. If you decide that you are not ready for permanent binding, leave the SEN in developer mode.\nDESTRUCTIVE ACTION The table below summarizes the differences between Development Mode (no Bind Lock) and Production Mode (Bind Locked)\nEvent Development Mode Production Mode Triggers Tamper Event 6 flash + channel sub-flash Destroy all keys Immediately Low Temp Threshold 20 flash + 1 sub-flash Do Not Boot Immediately High Temp Threshold 20 flash + 2 sub-flash Do Not Boot Immediately Low Battery Voltage Threshold 6 flash Two Policies: Prevent Boot or Destroy all keys Power Off Supervised Boot Failure 4 flash + 2 sub-flash Two Policies: Prevent Boot or Destroy all keys On Boot Once locked, setting the Event Action modes are limited in the following way:\nEvent Setting Tamper One time after locked Low Temp Threshold Must be set prior to locking High Temp Threshold Must be set prior to locking Low Battery Voltage Threshold Must be set prior to locking Supervised Boot Failure No limit When you have completed your development work with the SEN and are ready to deploy your system into the field, we recommend that you permanently bind your SEN to a specific host device.\nSummary of Steps Develop your application\n[ ] Ensure your host has all the necessary prerequisites in place to interface with the SEN and that it will be able to run your software application.\nActivate Production Mode\n[ ] Permanently bind your SEN.\nDevelop your application The following steps should be complete:\n[ ] Install a battery on the Zymbit SEN I/O board.\n[ ] Install all necessary software for your application on the host and establish temporary binding in development mode.\nAfter these steps have been completed, you are ready to prepare your device for permanent binding.\nPrepare Perimeter Detect The Perimeter Event Actions for your SEN should be set to none or notify only. If your SEN’s action mode is set to self_destruct, you might render your unit /c/Users/bobgu/OneDrive/Desktop/Atom.lnkuseless while attempting to activate Production Mode.\nResources Perimeter Detect: Secure Edge Node Understand how to use the SEN’s perimeter detect features. Read article To do this quickly, with the SEN client libraries installed, you can run the following shell command to use the Python API to communicate with the SEN and set the Perimeter Event Actions to only Notify when triggered:\npython3 -c \"import zymkey; for ch in (0, 1): zymkey.client.set_perimeter_event_actions(ch, action_notify=True, action_self_destruct=False) zymkey.client.clear_perimeter_detect_info()\" Prepare your application You should then install your application on your host SBC. The SEN root partition is pre-encrypted and is secured by the SEN itself.\nTest, debug, and test again Danger DO NOT skip this step. If you encounter a major issue with your application after your SEN has been permanently bound to your device and armed, you may not be able to fix it. Test the functionality of your application thoroughly to ensure it is free of major defects that will prevent it from functioning properly. In Production Mode when Perimeter Detect features are in use, it may be difficult to make significant changes to your configuration without locking youself out of the SEN, depending on the nature of your application and its configuration.\nActivate Production Mode To put the SEN into Production Mode only requires a function call followed by a power cycle.\nThe API function lock_binding puts the SEN into Production Mode. Below are three examples which check the current binding info, lock the SEN binding, then check the current binding info again. Remove the comments around the lock binding function to move to Production Mode.\nC - zkLockBinding // gcc example_binding.c -I /usr/include/zymkey -l zk_app_utils -o example_binding #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \"zk_app_utils.h\" #include \"zk_b64.h\" void check_code(int code, char* location){ if (code \u003c 0) { fprintf(stderr, \"FAILURE: %s - %s\\n\", location, strerror(code)); } else if (code \u003e= 0) { fprintf(stdout, \"SUCCESS: %s - %d\\n\", location, code); } } void HSM_soft_bind(zkCTX zk_ctx) { bool binding_is_locked = false; bool is_bound = false; int ret = zkGetCurrentBindingInfo(zk_ctx, \u0026binding_is_locked, \u0026is_bound); check_code(ret, \"zkGetCurrentBindingInfo\"); printf(\"Binding is locked: \"); printf(binding_is_locked ? \"true\" : \"false\"); printf(\"\\n\"); printf(\"SEN is bound: \"); printf(is_bound ? \"true\" : \"false\"); printf(\"\\n\\n\"); //ret = zkLockBinding(zk_ctx); //if(binding_is_locked \u0026\u0026 is_bound) //{ // check_code(ret, \"zkLockBinding - Already Bound\"); //} //else //{ // check_code(ret, \"zkLockBinding\"); //} //printf(\"\\n\"); ret = zkGetCurrentBindingInfo(zk_ctx, \u0026binding_is_locked, \u0026is_bound); check_code(ret, \"zkGetCurrentBindingInfo\"); printf(\"Binding is locked: \"); printf(binding_is_locked ? \"true\" : \"false\"); printf(\"\\n\"); printf(\"SEN is bound: \"); printf(is_bound ? \"true\" : \"false\"); printf(\"\\n\\n\"); } int main() { zkCTX zk_ctx; int status = zkOpen(\u0026zk_ctx); check_code(status, \"zkOpen\"); printf(\"\\n\\n\"); HSM_soft_bind(zk_ctx); status = zkClose(zk_ctx); check_code(status, \"zkClose\"); printf(\"\\n\"); return 0; } C++ - lockBinding #include \u003cstdio.h\u003e #include \u003czkAppUtilsClass.h\u003e using namespace std; using namespace zkAppUtils; void HSM_soft_bind(zkClass* zk_inst) { bool binding_is_locked = false; bool is_bound = false; zk_inst-\u003egetCurrentBindingInfo(binding_is_locked, is_bound); printf(\"Binding is locked: \"); printf(binding_is_locked ? \"true\" : \"false\"); printf(\"\\n\"); printf(\"SEN is bound: \"); printf(is_bound ? \"true\" : \"false\"); printf(\"\\n\"); //zk_inst-\u003elockBinding(); //printf(\"lockBinding successful\\n\"); zk_inst-\u003egetCurrentBindingInfo(binding_is_locked, is_bound); printf(\"Binding is locked: \"); printf(binding_is_locked ? \"true\" : \"false\"); printf(\"\\n\"); printf(\"SEN is bound: \"); printf(is_bound ? \"true\" : \"false\"); printf(\"\\n\"); } int main() { zkClass* zk_inst; zk_inst = new zkClass(); HSM_soft_bind(zk_inst); delete zk_inst; return 0; } Python - lock_binding import zymkey tup = zymkey.client.get_current_binding_info() print(\"SEN is bound: \" + str(tup[1])) print(\"Binding is locked: \" + str(tup[0])) #zymkey.client.lock_binding() tup = zymkey.client.get_current_binding_info() print(\"SEN is bound: \" + str(tup[1])) print(\"Binding is locked: \" + str(tup[0])) Warning Do not proceed without completing the steps outlined above, including setting the Perimeter Event Actions to none or notify. Prior to setting the Bind Lock. Finalize your device for deployment After using the APIs to lock binding, reboot. The blink pattern on the SEN will change to 3 rapid blinks once every 3 seconds to indicate that the SEN has bound to the host in Production Mode.\nIf you are using the Perimeter Detect features, close your perimeter circuits (for example, by closing the enclosure’s lid), and then clear any Perimeter Detect Events using the API:\npython3 -c \"import zymkey; idx = 0; zymkey.client.clear_perimeter_detect_info() for p in zymkey.client.get_perimeter_detect_info(): if p: print(f'Channel {idx} has a detected breach event. Clear the Perimeter Detect Events again.') idx += 1 else: print('No perimeter breach detected.')\" If you get a message that a breach event was detected from the above command, run it again to ensure all events have been cleared.\nWarning You only get one chance to set Perimeter Event Actions once you are in Production Mode! When it confirms that no breach events have been detected, it is then safe to arm the system by setting the Perimeter Event Actions to notify or selfdestruct, if desired.\nYour system is now armed and ready to be used in the field!\n","categories":"","description":"","excerpt":"If left in Development Mode, self-destruct events are simulated with …","ref":"/getting-started/sen/production-mode/","tags":"","title":"Enabling Production Mode - Secure Edge Node"},{"body":" DESTRUCTIVE ACTION THE BINDING PROCESS IS PERMANENT AND CANNOT BE REVERSED. PAY ATTENTION TO THE FOLLOWING:\nYour specific HSM4 will be permanently locked to the specific host device. It will be impossible to move or bind your HSM4 to another device. There are no factory resets, masterkeys, or other forms of recovery. If you are using the Perimeter Detect features, then the sequence in which you arm and disarm this feature is very important. Be sure to carefully follow the process steps below. Once you have locked your HSM4 into production mode, Zymbit cannot guarantee its operation if you subsequently do a major distribution upgrade (e.g. Raspbian Jessie to Stretch). Contact Zymbit for more information. If you decide that you are not ready for permanent binding, leave the HSM4 in developer mode, but beware this makes it easier for a bad actor to replace the host with rogue hardware.\nDESTRUCTIVE ACTION When you have completed your development work with the HSM4 and are ready to deploy your system into the field, we recommend that you permanently bind your HSM4 to a specific host device and SD card.\nResources Binding, Device ID, and Authentication HSM4 generates a unique Device ID by measuring certain attributes of the specific host and the HSM4 itself to permanently associate the two devices. Read article Summary of Steps Develop your application\nEnsure your host has all the necessary prerequisites in place to interface with the HSM4 and that it will be able to run your software application. Active production mode\nPermanently bind your HSM4 to the host device. Develop your application To begin, ensure that you have followed the Getting Started guide for your HSM4 carefully to install the prerequisite client software:\nResources HSM4 Install your HSM4 to a Raspberry Pi running Raspbian or Ubuntu before moving to production mode. Read article To reiterate, before you continue, the following steps should be complete:\nInstall a battery on the HSM4. Connect the GPIO header of the HSM4 to the GPIO pins of the host board while the host is powered down. Install HSM4 software on the host and establish temporary binding in development mode. After these steps have been completed, you are ready to prepare your device for permanent binding.\nPrepare Perimeter Detect The Perimeter Event Actions for your HSM4 should be set to none or notify only. If your HSM4’s action mode is set to selfdestruct, you might render your HSM4 useless while attempting to activate production mode.\nResources Perimeter Detect: HSM4 Understand how to use the HSM4’s perimeter detect features. Read article To do this quickly, with the HSM4 client libraries installed, you can run the following shell command to use the Python API to communicate with the HSM4 and set the Perimeter Event Actions to do nothing when triggered:\npython3 -c \"import zymkey; for ch in (0, 1): zymkey.client.set_perimeter_event_actions(ch, action_notify=False, action_self_destruct=False) zymkey.client.clear_perimeter_detect_info()\" Prepare your application If you intend to use your HSM4 to encrypt your root file system, you should complete that step now, using our guide. This step is highly recommended.\nResources Encrypting Root File System with Zymbit Security Modules Encrypt the root file system of your host device using LUKS and your HSM4. Read article You should then install your application on your host SBC (in the encrypted volume, if applicable).\nTest, debug, and test again Danger DO NOT skip this step. If you encounter a major issue with your application after your HSM4 has been permanently bound to your device and armed, you may not be able to fix it. Test the functionality of your application thoroughly to ensure it is free of major defects that will prevent it from functioning properly. After the HSM4 has been bound to your host SBC, especially if Perimeter Detect features are in use, it may be difficult to make significant chances to your configuration without locking youself out of the HSM4, depending on the nature of your application and its configuration.\nActivate production mode With the Zymkey, a physical tab was cut to go into production mode. In the HSM models, to go into production mode it only requires a function call followed by a reboot.\nThe API function lock binding puts the HSM into production mode. Below are three examples which check the current binding info, lock the HSM binding, then check the current binding info again. Remove the comments around the lock binding function to move to production mode.\nC - zkLockBinding // gcc example_binding.c -I /usr/include/zymkey -l zk_app_utils -o example_binding #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \"zk_app_utils.h\" #include \"zk_b64.h\" void check_code(int code, char* location){ if (code \u003c 0) { fprintf(stderr, \"FAILURE: %s - %s\\n\", location, strerror(code)); } else if (code \u003e= 0) { fprintf(stdout, \"SUCCESS: %s - %d\\n\", location, code); } } void HSM_soft_bind(zkCTX zk_ctx) { bool binding_is_locked = false; bool is_bound = false; int ret = zkGetCurrentBindingInfo(zk_ctx, \u0026binding_is_locked, \u0026is_bound); check_code(ret, \"zkGetCurrentBindingInfo\"); printf(\"Binding is locked: \"); printf(binding_is_locked ? \"true\" : \"false\"); printf(\"\\n\"); printf(\"HSM is bound: \"); printf(is_bound ? \"true\" : \"false\"); printf(\"\\n\\n\"); //ret = zkLockBinding(zk_ctx); //if(binding_is_locked \u0026\u0026 is_bound) //{ // check_code(ret, \"zkLockBinding - Already Bound\"); //} //else //{ // check_code(ret, \"zkLockBinding\"); //} //printf(\"\\n\"); ret = zkGetCurrentBindingInfo(zk_ctx, \u0026binding_is_locked, \u0026is_bound); check_code(ret, \"zkGetCurrentBindingInfo\"); printf(\"Binding is locked: \"); printf(binding_is_locked ? \"true\" : \"false\"); printf(\"\\n\"); printf(\"HSM is bound: \"); printf(is_bound ? \"true\" : \"false\"); printf(\"\\n\\n\"); } int main() { zkCTX zk_ctx; int status = zkOpen(\u0026zk_ctx); check_code(status, \"zkOpen\"); printf(\"\\n\\n\"); HSM_soft_bind(zk_ctx); status = zkClose(zk_ctx); check_code(status, \"zkClose\"); printf(\"\\n\"); return 0; } C++ - lockBinding #include \u003cstdio.h\u003e #include \u003czkAppUtilsClass.h\u003e using namespace std; using namespace zkAppUtils; void HSM_soft_bind(zkClass* zk_inst) { bool binding_is_locked = false; bool is_bound = false; zk_inst-\u003egetCurrentBindingInfo(binding_is_locked, is_bound); printf(\"Binding is locked: \"); printf(binding_is_locked ? \"true\" : \"false\"); printf(\"\\n\"); printf(\"HSM is bound: \"); printf(is_bound ? \"true\" : \"false\"); printf(\"\\n\"); //zk_inst-\u003elockBinding(); //printf(\"lockBinding successful\\n\"); zk_inst-\u003egetCurrentBindingInfo(binding_is_locked, is_bound); printf(\"Binding is locked: \"); printf(binding_is_locked ? \"true\" : \"false\"); printf(\"\\n\"); printf(\"HSM is bound: \"); printf(is_bound ? \"true\" : \"false\"); printf(\"\\n\"); } int main() { zkClass* zk_inst; zk_inst = new zkClass(); HSM_soft_bind(zk_inst); delete zk_inst; return 0; } Python - lock_binding import zymkey tup = zymkey.client.get_current_binding_info() print(\"HSM is bound: \" + str(tup[1])) print(\"Binding is locked: \" + str(tup[0])) #zymkey.client.lock_binding() tup = zymkey.client.get_current_binding_info() print(\"HSM is bound: \" + str(tup[1])) print(\"Binding is locked: \" + str(tup[0])) Warning Do not proceed without completing the steps outlined above, including setting the Perimeter Event Actions to none or notify. Finalize your device for deployment After using the APIs to lock binding, reboot. The blink pattern on the HSM4 will change to 3 rapid blinks once every 3 seconds to indicate that HSM4 has bound to the host in production mode.\nIf you are using the Perimeter Detect features, close your perimeter circuits (for example, by closing the enclosure’s lid), and then clear any Perimeter Detect Events using the API:\npython3 -c \"import zymkey; idx = 0; zymkey.client.clear_perimeter_detect_info() for p in zymkey.client.get_perimeter_detect_info(): if p: print(f'Channel {idx} has a detected breach event. Clear the Perimeter Detect Events again.') idx += 1 else: print('No perimeter breach detected.')\" If you get a message that a breach event was detected from the above command, run it again to ensure all events have been cleared. When it confirms that no breach events have been detected, it is then safe to arm the system by setting the Perimeter Event Actions to notify or selfdestruct, if desired.\nYour system is now armed and ready to be used in the field!\n","categories":"","description":"","excerpt":" DESTRUCTIVE ACTION THE BINDING PROCESS IS PERMANENT AND CANNOT BE …","ref":"/getting-started/hsm4/production-mode/","tags":"","title":"Enabling Production Mode - HSM4"},{"body":" DESTRUCTIVE ACTION THE BINDING PROCESS IS PERMANENT AND CANNOT BE REVERSED. PAY ATTENTION TO THE FOLLOWING:\nYour specific HSM6 will be permanently locked to the specific host device. It will be impossible to move or bind your HSM6 to another device. There are no factory resets, masterkeys, or other forms of recovery. If you are using the Perimeter Detect features, then the sequence in which you arm and disarm this feature is very important. Be sure to carefully follow the process steps below. Once you have locked your HSM6 into production mode, Zymbit cannot guarantee its operation if you subsequently do a major distribution upgrade (e.g. Raspbian Jessie to Stretch). Contact Zymbit for more information. If you decide that you are not ready for permanent binding, leave the HSM6 in developer mode, but beware this makes it easier for a bad actor to replace the host with rogue hardware.\nDESTRUCTIVE ACTION When you have completed your development work with the HSM6 and are ready to deploy your system into the field, we recommend that you permanently bind your HSM6 to a specific host device and SD card.\nResources Binding, Device ID, and Authentication HSM6 generates a unique Device ID by measuring certain attributes of the specific host and the HSM6 itself to permanently associate the two devices. Read article Summary of Steps Develop your application\nEnsure your host has all the necessary prerequisites in place to interface with the HSM6 and that it will be able to run your software application. Active production mode\nPermanently bind your HSM6 to the host device. Develop your application To begin, ensure that you have followed the Getting Started guide for your HSM6 carefully to install the prerequisite client software:\nResources HSM6 Install your HSM6 to a Raspberry Pi running Raspbian or Ubuntu before moving to production mode. Read article To reiterate, before you continue, the following steps should be complete:\nInstall a battery on the HSM6. Connect the GPIO header of the HSM6 to the GPIO pins of the host board while the host is powered down. Install HSM6 software on the host and establish temporary binding in development mode. After these steps have been completed, you are ready to prepare your device for permanent binding.\nPrepare Perimeter Detect The Perimeter Event Actions for your HSM6 should be set to none or notify only. If your HSM6’s action mode is set to selfdestruct, you might render your HSM6 useless while attempting to activate production mode.\nResources Perimeter Detect: HSM6 Understand how to use the HSM6’s perimeter detect features. Read article To do this quickly, with the HSM6 client libraries installed, you can run the following shell command to use the Python API to communicate with the HSM6 and set the Perimeter Event Actions to do nothing when triggered:\npython3 -c \"import zymkey; for ch in (0, 1): zymkey.client.set_perimeter_event_actions(ch, action_notify=False, action_self_destruct=False) zymkey.client.clear_perimeter_detect_info()\" Prepare your application If you intend to use your HSM6 to encrypt your root file system, you should complete that step now, using our guide. This step is highly recommended.\nResources Encrypting Root File System with Zymbit Security Modules Encrypt the root file system of your host device using LUKS and your HSM6. Read article You should then install your application on your host SBC (in the encrypted volume, if applicable).\nTest, debug, and test again Danger DO NOT skip this step. If you encounter a major issue with your application after your HSM6 has been permanently bound to your device and armed, you may not be able to fix it. Test the functionality of your application thoroughly to ensure it is free of major defects that will prevent it from functioning properly. After the HSM6 has been bound to your host SBC, especially if Perimeter Detect features are in use, it may be difficult to make significant chances to your configuration without locking youself out of the HSM6, depending on the nature of your application and its configuration.\nActivate production mode With the Zymkey, a physical tab was cut to go into production mode. In the HSM models, to go into production mode it only requires a function call followed by a reboot.\nThe API function lock binding puts the HSM into production mode. Below are three examples which check the current binding info, lock the HSM binding, then check the current binding info again. Remove the comments around the lock binding function to move to production mode.\nC - zkLockBinding // gcc example_binding.c -I /usr/include/zymkey -l zk_app_utils -o example_binding #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \"zk_app_utils.h\" #include \"zk_b64.h\" void check_code(int code, char* location){ if (code \u003c 0) { fprintf(stderr, \"FAILURE: %s - %s\\n\", location, strerror(code)); } else if (code \u003e= 0) { fprintf(stdout, \"SUCCESS: %s - %d\\n\", location, code); } } void HSM_soft_bind(zkCTX zk_ctx) { bool binding_is_locked = false; bool is_bound = false; int ret = zkGetCurrentBindingInfo(zk_ctx, \u0026binding_is_locked, \u0026is_bound); check_code(ret, \"zkGetCurrentBindingInfo\"); printf(\"Binding is locked: \"); printf(binding_is_locked ? \"true\" : \"false\"); printf(\"\\n\"); printf(\"HSM is bound: \"); printf(is_bound ? \"true\" : \"false\"); printf(\"\\n\\n\"); //ret = zkLockBinding(zk_ctx); //if(binding_is_locked \u0026\u0026 is_bound) //{ // check_code(ret, \"zkLockBinding - Already Bound\"); //} //else //{ // check_code(ret, \"zkLockBinding\"); //} //printf(\"\\n\"); ret = zkGetCurrentBindingInfo(zk_ctx, \u0026binding_is_locked, \u0026is_bound); check_code(ret, \"zkGetCurrentBindingInfo\"); printf(\"Binding is locked: \"); printf(binding_is_locked ? \"true\" : \"false\"); printf(\"\\n\"); printf(\"HSM is bound: \"); printf(is_bound ? \"true\" : \"false\"); printf(\"\\n\\n\"); } int main() { zkCTX zk_ctx; int status = zkOpen(\u0026zk_ctx); check_code(status, \"zkOpen\"); printf(\"\\n\\n\"); HSM_soft_bind(zk_ctx); status = zkClose(zk_ctx); check_code(status, \"zkClose\"); printf(\"\\n\"); return 0; } C++ - lockBinding #include \u003cstdio.h\u003e #include \u003czkAppUtilsClass.h\u003e using namespace std; using namespace zkAppUtils; void HSM_soft_bind(zkClass* zk_inst) { bool binding_is_locked = false; bool is_bound = false; zk_inst-\u003egetCurrentBindingInfo(binding_is_locked, is_bound); printf(\"Binding is locked: \"); printf(binding_is_locked ? \"true\" : \"false\"); printf(\"\\n\"); printf(\"HSM is bound: \"); printf(is_bound ? \"true\" : \"false\"); printf(\"\\n\"); //zk_inst-\u003elockBinding(); //printf(\"lockBinding successful\\n\"); zk_inst-\u003egetCurrentBindingInfo(binding_is_locked, is_bound); printf(\"Binding is locked: \"); printf(binding_is_locked ? \"true\" : \"false\"); printf(\"\\n\"); printf(\"HSM is bound: \"); printf(is_bound ? \"true\" : \"false\"); printf(\"\\n\"); } int main() { zkClass* zk_inst; zk_inst = new zkClass(); HSM_soft_bind(zk_inst); delete zk_inst; return 0; } Python - lock_binding import zymkey tup = zymkey.client.get_current_binding_info() print(\"HSM is bound: \" + str(tup[1])) print(\"Binding is locked: \" + str(tup[0])) #zymkey.client.lock_binding() tup = zymkey.client.get_current_binding_info() print(\"HSM is bound: \" + str(tup[1])) print(\"Binding is locked: \" + str(tup[0])) Warning Do not proceed without completing the steps outlined above, including setting the Perimeter Event Actions to none or notify. Finalize your device for deployment After using the APIs to lock binding, reboot. The blink pattern on the HSM6 will change to 3 rapid blinks once every 3 seconds to indicate that HSM6 has bound to the host in production mode.\nIf you are using the Perimeter Detect features, close your perimeter circuits (for example, by closing the enclosure’s lid), and then clear any Perimeter Detect Events using the API:\npython3 -c \"import zymkey; idx = 0; zymkey.client.clear_perimeter_detect_info() for p in zymkey.client.get_perimeter_detect_info(): if p: print(f'Channel {idx} has a detected breach event. Clear the Perimeter Detect Events again.') idx += 1 else: print('No perimeter breach detected.')\" If you get a message that a breach event was detected from the above command, run it again to ensure all events have been cleared. When it confirms that no breach events have been detected, it is then safe to arm the system by setting the Perimeter Event Actions to notify or selfdestruct, if desired.\nYour system is now armed and ready to be used in the field!\n","categories":"","description":"","excerpt":" DESTRUCTIVE ACTION THE BINDING PROCESS IS PERMANENT AND CANNOT BE …","ref":"/getting-started/hsm6/production-mode/","tags":"","title":"Enabling Production Mode - HSM6"},{"body":" DESTRUCTIVE ACTION THE BINDING PROCESS IS PERMANENT AND CANNOT BE REVERSED. PAY ATTENTION TO THE FOLLOWING:\nYour specific ZYMKEY4 will be permanently locked to the specific host device. It will be impossible to move or bind your ZYMKEY4 to another device. There are no factory resets, masterkeys, or other forms of recovery. If you are using the Perimeter Detect features, then the sequence in which you arm and disarm this feature is very important. Be sure to carefully follow the process steps below. Once you have locked your ZYMKEY4 into production mode, Zymbit cannot guarantee its operation if you subsequently do a major distribution upgrade (e.g. Raspbian Jessie to Stretch). Contact Zymbit for more information. If you decide that you are not ready for permanent binding, leave the ZYMKEY4 in developer mode, but beware this makes it easier for a bad actor to replace the host with rogue hardware.\nDESTRUCTIVE ACTION When you have completed your devlopment work with the ZYMKEY4 and are ready to deploy your system into the field, we recommend that you permanently bind your ZYMKEY4 to a specific host device and SD card.\nResources Binding, Device ID, and Authentication ZYMKEY4 generates a unique Device ID by measuring certain attributes of the specific host and the ZYMKEY4 itself to permanently associate the two devices. Read article Summary of Steps Develop your application Ensure your host has all the necessary prerequisites in place to interface with the ZYMKEY4 and that it will be able to run your software application. Active production mode Permanently bind your ZYMKEY4 to the host device. Develop your application DESTRUCTIVE ACTION DO NOT cut the lock tab yet. DESTRUCTIVE ACTION To begin, ensure that you have followed the Getting Started guide for your ZYMKEY4 carefully to install the prerequisite client software:\nResources ZYMKEY4 Install your ZYMKEY4 to a Raspberry Pi running Raspbian or Ubuntu before moving to production mode. Read article To reiterate, before you continue, the following steps should be complete:\nInstall a battery on the ZYMKEY4. Connect the GPIO header of the ZYMKEY4 to the GPIO pins of the host board while the host is powered down. Install ZYMKEY4 software on the host and establish temporary binding in development mode. After these steps have been completed, you are ready to prepare your device for permanent binding.\nPrepare Perimeter Detect The Perimeter Event Actions for your ZYMKEY4 should be set to none or notify only. If your ZYMKEY4’s action mode is set to selfdestruct, you might render your ZYMKEY4 useless while attempting to activate production mode.\nResources Perimeter Detect: ZYMKEY4 Understand how to use the ZYMKEY4’s perimeter detect features. Read article To do this quickly, with the ZYMKEY4 client libraries installed, you can run the following shell command to use the Python API to communicate with the ZYMKEY4 and set the Perimeter Event Actions to do nothing when triggered:\npython3 -c \"import zymkey; for ch in (0, 1): zymkey.client.set_perimeter_event_actions(ch, action_notify=False, action_self_destruct=False) zymkey.client.clear_perimeter_detect_info()\" Prepare your application If you intend to use your ZYMKEY4 to encrypt your root file system, you should complete that step now, using our guide. This step is highly recommended.\nResources Encrypt the root file system of your host device using LUKS and your ZYMKEY4. Read article You should then install your application on your host SBC (in the encrypted volume, if applicable).\nTest, debug, and test again Danger DO NOT skip this step. If you encounter a major issue with your application after your ZYMKEY4 has been permanently bound to your device and armed, you may not be able to fix it. Test the functionality of your application thoroughly to ensure it is free of major defects that will prevent it from functioning properly. After the ZYMKEY4 has been bound to your host SBC, especially if Perimeter Detect features are in use, it may be difficult to make significant chances to your configuration without locking youself out of the ZYMKEY4, depending on the nature of your application and its configuration.\nActivate production mode Danger DO NOT cut the lock tab yet. Before proceeding, shut your host board down and disconnect it from power. Then, without removing the ZYMKEY4’s battery (if installed), remove the ZYMKEY4 from the host SBC.\nCut the lock tab Warning This procedure can be performed while the ZYMKEY4 is connected to the host SBC, but the host must be disconnected from power.\nDo not proceed without completing the steps outlined above, including setting the Perimeter Event Actions to none or notify.\nFollow the procedure below carefully to move your ZYMKEY4 into production mode.\n1. Use sharp diagonal cutter pliers 2. Cut the tab Align the pliers with the guide lines on the Cut-2-Lock tab, and carefully cut the tab. 3. Finish the cut The resulting cut should leave the edge of the ZYMKEY4 motherboard flush. If portions of the tab remain attached to the board, you can remove them with the angle cutter pliers. Finalize your device for deployment After cutting the lock tab, reinstall the ZYMKEY4 the host SBC, reconnect it to power, and boot into the host. The blink pattern on the ZYMKEY4 will change to 3 rapid blinks once every 3 seconds to indicate that ZYMKEY4 has bound to the host in production mode.\nIf you are using the Perimeter Detect features, close your perimeter circuits (for example, by closing the enclosure’s lid), and then clear any Perimeter Detect Events using the API:\npython3 -c \"import zymkey; idx = 0; zymkey.client.clear_perimeter_detect_info() for p in zymkey.client.get_perimeter_detect_info(): if p: print(f'Channel {idx} has a detected breach event. Clear the Perimeter Detect Events again.') idx += 1 else: print('No perimeter breach detected.')\" If you get a message that a breach event was detected from the above command, run it again to ensure all events have been cleared. When it confirms that no breach events have been detected, it is then safe to arm the system by setting the Perimeter Event Actions to notify or selfdestruct, if desired.\nYour system is now armed and ready to be used in the field!\n","categories":"","description":"","excerpt":" DESTRUCTIVE ACTION THE BINDING PROCESS IS PERMANENT AND CANNOT BE …","ref":"/getting-started/zymkey4/production-mode/","tags":"","title":"Enabling Production Mode - ZYMKEY4"},{"body":"Updated: 2023-01-22\nWhat is Supervised Boot? Supervised Boot is Zymbit’s method for insuring that the boot process is secure. A list of files can be specifed to be hashed, signed, and verified by the SCM prior to allowing the CM4 module to boot. By default, the following files are signed and verified:\n/boot/bcm2711-rpi-cm4.dtb /boot/cmdline.txt /boot/config.txt /boot/initrd.img /boot/kernel8.img (or /boot/kernel7l.img for 32-bit) /boot/start4.elf /boot/zymbit_mac_address /boot/overlays/vc4-kms-v3d.dtbo The Manifest The Manifest is the list of files that will be tracked and verified by the Zymbit Secure Compute Module (SCM) during the boot process. The Manifest resides within the SCM itself. It does not live on any file system. Zymbit provides an API interface to add/update/delete entries in the Manifest as well as set the action to take if a signature verification of a file should fail.\nAll files in the Manifest must reside within the /boot partition. File paths in the Manifest all include /boot/ by default. Only include the portion of the file path after /boot/. For instance, to include /boot/config.txt, you would call our API with the string config.txt.\nIf any file exists in the Manifest, Supervised Boot is automatically enabled. To turn off Supervised Boot, remove all files from the Manifest.\nExample Python CLI Application Prerequisites Zymbit Modules that support this feature:\nSecure Compute Module (SCM ) All code snippets written in this article are written using Python3. For more Zymbit API documentation (Python/C/C++) visit: API Documentation\nExample Application The code below can be used to add/update/delete and display the Manifest of files to check during Secure Boot operation. It can also update all the files in the Manifest or delete all the files in the Manifest. Save the code below to a file. We will name it manifest.py for the following examples.\n#!/usr/bin/python3 import argparse import zymkey def add_update(filepath, slot=None): if slot: print(f\"Manifest Add/Update {filepath} slot={slot}\") zymkey.client.add_or_update_supervised_boot_file(filepath, int(slot)) else: print(f\"Manifest Add/Update {filepath} default slot=15\") zymkey.client.add_or_update_supervised_boot_file(filepath) def update_all_entries(slot=None): list = zymkey.client.get_supervised_boot_file_manifest() if len(list) == 0: print(\"Manifest is empty\") else: for filepath in list.split(): add_update(filepath, slot) def delete(filepath): print(f\"Manifest Delete: {filepath}\") zymkey.client.remove_supervised_boot_file(filepath) def delete_all_entries(): list = zymkey.client.get_supervised_boot_file_manifest() if len(list) == 0: print(\"Manifest is empty\") else: for filepath in list.split(): delete(filepath) def show(): print(\"\\nManifest:\") print(\"---------\") list = zymkey.client.get_supervised_boot_file_manifest() if len(list) == 0: print(\"Manifest is empty\") else: for filepath in list.split(): print(filepath) print(\"\") if __name__ == \"__main__\": # Setup arg parser parser = argparse.ArgumentParser( description=\"add/del/update Supervised Boot Manifest. (show by default)\", epilog=\"filepath from /boot. ex: for /boot/config.txt, provide config.txt.\" ) group = parser.add_mutually_exclusive_group() group.add_argument(\"-a\", \"--add\", metavar=\"filepath\", help=\"add filepath to manifest\", action=\"store\", required=False) group.add_argument(\"-u\", \"--update\", metavar=\"filepath\", help=\"update filepath in manifest\", action=\"store\", required=False) group.add_argument(\"-U\", help=\"update all entries in manifest\", action=\"store_true\", required=False) group.add_argument(\"-d\", \"--delete\", metavar=\"filepath\", help=\"delete filepath from manifest\", action=\"store\", required=False) group.add_argument(\"-D\", help=\"delete all entries from manifest\", action=\"store_true\", required=False) parser.add_argument(\"-s\", \"--slot\", metavar=\"slot_num\", help=\"use slot for add/delete (default=15)\", action=\"store\", required=False) args = parser.parse_args() parser.parse_args() if args.add: add_update(args.add, args.slot) elif args.update: add_update(args.update, args.slot) elif args.U: print(\"Updating all entries in manifest...\") update_all_entries(args.slot) elif args.delete: delete(args.delete) elif args.D: print(\"Deleting all entries from manifest...\") delete_all_entries() show() Working with the Manifest Running the example with no parameters will display the current contents of the Manifest. The default Manifest as shipped contains:\n$ ./manifest.py Manifest: --------- bcm2711-rpi-cm4.dtb bootcode.bin cmdline.txt config.txt initrd.img kernel8.img start4.elf zymbit_mac_address overlays/vc4-kms-v3d.dtbo To add a file to the Manifest, run the example script with the --add option and give it a filepath to a file in /boot. We’ll create a sample file by copying /etc/hosts,\n$ sudo cp /etc/hosts /boot/sample.txt $ ./manifest.py --add sample.txt Manifest: --------- bcm2711-rpi-cm4.dtb bootcode.bin cmdline.txt config.txt initrd.img kernel8.img start4.elf zymbit_mac_address overlays/vc4-kms-v3d.dtbo sample.txt The SCM will create a signature for the file sample.txt and store it internally. The SCM will verify that signature against the file upon the next boot. If the signature does not verify, the SCM will be held in reset and will not boot. In Development Mode (no bind lock), the SCM will “simulate” this process by flashing an LED sequence of 4 followed by 2 flashes, repeated three times, and then the SCM will boot normally.\nYou can test this out:\nFirst, after adding sample.txt to the Manifest and power cycle. The system should boot normally. Next, edit /boot/sample.txt and power cycle. The sign/verify process will fail and the SCM will simulate a Held in Reset condition with a sequence of 4 flashes followed by 2 flashes, three times. If left in Development Mode (no bind lock), the SCM will boot up and allow you to recover. There are three ways you can remedy the verification failure:\nEdit /boot/sample.txt and revert back to its original contents.\nUpdate the Manifest to sync up the current contents of the file with the Manifest\n./manifest.py --update sample.txt\nRemove the file from the Manifest with `./manifest.py –delete\n./manifest.py --delete sample.txt\nThe next powercycle should boot with the normal sequence - it should not flash the 4 flashes followed by 2 flashes, three times sequence.\nSpecifying a Different Slot The example above uses the default slot 15 but will take alternative slot numbers, 0-15. Slots in the key store (Slots 16-528) are not supported.\n","categories":"","description":"","excerpt":"Updated: 2023-01-22\nWhat is Supervised Boot? Supervised Boot is …","ref":"/tutorials/supervised-boot/","tags":"","title":"Working with SCM Supervised Boot"},{"body":"Introduction While all Zymbit modules make it trivial to verify data signed on the device with that module, verifying the signature of data on other devices using the exportable public key requires a little more explanation. Below is a simple code snippet to show how to verify the signature of data using Zymbit’s Python API.\n#!/usr/bin/python3 import zymkey # sign data data = 'hello world!' payload_sig = zymkey.client.sign(data) # verify signature matches encrypted data try: if zymkey.client.verify(data, payload_sig): print('Signature signed correctly by Zymbit module and matches payload.') except Exception as e: print('Signature invalid. Data not signed by Zymbit module private key.') Since the IoT environment is all about communication among many devices, we will demonstrate how to verify a Zymbit module’s ECDSA signature on other devices. We will do this using the public key corresponding to the device’s private key stored securely on the Zymbit module.\nAfter showing how to do signature verification, we will demonstrate how this can be used in a practical situation by collecting temperature data from a sensor and signing the data. We will then package the data in JSON format - a standard format for data communication over the internet using strings. This data will then be published to AWS IoT, where it will be routed via a Rule to a Lambda Function. The Lambda Function will validate the data based on the public key. From there you can route the data to any service you desire.\nThis post will demonstrate how to validate the signatures of all data sent to AWS before processing by another service. All data published to AWS will be authenticated against a device certificate which validates against the Zymbit module’s private key without exporting said key. We will do this by making HTTPS requests to AWS IoT using PyCurl. This serves as client authentication when connecting to AWS IoT. All these examples will be done via Python using the Python-ECDSA library.\nPrerequisites Follow the Getting Started guide first, installing all baseline software. If you wish to try Signature validation on AWS, you need a valid device certificate attached to your AWS account. The device certificate needs to have a policy attached giving it permission to publish data. Simple Signature Validation against Zymkey Public Key Installing Python-Ecdsa library For the verification of ECDSA-NIST256 signatures, we will be using the Python-ECDSA library. Using Pip, the library can be installed simply by running the following command:\nsudo pip3 install ecdsa Simple Signature Verification with Public Key Below is a simple Python program demonstrating how to verify a Zymbit module signature with a public key hosted on a device bound to that Zymbit module. The data passed to the ECDSA verifying function is in bytearray format. The function is validating against the default signing hash function Zymbit module uses, sha256, and returns a boolean indicating whether the signature matches the public key and data. The public key for Zymkey is exported as bytearray using the API function get_public_key().\n#!/usr/bin/python3 import zymkey import ecdsa import hashlib # Function to verify ECDSA signatures, all arguments must be in bytearray format. # Validating against Zymkey signing's default hashing function, sha256 but this can be modified. def verify_ecdsa_signature(data, sig, pub_key): vk = ecdsa.VerifyingKey.from_string(pub_key, ecdsa.NIST256p) return vk.verify(sig, data, hashfunc=hashlib.sha256) if __name__ == \"__main__\": # exporting Zymkey public key as bytearray pub_key = zymkey.client.get_public_key(slot=0, foreign=False) data = 'hello world!' data_bytes = bytearray(data, 'utf-8') payload_sig = zymkey.client.sign(data) if verify_ecdsa_signature(data=data_bytes, sig=payload_sig, pub_key = pub_key): print('Signature matches data and public key pair.') else: print('Signature is invalid; it does not correspond to the public key.') Signature Verification on Another Device This next section will simulate signature verification on another device that receives data in JSON format that has been signed with a Zymbit module. The public key is hard coded into the program for the sake of a simple demonstration, but public key exchange between devices is up to the discretion of the user.\nThe data payload and signature is passed in a JSON string in the format of a hex string. Hex strings are simply representations of the underlying bytes in a human readable format. The JSON data is represented below as the variable received_payload. For this example, we are using received_payload data generated with the following example code on your device with the Zymbit module.\nExport Public Key and Generate Example JSON Data for Validation\n#!/usr/bin/python3 import json import zymkey if __name__ == \"__main__\": # Get public key to give to remote pub_key = zymkey.client.get_public_key() print(\"Public key:\") print(pub_key.hex()) # Create data then sign data data = 'hello world' data_bytes = bytearray(data, 'utf-8') signature = zymkey.client.sign(data) # Store data in a python dictionary that represents JSON. Data is originally in bytearray form # but will be converted to hex_string json_dictionary = { 'data': data_bytes.hex(), 'signature': signature.hex() } # Convert python dictionary to JSON string format received_payload = json.dumps(json_dictionary) print(\"\\nJSON string:\") print(received_payload) Python Code to Verify Signature with Data Generated above\nEither substitute in your pub_key and JSON data from the previous example or use as is.\n#!/usr/bin/python3 import json import zymkey import hashlib import ecdsa def verify_ecdsa_signature(data, sig, pub_key): vk = ecdsa.VerifyingKey.from_string(pub_key, ecdsa.NIST256p) return vk.verify(sig, data, hashfunc=hashlib.sha256) if __name__ == \"__main__\": # Zymkey public key in hex string format. Converted to byte_array, public key storage/exchange up to user. pub_key = bytearray.fromhex('6cd0b8b14963f6712877eb50a3f5afa9c0e39483e560f58eb795e634df53f399ba370dbceb71ea87cba5e2fca4f23ef73b8e683a9946758829f76521e7a19e5a') ''' The variable received_payload will be the JSON string sent over to this device from the Zymkey. It contains 1.the data and 2.the signature for this data. See next code example to create an example. Here is how it will be formatted: \"{ 'data': 'hex_string of data', 'signature': 'hex_string of signature; }\" ''' received_payload = '{ \"data\": \"68656c6c6f20776f726c64\", \"signature\": \"28953e99dcc7f7ebf2771acae9e996e45997a212f7deba04a5974d1db6651fc8c50f11a5e5ad24ef25bdf0dafbdb736513f618184505f469f126c7dd4557cade\" }' # Converting JSON string to Python dictionary for easier manipulation payload_pydict = json.loads(received_payload) # Getting the hex_strings from the new Python dictionary payload = payload_pydict['data'] payload_sig = payload_pydict['signature'] # Validating signature against public key and data, converting all hex_strings to bytearrays. if verify_ecdsa_signature(data=bytearray.fromhex(payload), sig=bytearray.fromhex(payload_sig), pub_key=pub_key): print('Signature matches data and public key pair.') else: print('Signature is invalid; it does not correspond to the public key.') Validation of Sensor Data Signature on AWS This example will generate randomly simulated temperature sensor data, package the data into JSON format, and sign and send to send to AWS IoT. The function read_temp() will return an array containing random values for temp_c and temp_f.\nNotice If you wish to use an actual DS18B20 OneWire probe to collect temperature data, you can follow the instructions at this link.\nResources Using a DS18B20 OneWire Probe to Collect Temperature Data Read article Add this code and substitute for the read_temp() function in the example below. This code collects Temperature data from the probe. It reads from a file that the probes deposit temperature data to. The function read_temp() will return an array containing temp_c and temp_f, whenever you need to read temperature from the probes. Substitute this next snippet of code if you are using a real probe.\n#!/usr/bin/python3 os.system('modprobe w1-gpio') os.system('modprobe w1-therm') base_dir = '/sys/bus/w1/devices/' device_folder = glob.glob(base_dir + '28*')[0] device_file = device_folder + '/w1_slave' def read_temp(): # Supplies random temperature in Celsius and Farenheit for this example. lines = read_temp_raw() while lines[0].strip()[-3:] != 'YES': time.sleep(0.2) lines = read_temp_raw() equals_pos = lines[1].find('t=') if equals_pos != -1: temp_string = lines[1][equals_pos+2:] temp_c = float(temp_string) / 1000.0 temp_f = temp_c * 9.0 / 5.0 + 32.0 return temp_c, temp_f Collect data in JSON format, sign, and prepare for AWS\n#!/usr/bin/python3 import json import random import time import zymkey ''' Note that JSON data needs to be in this format: \"{ 'data': 'hex_string of data', 'signature': 'hex_string of signature; }\" If you wish to use a different JSON format, you can always modify the lambda function. ''' def read_temp(): # this provides simulated random data for the example temp_c = float(random.randint(0,100)) temp_f = temp_c * 9.0 / 5.0 + 32.0 return temp_c, temp_f while True: temp_C, temp_F = read_temp() deviceID = 1 myIP= '192.168.100.100' # Package the data in Python dictionary, then convert to JSON string. data = {'temp_F': temp_F, 'temp_C': temp_C, 'deviceIP': myIP, 'deviceID': deviceID} # sign the JSON string json_str = json.dumps(data) json_str_bytes = bytearray(json_str, 'utf-8') signature = zymkey.client.sign(json_str) # Make a new dictionary to hold the hex_strings of the data and signature, and then turn into JSON json_data = json.dumps({'data': json_str_bytes.hex(), 'signature': signature.hex()}) print(json_data) # 10 seconds before reading temperature again time.sleep(10) Sending Encrypted Temperature Data to AWS The AWS SDK doesn’t support TLS connections over OpenSSL engines. Therefore, since we keep the private key in the Zymbit module and not the file system, we will use CURL to make HTTPS requests to AWS with the Zymbit module’s embedded private key. We will be using PyCurl to do this programatically.\nInstalling PyCurl\nPyCurl is simply a wrapper on the libssl library for C/C++. Install and configure libssl library along with PyCurl:\nsudo apt-get install libcurl4-openssl-dev sudo apt-get install libssl-dev sudo pip install pycurl Registering Zymbit module device Certificate\nConnecting to and Publishing data to AWS IoT requries you to present a valid certificate that has been regsitered with your AWS account. Instructions for that process is outlined here. Make sure that the certificate has a policy attached to allow data publication on AWS, if you follow the post completely this should be done.\nPublishing data to AWS IoT\nNext we will publish the temperature data signed and saved from the last section to AWS IoT using PyCurl. Make sure to find and change your AWS IoT endpoint in the following code. Information on how to do this can be found in the tutorial linked above.\n#!/usr/bin/python3 import json import pycurl import random import time import zymkey def read_temp(): temp_c = float(random.randint(0,100)) temp_f = temp_c * 9.0 / 5.0 + 32.0 return temp_c, temp_f def ZK_AWS_Publish(url, post_field, CA_Path, Cert_Path,): c = pycurl.Curl() # Set Curl to use zymkey_ssl engine c.setopt(c.SSLENGINE, \"zymkey_ssl\") c.setopt(c.SSLVERSION, c.SSLVERSION_TLSv1_2) # Set certificates for HTTPS connection c.setopt(c.SSLCERT, Cert_Path) c.setopt(c.CAINFO, CA_Path) # Set endpoint and HTTPS type, here it is a POST c.setopt(c.URL, url) c.setopt(c.POSTFIELDS, post_field) # Tell Curl to do client and host authentication c.setopt(c.SSL_VERIFYPEER, 1) c.setopt(c.SSL_VERIFYHOST, 2) # Turn on Verbose output and set key as placeholder, not actually a real file. c.setopt(c.VERBOSE, 1) c.setopt(c.SSLKEYTYPE, \"ENG\")\tc.setopt(c.SSLKEY, \"nonzymkey.key\") c.perform() c.close() if __name__ == '__main__': while True: temp_C, temp_F = read_temp() deviceID = 1 myIP= '192.168.100.100' # Package the data in Python dictionary, then convert to JSON string. data = {'temp_F': temp_F, 'temp_C': temp_C, 'deviceIP': myIP, 'deviceID': deviceID} # sign the JSON string json_str = json.dumps(data) json_str_bytes = bytearray(json_str, 'utf-8') signature = zymkey.client.sign(json_str) # Make a new dictionary to hold the hex_strings of the data and signature, and then turn into JSON json_data = json.dumps({'data': json_str_bytes.hex(), 'signature': signature.hex()}) # make sure and substitute you AWS endpoint as well as the paths to your certificate AWS_ENDPOINT = 'https://\u003cendpoint\u003e.amazonaws.com:8443/topics/pub_key_validate?qos=1' ZK_AWS_Publish(url=AWS_ENDPOINT, post_field=json_data, CA_Path='/home/pi/verify-sig/AWS_CA.pem', Cert_Path='/home/pi/verify-sig/zymkey.crt') time.sleep(10) Checking Data is being published to AWS IoT If all the previous steps have been done correctly, then you should be able to see the JSON string you published on the AWS IoT console. It will be published to the topic pub_key_validate. This is encoded in the endpoint link you can see in the code. The topic can be changed to whatever you want. Here’s how to check the data from the AWS IoT console:\nFrom the AWS console, select AWS IoT. On the left hand bar, select Test. If MQTT Test is shown choose that. Under subscription topic, write pub_key_validate and hit subscribe. You should see your data being shown as it is being published. Verifying Signature of Encrypted Data with Zymkey Public Key on AWS Signature Verification Lambda function An AWS Lambda function is code that runs on the cloud based on a configured trigger. For this demonstration, the trigger will be data published to a specific topic, pub_key_validate, on AWS IoT. From there the lambda function can validate signatures and talk with any other AWS service.\nThe function is written in terms of a lambda_handler. The event that it gets passed is the JSON string published to AWS IoT. The Python lambda context automatically converts event from a JSON string to Python dictionary.\n#!/usr/bin/python3 import ecdsa import json import hashlib def verify_ecdsa_signature(data, sig, pub_key): vk = ecdsa.VerifyingKey.from_string(pub_key, ecdsa.NIST256p) return vk.verify(sig, data, hashfunc=hashlib.sha256) def lambda_handler(event, context): #event is already converted from json-\u003epython dict pub_key_byte = bytearray.fromhex('9929a80b1d2e1543992dc767f394d1859bc33e9b241203f53473d859e1506f7ee5593b53a7fe7014aecc1f14886e1440e6bde27571c596a7ae3d1573e4122d90') byte_data = bytearray.fromhex(event['data']) byte_signature = bytearray.fromhex(event['signature']) success_message = 'Signature is authenticated against public key and data presented; it is valid.' fail_message = 'Signature authentication has failed.' if verify_ecdsa_signature(data=byte_data, sig=byte_signature, pub_key=pub_key_byte): print(success_message) return success_message else: print(fail_message) return fail_message Setting up Lambda function on AWS\nThe lambda function is the python code that actually validates your Zymbit module signature. The data in JSON format will be published to AWS IoT, and then routed to the lambda function. This is triggered by an IoT rule. This basic lambda function will take the JSON string, validate the data using the Python-ECDSA package, and then print and log its success status.\nTo set up the lambda function on AWS, we must first package the code with the ECDSA package, since it is not part of the Python STL. To do this we zip up the lambda code with the ECDSA package in the build directory.\nPackaging function with Python-ECDSA\nYou can download a pre-configured zip file with Python-ECDSA included here. You can modify the lambda function however you want here, but make sure you change the public key in particular if you want to test out simple validation. If you change the lambda function make sure it is changed inside the zip file.\nOtherwise just zip up the lambda function with the ecdsa directory you made in the build directory. You can do this by first cloning the Github repository. Then build the project by running this build command while inside the project directory.\npython setup.py build Find the ecdsa directory inside the build directory, and zip up that directory with your code.\nNow, follow these steps to upload and activate your code on AWS:\nFrom the AWS Console, select Lambda Select the orange Create function button Choose to Author from Scratch Click next, the trigger will be configured later. Give the Lambda function an appropriate Name and Description. Select Python 2.7 as the Runtime. Under Code entry type, choose to Upload a .ZIP file Upload your Zip file, making sure you have adjusted the public key for the lambda. For Handler make sure to change it to Signature_Validation_Lambda.lambda_handler Choose to Create A Role if you don’t already have one with basic logging privileges. Give it an appropriate name and choose a policy template, picking basicedgelambda. Finally, click next and then create function. Testing Lambda function is working properly\nAWS’ lambda function can be given sample JSON input to test the function. So what we can do is create data and sign it with Zymkey then convert it to a hex string locally, and then copy these strings as input into the lambda function. If the public key in the lambda function you set up is the complement to your Zymkey, it will validate correctly. Here we will use python to print out the JSON string we need.\n#!/usr/bin/python3 import zymkey import json data = bytearray('hello world~') signature = zymkey.client.sign(data) python_dictionary = {'data': data, 'signature': signature} print(json.dumps(python_dictionary)) Copy the output string, you will need to paste it onto the AWS test inputs. From the AWS Lambda console, select your lambda function and click Test. Paste your JSON string as the input. It should return and print a success message.\nCreating AWS IoT Rule\nThe final step is to create a trigger for the Lambda function. Here we will make a Rule in AWS IoT, so that all data published to pub_key_readings are routed to and trigger your Lambda function.\nFrom your AWS Console, click on the AWS IoT service. On the left hand side, select Rules and then click the blue Create button. Give it an appropriate Name and Description. Using SQL version 2016-03-23 use the following settings: Attribute: * Topic Filter: pub_key_reading Set it to trigger a lambda function, and select the lambda function you created for signature validation.\nSeeing it all in Action\nThe whole data pipeline goes like this:\npython collects data -\u003e zymkey signs data -\u003e python packages data to json -\u003e pycurl publish data to AWS IoT -\u003e AWS IoT rule routs data and triggers lambda -\u003e Lambda validates signature and logs the success/failure.\nIf you’ve tested that data is being published and the lambda function is working properly, it should all work when you run the program to publish data.\nFrom your AWS Console, select CloudWatch. Under Logs you shoud see something like /aws/lambda/Signature_Validation. Check the logs for proper validation, if you have no logs chances are your AWS IoT rule is not routing the data properly. If data is being published and no logs appear, check your rule is configured properly.\n","categories":"","description":"","excerpt":"Introduction While all Zymbit modules make it trivial to verify data …","ref":"/tutorials/aws-iot/verify-sigs/","tags":"","title":"How to Verify Signatures against Public Key on AWS and Other Devices"},{"body":"How to generate a client certificate for your Zymkey, register your own CA, and establish a TLS connection to AWS IoT to publish data. Overview The following post will show you how to create and register a Zymkey Client Certificate for devices connecting to AWS IoT, as well as how to publish data to AWS IoT using Zymkey. This will allow you to connect a client device to AWS IoT using the private key stored in a Zymkey hardware security module, which is inherently a more secure client certification and authentication method.\nIf you have a large number of client devices to connect to AWS IoT, consider using the more automated Just In Time Registration Process using Zymkey. More details.\nAWS IoT uses a certificate based system for its TLS client authentication. This means that any attempted connection to the AWS IoT servers such as when pulling/publishing data, which is done through TLS/HTTPS, requires the client to present a valid client certificate as well as a valid certificate authority certificate. Furthermore the client must be able to prove that they have the private key associated with the provided certificate. Client Certificates are considered valid if they are registered with Amazon.\nIn this example we will be using AWS IoT’s BYOC (Bring Your Own Certicate) system to create a certificate based on Zymkey’s private key and register it with Amazon. The Zymkey certificate can be signed by either the AWS IoT root certificate authority or your own certificate authority. Both methods will be covered here. Once the setup is complete, you will be able to work with AWS IoT using their REST API, authenticating with Zymkey’s private key.\nClassic client TLS authentication requires the user to keep their private key stored in a file, such as in a file called zymkey.key, and the key is read by whatever client is establishing the TLS connection so that it can be used to prove that you own the key.\nWith Zymkey, authentication is done by a key that cannot be read/exported and that isn’t kept on the file system. The key is always stored in the Zymkey hardware.\nLastly, we will show you how to test your setup. This is done with CURL to make HTTPS requests to the MQTT port 8443.\nPrerequisites Notice The following procedure was done with Raspberry PI OS Buster 32bit. The current version of cURL included in bullseye (7.74.0) seems to have an issue using the openssl engine import feature. Install the necessary software packages and insure the Zymkey is bound to its host using the Getting Started Guide.\nHave a registered AWS Account, a free developer account can be made here.\nProcess Overview Create a Certificate Signing Request (CSR) with Zymkey private key Sign CSR with a Certificate Authority to get a Zymkey Device Certificate If using your own Certificate Authority, register it with AWS Register the Zymkey Device Certificate with AWS Test a TLS connection using your Zymkey Device Certificate and Private Key Attach a policy to the Zymkey Device Certificate to allow it to publish data to AWS IoT Publish data to AWS IoT over TLS using Zymkey Device Certificate for authentication Manual vs. Programmatic Setup Details All AWS settings can be configured either manually through the AWS web interface or programatically through AWS’ boto 3 module in Python. If you would like to use scripts to programatically set up your client certificate, you will need to do the following steps.\nFirst, follow these instructions on the boto3 page to set up the boto3 module for Python: http://boto3.readthedocs.io/en/latest/guide/quickstart.html\nThe boto3 module authenticates with AWS based on a IAM Access ID and Secret Key. The boto3 tutorial will ask you to setup an IAM user, here are some instructions on how to do so:\nFrom the AWS console, choose the IAM service. Go to Users and select Add User Choose a username and check the Programmatic access box For simplicity, choose Attach existing policies directly and select AdministratorAccess If you wish to better manage your IAM credentials, feel free to customize your Access Policy. Click Review and then Create User Save the Access ID and Secret Key and follow the boto3 guide. Creating a Certificate Signing Request with Zymkey Bring Your Own device Certificate (BYOC)\nThe first step is to create a valid device certificate using Zymkey’s private key. This can be done by first creating a Certificate Signing Request using OpenSSL:\nopenssl req -key nonzymkey.key -new -out zymkey.csr -engine zymkey_ssl -keyform e -subj \"/C=US/ST=California/L=Santa Barbara/O=Zymbit/OU=Zymkey/CN=rpi.edge.zymbit.com\" The file nonzymkey.key is a placeholder argument and is not actually a real file or used since Zymkey’s private key can not be exported nor read. A CSR file zymkey.csr is created in the directory where this command is run. The -subj argument automatically inserts certificate information, but you can leave this argument out and will be prompted to input your own information. Your CSR now needs to be signed by a valid Certificate Authority.\nRegistering a Certificate Authority Now that you have created a CSR with Zymkey, you have two options for Certificate Authorities.\nOption A - Using the AWS IoT Root Certificate Authority (Easiest) Details Signing CSR with AWS’ Certificate Authority Using AWS’ Certificate Authority is the easier option in terms of setup and allows you to use a trustworthy Certificate Authority that Amazon uses its services. The following steps show you how to sign your Zymkey’s private key with Amazon’s CA and get a valid device certificate:\nManually:\nSign into your AWS console. Here is a link to the console sign-in page: https://aws.amazon.com/console/ From the console, select the AWS IoT Core service Under the secure tab, click on Certificates and click the blue Create a certificate bar Choose the Create with CSR option When the File Selection menu pops up point to your CSR file. It shoud be zymkey.csr by default. Choose Upload file. We created this file on your IoT device, you may need to transfer it to where your logged into AWS. Download the Certificate file on the next screen and save as zymkey.crt. If you are not logged into AWS from your IoT device, transfer the file to your IoT device. We will use this later. You also need to download the root CA for AWS IoT, by clicking Download. On the page that opens, scroll down to the section CA certificates for server authentication, click ECC 256 bit key and click on the adjacent link Amazon Root CA 3. Copy the public key into a file named AWS_CA.pem file. If you are not logged into AWS from your IoT device, transfer AWS_CA.pem to your IoT device. We will use this later. Return to the Create Certificate AWS IoT page and click Activate Programatically: Using the boto3 client, this python script will read the csr file zymkey.csr, give it to AWS to sign with their Certificate Authority, and create a signed certificate zymkey.crt in the directory where this program is run. Furthermore the certificate will be automatically registered and activated with AWS IoT and will be ready for use.\nimport boto3 iot_client = boto3.client('iot') with open('zymkey.csr', 'r') as zymkey_csr_file: zymkey_csr = zymkey_csr_file.read() zymkey_cert = iot_client.create_certificate_from_csr( certificateSigningRequest=zymkey_csr, setAsActive=True ) with open('zymkey.crt', 'w') as zymkey_cert_file: zymkey_cert_file.write(zymkey_cert['certificatePem']) Save the above script into a file called aws_sign_csr.py and run with the following command:\npython aws_sign_csr.py Now that your Certificate has been signed and activated by AWS IoT, it can be used to establish a TLS connection with the AWS IoT servers. Skip down to Testing the TLS Connection section to continue.\nOption B - Using your own Certificate Authority Details AWS IoT also allows you do you use own Certificate Authority as long as you register it with them. This constitutes proving you own the private key to the CA by signing a verification CSR that includes a registration code.\nIf you already have a Certificate Authority that you would like to use, you can ignore the next part. Here we create an example Certificate Authority using OpenSSL.\nCreating an example CA with OpenSSL #!/bin/bash set -e mkdir CA_files cd CA_files openssl ecparam -genkey -name prime256v1 -out zk_ca.key OPENSSL_CONF=/etc/ssl/openssl.cnf openssl req \\ -x509 -new -SHA256 -nodes -key zk_ca.key \\ -days 3650 -out zk_ca.crt \\ -subj \"/C=US/ST=California/L=Santa Barbara/O=Zymkey/CN=zymkey-verify.zymbit.com.dev\" cp zk_ca.crt zk_ca.pem Copy the above lines into a script called mk_ca.sh. You can then run the script in the command line by being in the same directory with the following command:\nbash mk_ca.sh The script will create a directory called CA_files and a couple of files:\nzk_ca.key: Private key for the created CA, will be supplied to OpenSSL for signing CSRs.\nzk_ca.pem: PEM formatted certificate for the CA\nzk_ca.crt: Same file as zk_ca.pem\nSigning CSR with Certificate Authority Next we will be signing the Zymkey CSR with your chosen Certificate Authority.\n#!/bin/bash set -e SCRIPT_NAME=$(basename $0) [ -z $2 ] \u0026\u0026 echo \"${SCRIPT_NAME} \u003ccsr filename\u003e \u003ccrt filename\u003e\" 1\u003e\u00262 \u0026\u0026 exit 1 csr=$1 crt=$2 openssl x509 -req -SHA256 -days 3650 \\ -CA CA_files/zk_ca.crt -CAkey CA_files/zk_ca.key -CAcreateserial \\ -in ${csr} -out ${crt} Copy the above lines into a script called sign_csr.sh. The first argument is the relative or absolute path of your csr file, such as zymkey.csr. The second argument is what you want to name the certificate file of the signed cert. Change the -CA and -CAkey file path, can be relative or absolute, if you are using your own CA. You can then run the script in the command line by being in the same directory with the following command:\nbash sign_csr.sh zymkey.csr zymkey.crt Registering Your Certificate Authority with AWS You now have a valid certificate, zymkey.crt signed by the Certificate Authority of your choice. If you are using your own Certificate Authority, you have to register your Certificate Authority with Amazon’s IoT service so that AWS IoT will accept certificates signed by that Certificate Authority.\nManually:\nFrom the AWS IoT console select Secure, then click CAs and then click Register\nClick Register CA\nFollow Steps 1 through 3 on the next screen to create a verification certificate.\nWhen signing the verification certificate with your CA in Step 4 run the following command:\nopenssl x509 -req -in verificationCert.csr -CA CA_files/zk_ca.pem -CAkey CA_files/zk_ca.key -CAcreateserial -out verificationCert.crt -days 500 -sha256 Note that if you use a different CA and not the demo one we generated, change the -CA and -CAkey paths appropriately.\nStep 5: click Select CA certificate and point to the correct .pem file. If you use the OpenSSL generated SSL point to CA_files/zk_ca.pem\nStep 6: click Select verification certificate and point to verificationCert.crt which was created in Step 4.\nSelect Activate CA certificate and Enable auto-registration of device certificates\nClick Register CA certificate button.\nProgramatically:\nThe following python script will automatically create a verification cert with a registration code and automatically activate your Certificate Authority. While it may look a bit intimidating, all you have to worry about is the very last line, where you can change to point to your CA files.\nimport OpenSSL import boto3 import os def gen_AWS_verification_csr(registrationCode): key = OpenSSL.crypto.PKey() key.generate_key(OpenSSL.crypto.TYPE_RSA, 2048) req = OpenSSL.crypto.X509Req() req.get_subject().CN = registrationCode req.set_pubkey(key) req.sign(key, \"sha256\")\treturn OpenSSL.crypto.dump_certificate_request(OpenSSL.crypto.FILETYPE_PEM, req) def sign_CSR_with_CA(verification_csr, CA_cert_path, CA_key_path): ca_cert = OpenSSL.crypto.load_certificate(OpenSSL.crypto.FILETYPE_PEM, open(CA_cert_path).read()) ca_key = OpenSSL.crypto.load_privatekey(OpenSSL.crypto.FILETYPE_PEM, open(CA_key_path).read()) req = OpenSSL.crypto.load_certificate_request(OpenSSL.crypto.FILETYPE_PEM, verification_csr) cert = OpenSSL.crypto.X509() cert.set_subject(req.get_subject()) cert.set_serial_number(1) cert.gmtime_adj_notBefore(0) cert.gmtime_adj_notAfter(24 * 60 * 60) cert.set_issuer(ca_cert.get_subject()) cert.set_pubkey(req.get_pubkey()) cert.sign(ca_key, \"sha256\") return OpenSSL.crypto.dump_certificate(OpenSSL.crypto.FILETYPE_PEM, cert) def register_CA_AWS(CA_cert_path, CA_key_path): client = boto3.client('iot') response = client.get_registration_code() registration_key = response['registrationCode'] verification_pem = gen_AWS_verification_csr(registrationCode=registration_key) verification_cert = sign_CSR_with_CA(verification_csr=verification_pem, CA_cert_path=CA_cert_path, CA_key_path=CA_key_path) response = client.register_ca_certificate( caCertificate=open(CA_cert_path).read(), verificationCertificate=verification_cert, setAsActive=True, allowAutoRegistration=True ) return response register_CA_AWS(CA_cert_path='CA_files/zk_ca.crt', CA_key_path='CA_files/zk_ca.key')\tCopy the above lines into a file called activate_aws_ca.py and run with the following command:\npython activate_aws_ca.py Registering a Device Certificate signed by Certificate Authority Now that your Certificate Authority has been registered with AWS IoT, all that is left to do is to register and activate your Zymbit device certificate.\nDetails Manually:\nFrom the AWS IoT Console click Secure, then Certificates and then click the blue Create button Under Use My Certificate click the Get Started button If you registered your own CA, choose the CA you registered on the Select a CA screen, then click Next Click Select certificates and navigate to the certificate that was signed by your CA. Its default name is zymkey.crt Make sure to check the Activate all circle on the certificate box, and finally click the blue Register certificates button. Programatically:\nThe same thing can be done in Python. Just change the last line to point to your CA_Path and Cert_Path, the paths can be either relative or absolute. For example if the two certificate files: zk_ca.crt and zymkey.crt are in the same directory as the Python script, you don’t have to change anything from the following:\nimport boto3 import OpenSSL def activate_cert_AWS(CA_path, Cert_path): boto3client = boto3.client('iot') with open(CA_path) as CA_file: CA_Pem = CA_file.read() with open(Cert_path) as Cert_file: Cert_Pem = Cert_file.read() return boto3client.register_certificate( certificatePem=Cert_Pem, caCertificatePem=CA_Pem, setAsActive=True, ) activate_cert_AWS(CA_path='CA_files/zk_ca.crt', Cert_path='zymkey.crt') Copy the above lines into a file called activate_aws_cert.py and run with the following command: Change the CA_Path and Cert_path if necessary.\npython activate_aws_cert.py Testing TLS connection with Zymkey Device Certificate: You can now test that your certificate zymkey.crt has been registered correctly by testing a TLS connection with your AWS IoT endpoint. We will be doing this with CURL.\nDetails The first thing to do is to look for your AWS endpoint:\nFrom the AWS IoT console screen, click on Settings in the left hand bar.\nIn the Device data endpoint section, copy the Endpoint.\nReplace endpoint.iot.region.amazonaws.com with the Endpoint you just copied in the following command. Now run the command, making sure to do it in the same directory where you keep your signed certificate, zymkey.crt and your CA cert/pem file, AWS_CA.pem, or CA_files/zk_ca.pem:\n#replace endpoint iot region with the copied endpoint curl --tlsv1.2 --cacert AWS_CA.pem --cert zymkey.crt --key nonzymkey.key --engine zymkey_ssl --key-type ENG -v -X POST -d \"{ \\\"hello\\\": \\\"world\\\"}\" \"https://endpoint.iot.region.amazonaws.com:8443/topics/hello/world\" Optionally, you can set an environment variable specifying the slot to use. For the HSM6, you will need to specify the variable prior to running the curl command:\nexport ZK_SSL_SLOT=0 You should see a successful TLS connection, but receive a 403 Forbidden Exception from AWS. This is because the certificate you registered, zymkey.crt doesn’t have the appropriate permissions to publish a message to the topic hello/world. We can fix this by adding a policy and attaching it to the certificate.\nHere’s what the successful TLS connection looks like:\nHere’s the 403 exception you should receive:\nAttaching Policy to Certificate and Publishing to AWS IoT Details Here we will attach a Policy to your Zymkey certificate that allows it to publish data to any topic on AWS IoT.\nFrom the AWS IoT console click on Secure and then Policies. Click the blue Create a policy button.\nGive your Policy an appropriate name.\nUnder Action, write the following:\niot:Connect, iot:Publish For Resource ARN write:\n* Check the Allow box, and click Create\nNow, click the Certificates tab on the left and click on the … option on the top right corner of your certificate. Select Attach Policy\nAttach the appropriate policy and you are done.\nPublishing data to AWS IoT Details Now the previous command should work and {“hello”: “world”} should be published to the hello/world topic on your AWS IoT endpoint.\nOn the AWS IoT console and the left hand bar, click on the Test option, and then the MQTT test client option.\nIn the Subscribe to a topic tab, in the Subscription topic box, type in hello/world. Click the Subscribe button\nTest your TLS connection with the following CURL command pointing to the CA cert/pem file and your Zymkey certificate:\n#replace endpoint.iot.region with the appropriate values curl --tlsv1.2 --cacert CA_files/zk_ca.pem --cert zymkey.crt --key nonzymkey.key --engine zymkey_ssl --key-type ENG -v -X POST -d \"{ \\\"hello\\\": \\\"world\\\"}\" \"https://endpoint.iot.region.amazonaws.com:8443/topics/hello/world\" If it works, your command line should have indication of successful TLS connection and “hello”: “world” should show up in your subscribed topic.\n","categories":"","description":"","excerpt":"How to generate a client certificate for your Zymkey, register your …","ref":"/tutorials/aws-iot/tls/","tags":"","title":"AWS IoT - TLS Client Certificate Authentication"},{"body":"Remapping GPIO4 Pin Zymkey4 uses GPIO4 for a ‘handshake signal’ to coordinate communications with the host Pi. There is a logical (software), electrical and mechanical connection with GPIO4. If you need to use an alternative GPIO pin, here are the steps you need to take reconfigure your system:\nSoftware Configuration To remap the GPIO_4 pin used by Zymbit from GPIO4 to GPIO_X:\nLocate the directory ‘/var/lib/zymbit’ Locate the configuration file name ‘zkenv.conf’ - if non exists then create text file ‘zkenv.conf’ Into the file ‘zkenv.conf’ insert the line ZK_GPIO_WAKE_PIN=X, where X is your GPIO pin of choice. ‘In the RaspberryPi file named ‘config.txt’ you will also need to explicity set GPIO_X to an input . (Note that this is the RaspberryPi config file, which is different to the Zymbit conf file) Finish Electrical Configuration Electrically reconnect Zymkey4 pins per the diagram below. Mechanical Configuration Move your Zymkey4 so it does not mechanically or electrically interfere with other devices connected to pins 1 thru 10. ","categories":"","description":"","excerpt":"Remapping GPIO4 Pin Zymkey4 uses GPIO4 for a ‘handshake signal’ to …","ref":"/tutorials/alternative-gpio/","tags":"","title":"Using an Alternative GPIO Pin"},{"body":" Introduction C interface to Zymkey Application Utilities Library.\nThis file contains the C API to the the Zymkey Application Utilities library. This API facilitates writing user space applications which use Zymkey to perform cryptographic operations, such as:\nSigning of payloads using ECDSA. Verification of payloads that were signed using Zymkey. Exporting the public key that matches Zymkey’s private key. “Locking” and “unlocking” data objects. Generating random data Additionally, there are functions for changing the i2c address (i2c units only), setting tap sensitivity and controlling the LED. Typedefs typedef void *zkCTX typedef enum ZK_EC_KEY_TYPEZK_EC_KEY_TYPE Supported key types.\ntypedef enum ZK_RECOVERY_STRATEGYZK_RECOVERY_STRATEGY Supported recovery strategies.\ntypedef enum ZK_ECDH_KDF_TYPEZK_ECDH_KDF_TYPE Supported ECDH key derivation function types.\ntypedef enum ZK_ACCEL_AXIS_TYPEZK_ACCEL_AXIS_TYPE Accelerometer axis enum, used to set tap sensitivity.\ntypedef enum ZK_THRESHOLD_ACTION_TYPEZK_THRESHOLD_ACTION_TYPE Possible actions for threshold monitor functions.\ntypedef struct zkAccelAxisDataTypezkAccelAxisDataType zkGetAccelerometer data output.\nStructs struct zkAccelAxisDataType #include \u003czk_app_utils.h\u003e zkGetAccelerometer data output.\ndouble g the axis reading in units of g-force.\nint tapDirection the direction of the force along the axis which caused a tap event: -1 = negative +1 = positive 0 = did not cause a tap event.\nEnums enum ZK_EC_KEY_TYPE Supported key types.\nenumerator ZK_NISTP256 enumerator ZK_SECP256R1 enumerator ZK_SECP256K1 enumerator ZK_ED25519 enumerator ZK_X25519 enum ZK_RECOVERY_STRATEGY Supported recovery strategies.\nenumerator ZK_NONE enumerator ZK_BIP39 enumerator ZK_SLIP39 enum ZK_ECDH_KDF_TYPE Supported ECDH key derivation function types.\nenumerator ZK_KDF_RFC5869_SHA256 enumerator ZK_KDF_RFC5869_SHA512 enumerator ZK_KDF_PBKDF2_SHA256 enumerator ZK_KDF_PBKDF2_SHA512 enum ZK_ACCEL_AXIS_TYPE Accelerometer axis enum, used to set tap sensitivity.\nenumerator ZK_ACCEL_AXIS_X enumerator ZK_ACCEL_AXIS_Y enumerator ZK_ACCEL_AXIS_Z enumerator ZK_ACCEL_AXIS_ALL enum ZK_THRESHOLD_ACTION_TYPE Possible actions for threshold monitor functions.\nenumerator ZK_ACTION_NONE enumerator ZK_ACTION_SELF_DESTRUCT enumerator ZK_ACTION_SLEEP Functions Zymkey Context int zkOpen ( zkCTX * ctx) Open a Zymkey context.\nParameters ctx — (output) returns a pointer to a Zymkey context.\nReturns 0 for success, less than 0 for failure.\nint zkClose ( zkCTX ctx) Close a Zymkey context.\nParameters ctx — (input) The Zymkey context to close.\nReturns 0 for success, less than 0 for failure.\nRandom Number Generation int zkCreateRandDataFile ( zkCTX ctx, const char * dst_filename, int rdata_sz) Fill a file with random numbers.\nParameters ctx — (input) Zymkey context.\ndst_filename — (input) Absolute path name for the destination file.\nrdata_sz — (input) The number of random bytes to generate.\nReturns 0 for success, less than 0 for failure.\nint zkGetRandBytes ( zkCTX ctx, uint8_t ** rdata, int rdata_sz) Get an array of random bytes.\nParameters ctx — (input) Zymkey context.\nrdata — (input) Pointer to a pointer of bytes.\nrdata_sz — (input) The number of random bytes to generate.\nReturns 0 for success, less than 0 for failure.\nLock Data int zkLockDataF2F ( zkCTX ctx, const char * src_pt_filename, const char * dst_ct_filename, bool use_shared_key) Lock up source (plaintext) data from a file and store the results (ciphertext) in a destination file.\nThis function encrypts and signs a block of plaintext data from a file and stores the result in a destination file.\nParameters ctx — (input) Zymkey context.\nsrc_pt_filename — (input) The absolute path to the file where the source (plaintext) data is located.\ndst_ct_filename — (input) The absolute path to the file where the destination (ciphertext) data should be deposited.\nuse_shared_key — (input) This parameter specifies which key will be used to used to lock the data up. A value of “false” specifies that the Zymkey will use the one-way key whereas “true” specifies that the shared key will be used. Specify “true” for publishing data to another that has the shared key (e.g. Zymbit cloud) and “False” when the data is meant to reside exclusively withing the host computer.\nReturns 0 for success, less than 0 for failure.\nint zkLockDataB2F ( zkCTX ctx, const uint8_t * src_pt, int src_pt_sz, const char * dst_ct_filename, bool use_shared_key) Lock up source (plaintext) data from a byte array and store the results (ciphertext) in a destination file.\nThis function encrypts and signs a block of binary plaintext data and stores the result in a destination file.\nParameters ctx — (input) Zymkey context.\nsrc_pt — (input) Binary plaintext source byte array.\nsrc_pt_sz — (input) Size of plaintext source data.\ndst_ct_filename — (input) The absolute path to the file where the destination (ciphertext) data should be deposited.\nuse_shared_key — (input) Specifies if shared key is to be used. See zkLockDataF2F.\nReturns 0 for success, less than 0 for failure.\nint zkLockDataF2B ( zkCTX ctx, const char * src_pt_filename, uint8_t ** dst_ct, int * dst_ct_sz, bool use_shared_key) Lock up source (plaintext) data from a file and store the results (ciphertext) in a destination byte array.\nThis function encrypts and signs a block of plaintext data from a file and stores the result in a binary byte array.\nParameters ctx — (input) Zymkey context.\nsrc_pt_filename — (input) The absolute path to the file where the source (plaintext) data is located.\ndst_ct — (output) A pointer to a pointer to an array of unsigned bytes created by this function. This pointer must be freed by the application when no longer needed.\ndst_ct_sz — (output) A pointer to an integer which contains the size of the destination array.\nuse_shared_key — (input) Specifies if shared key is to be used. See zkLockDataF2F.\nReturns 0 for success, less than 0 for failure.\nint zkLockDataB2B ( zkCTX ctx, const uint8_t * src_pt, int src_pt_sz, uint8_t ** dst_ct, int * dst_ct_sz, bool use_shared_key) Lock up source (plaintext) data from a byte array and store the results (ciphertext) in a destination byte array.\nThis function encrypts and signs a block of plaintext data and stores the result in a binary byte array.\nParameters ctx — (input) Zymkey context.\nsrc_pt — (input) Binary plaintext source byte array.\nsrc_pt_sz — (input) Size of plaintext source data.\ndst_ct — (output) A pointer to a pointer to an array of unsigned bytes created by this function. This pointer must be freed by the application when no longer needed.\ndst_ct_sz — (output) A pointer to an integer which contains the size of the destination array.\nuse_shared_key — (input) Specifies if shared key is to be used. See zkLockDataF2F.\nReturns 0 for success, less than 0 for failure.\nUnlock Data int zkUnlockDataF2F ( zkCTX ctx, const char * src_ct_filename, const char * dst_pt_filename, bool use_shared_key) Unlock source (ciphertext) data from a file and store the results (plaintext) in a destination file.\nThis function verifies a locked object signature and decrypts the associated ciphertext data.\nParameters ctx — (input) Zymkey context.\nsrc_ct_filename — (input) The absolute path to the file where the source (ciphertext) data is located.\ndst_pt_filename — (input) The absolute path to the file where the destination (plaintext) data should be deposited.\nuse_shared_key — (input) This parameter specifies which key will be used to used to lock the data up. A value of “false” specifies that the Zymkey will use the one-way key whereas “true” specifies that the shared key will be used. Specify “true” for publishing data to another that has the shared key (e.g. Zymbit cloud) and “False” when the data is meant to reside exclusively withing the host computer.\nReturns 0 for success, less than 0 for failure.\nint zkUnlockDataB2F ( zkCTX ctx, const uint8_t * src_ct, int src_ct_sz, const char * dst_pt_filename, bool use_shared_key) Unlock source (ciphertext) data from a byte array and store the results (plaintext) in a destination file.\nThis function verifies a locked object signature and decrypts the associated ciphertext data.\nParameters ctx — (input) Zymkey context.\nsrc_ct — (input) Binary ciphertext source byte array.\nsrc_ct_sz — (input) Size of ciphertext source data.\ndst_pt_filename — (input) The absolute path to the file where the destination (plaintext) data should be deposited.\nuse_shared_key — (input) Specifies if shared key is to be used. See zkLockDataF2F.\nReturns 0 for success, less than 0 for failure.\nint zkUnlockDataF2B ( zkCTX ctx, const char * src_ct_filename, uint8_t ** dst_pt, int * dst_pt_sz, bool use_shared_key) Unlock source (ciphertext) data from a file and store the results (plaintext) in a destination byte array.\nThis function verifies a locked object signature and decrypts the associated ciphertext data.\nParameters ctx — (input) Zymkey context.\nsrc_ct_filename — (input) The absolute path to the file where the source (ciphertext) data is located.\ndst_pt — (output) A pointer to a pointer to an array of unsigned bytes created by this function. This pointer must be freed by the application when no longer needed.\ndst_pt_sz — (output) A pointer to an integer which contains the size of the destination array.\nuse_shared_key — (input) Specifies if shared key is to be used. See zkLockDataF2F.\nReturns 0 for success, less than 0 for failure.\nint zkUnlockDataB2B ( zkCTX ctx, const uint8_t * src_ct, int src_ct_sz, uint8_t ** dst_pt, int * dst_pt_sz, bool use_shared_key) Unlock source (ciphertext) data from a byte array and store the results (plaintext) in a destination byte array.\nThis function verifies a locked object signature and decrypts the associated ciphertext data.\nParameters ctx — (input) Zymkey context.\nsrc_ct — (input) Binary ciphertext source byte array.\nsrc_ct_sz — (input) Size of ciphertext source data.\ndst_pt — (output) A pointer to a pointer to an array of unsigned bytes created by this function. This pointer must be freed by the application when no longer needed.\ndst_pt_sz — (output) A pointer to an integer which contains the size of the destination array.\nuse_shared_key — (input) Specifies if shared key is to be used. See zkLockDataF2F.\nReturns 0 for success, less than 0 for failure.\nECDSA int zkGenECDSASigFromDigest ( zkCTX ctx, const uint8_t * digest, int slot, uint8_t ** sig, int * sig_sz) Generate a signature using the Zymkey’s ECDSA private key.\nParameters ctx — (input) Zymkey context.\ndigest — (input) This parameter contains the digest of the data that will be used to generate the signature.\nslot — (input) The key slot to generate a signature from. This parameter is only valid for Zymkey models 4i and beyond.\nsig — (output) A pointer to a pointer to an array of unsigned bytes which contains the generated signature. This pointer is created by this function and must be freed by the application when no longer needed.\nsig_sz — (output) A pointer to an integer which contains the size of the signature.\nReturns 0 for success, less than 0 for failure.\nint zkGenECDSASigFromDigestWithRecID ( zkCTX ctx, const uint8_t * digest, int slot, uint8_t ** sig, int * sig_sz, uint8_t * recovery_id) Generate a signature using the Zymkey’s ECDSA private key.\nParameters ctx — (input) Zymkey context.\ndigest — (input) This parameter contains the digest of the data that will be used to generate the signature.\nslot — (input) The key slot to generate a signature from. This parameter is only valid for Zymkey models 4i and beyond.\nsig — (output) A pointer to a pointer to an array of unsigned bytes which contains the generated signature. This pointer is created by this function and must be freed by the application when no longer needed.\nsig_sz — (output) A pointer to an integer which contains the size of the signature.\nrecovery_id — (output) Returns recovery id value needed for ethereum key recovery.\nReturns 0 for success, less than 0 for failure.\nint zkVerifyECDSASigFromDigest ( zkCTX ctx, const uint8_t * digest, int pubkey_slot, const uint8_t * sig, int sig_sz) Verify a signature using one of the Zymkey’s public keys.\nVerify a signature using an internal public key from the Zymkey private/public key store.\nParameters ctx — (input) Zymkey context.\ndigest — (input) This parameter contains the digest of the data that will be used to generate the signature.\npubkey_slot — (input) The key slot to generate a signature from. This parameter is only valid for Zymkey models 4i and beyond.\nsig — (input) Array of bytes which contains the signature.\nsig_sz — (input) Size of signature.\nReturns 0 for signature verification failed, 1 for signature verification passed, less than 0 for general failure.\nint zkVerifyECDSASigFromDigestWithForeignKeySlot ( zkCTX ctx, const uint8_t * digest, int pubkey_slot, const uint8_t * sig, int sig_sz) Verify a signature using one of the Zymkey’s foreign public keys.\nVerify a signature using a public key from the Zymkey foreign key store.\nParameters ctx — (input) Zymkey context.\ndigest — (input) This parameter contains the digest of the data that will be used to generate the signature.\npubkey_slot — (input) The key slot to generate a signature from. This parameter is only valid for Zymkey models 4i and beyond.\nsig — (input) Array of bytes which contains the signature.\nsig_sz — (input) Size of signature.\nReturns 0 for signature verification failed, 1 for signature verification passed, less than 0 for general failure.\nECDH and KDF int zkDoRawECDH ( zkCTX ctx, int slot, const uint8_t * peer_pubkey, int peer_pubkey_sz, uint8_t ** pre_master_secret) Perform a raw ECDH operation. (Supported Devices: HSM6, Secure Compute Module).\nPerform an ECDH operation with no Key Derivation Function (KDF). The raw pre-master secret is returned in the response. The peer public key is presented in the call.\nParameters ctx — (input) Zymkey context.\nslot — (input) The key slot to use for the local key. If this parameter is -1, the ephemeral key is used.\npeer_pubkey — (input) The peer public key.\npeer_pubkey_sz — (input) Size of the peer public key.\npre_master_secret — (output) returned pointer to the pre-master secret.\nReturns 0 for success, less than 0 for general failure.\nint zkDoRawECDHWithIntPeerPubkey ( zkCTX ctx, int slot, int peer_pubkey_slot, bool peer_pubkey_slot_is_foreign, uint8_t ** pre_master_secret) Perform a raw ECDH operation. (Supported Devices: HSM6, Secure Compute Module).\nPerform an ECDH operation with no Key Derivation Function (KDF). The raw pre-master secret is returned in the response. The peer public key is referenced from the zymkey internal key store.\nParameters ctx — (input) Zymkey context.\nslot — (input) The key slot to use for the local key. If this parameter is -1, the ephemeral key is used.\npeer_pubkey_slot — (input) The peer public key slot where the peer public key is to be found.\npeer_pubkey_slot_is_foreign — (input) If true, the peer public key slot is found in the foreign public keyring.\npre_master_secret — (output) returned pointer to the pre-master secret.\nReturns 0 for success, less than 0 for general failure.\nint zkDoECDHAndKDF ( zkCTX ctx, ZK_ECDH_KDF_TYPE kdf_type, int slot, const uint8_t * peer_pubkey, int peer_pubkey_sz, const uint8_t * salt, int salt_sz, const uint8_t * info, int info_sz, int num_iterations, int derived_key_sz, uint8_t ** derived_key) Perform an ECDH operation plus Key Derivation Function. (Supported Devices: HSM6, Secure Compute Module).\nPerform an ECDH operation with Key Derivation Function (KDF). The derived key is returned in the response. The peer public key is presented in the call.\nParameters ctx — (input) Zymkey context.\nslot — (input) The key slot to use for the local key. If this parameter is -1, the ephemeral key is used.\npeer_pubkey — (input) The peer public key.\npeer_pubkey_sz — (input) Size of the peer public key.\nsalt — (input) The salt to use for the selected KDF.\nsalt_sz — (input) The salt size. Must be less than or equal to 128 bytes.\ninfo — (input) The info field to use for RFC 5869. Ignored for PBKDF2.\ninfo_sz — (input) The size of the info parameter. Must be less than or equal to 128 bytes.\nnum_iterations — (input) Number of iterations to carry out (PBKDF only).\nderived_key_sz — (input) The desired number of bytes to return for the KDF. For RFC 5869, this value must be less than 8160 bytes (SHA256) or 16320 (SHA512).\nderived_key — (output) returned pointer to the derived key.\nReturns 0 for success, less than 0 for general failure.\nint zkDoECDHAndKDFWithIntPeerPubkey ( zkCTX ctx, ZK_ECDH_KDF_TYPE kdf_type, int slot, int peer_pubkey_slot, bool peer_pubkey_slot_is_foreign, const uint8_t * salt, int salt_sz, const uint8_t * info, int info_sz, int num_iterations, int derived_key_sz, uint8_t ** derived_key) Perform an ECDH operation plus Key Derivation Function. (Supported Devices: HSM6, Secure Compute Module).\nPerform an ECDH operation with Key Derivation Function (KDF). The derived key is returned in the response. The peer public key is referenced from the zymkey internal key store.\nParameters ctx — (input) Zymkey context.\nslot — (input) The key slot to use for the local key. If this parameter is -1, the ephemeral key is used.\npeer_pubkey_slot — (input) The peer public key slot where the peer public key is to be found.\npeer_pubkey_slot_is_foreign — (input) If true, the peer public key slot is found in the foreign public keyring.\nsalt — (input) The salt to use for the selected KDF.\nsalt_sz — (input) The salt size. Must be less than or equal to 128 bytes.\ninfo — (input) The info field to use for RFC 5869. Ignored for PBKDF2.\ninfo_sz — (input) The size of the info parameter. Must be less than or equal to 128 bytes.\nnum_iterations — (input) Number of iterations to carry out (PBKDF only).\nderived_key_sz — (input) The desired number of bytes to return for the KDF. For RFC 5869, this value must be less than 8160 bytes (SHA256) or 16320 (SHA512).\nderived_key — (output) returned pointer to the derived key.\nReturns 0 for success, less than 0 for general failure.\nKey Management int zkSaveECDSAPubKey2File ( zkCTX ctx, const char * filename, int slot) [DEPRECATED] Use zkExportPubKey2File. Store the public key to a host file in PEM format.\nThis function is useful for generating Certificate Signing Requests (CSR).\nParameters ctx — (input) Zymkey context.\nfilename — (input) Filename where PEM formatted public key is to be stored.\nslot — (input) The key slot to retrieve. Only valid for model 4i and above.\nReturns 0 for success, less than 0 for failure.\nint zkExportPubKey2File ( zkCTX ctx, const char * filename, int pubkey_slot, bool slot_is_foreign) Store the public key to a host file in PEM format.\nThis function is useful for generating Certificate Signing Requests (CSR).\nParameters ctx — (input) Zymkey context.\nfilename — (input) Filename where PEM formatted public key is to be stored.\npubkey_slot — (input) The key slot to retrieve. Zymkey and HSM4 have slots 0, 1, and 2.\nslot_is_foreign — (input) If true, designates the pubkey slot to come from the foreign keystore. (Supported Devices: HSM6, Secure Compute Module).\nReturns 0 for success, less than 0 for failure.\nint zkGetECDSAPubKey ( zkCTX ctx, uint8_t ** pk, int * pk_sz, int slot) [DEPRECATED] Use zkExportPubKey. Gets the public key and stores in a byte array created by this function.\nParameters ctx — (input) Zymkey context.\npk — (output) Pointer to a pointer created by this function which contains the public key.\npk_sz — (output) Pointer to an integer which contains the size of the public key.\nslot — (input) The key slot to retrieve. Only valid for model 4i and above.\nReturns 0 for success, less than 0 for failure.\nint zkExportPubKey ( zkCTX ctx, uint8_t ** pk, int * pk_sz, int pubkey_slot, bool slot_is_foreign) Gets the public key and stores in a byte array created by this function.\nParameters ctx — (input) Zymkey context.\npk — (output) Pointer to a pointer created by this function which contains the public key.\npk_sz — (output) Pointer to an integer which contains the size of the public key.\npubkey_slot — (input) The key slot to retrieve. Zymkey and HSM4 have slots 0, 1, and 2.\nslot_is_foreign — (input) If true, designates the pubkey slot to come from the foreign keystore (Supported Devices: HSM6, Secure Compute Module).\nReturns 0 for success, less than 0 for failure.\nint zkGetAllocSlotsList ( zkCTX ctx, bool is_foreign, int * max_num_keys, int ** alloc_key_list, int * alloc_key_list_sz) Get the list of allocated keys (Supported Devices: HSM6, Secure Compute Module).\nThis function returns a list of all allocated key slots.\nParameters ctx — (input) Zymkey context.\nis_foreign — (input) if true, retrieve allocation list of the foreign keys.\nmax_num_keys — (input) retrieves the key pool size.\nalloc_key_list — (output) a pointer to an array of integers provided by this function to the caller.\nalloc_key_list_sz — (output) a pointer to an integer which contains the size of the returned key list.\nReturns 0 if successful, less than 0 for failure.\nint zkStoreForeignPubKey ( zkCTX ctx, ZK_EC_KEY_TYPE pk_type, uint8_t * pk, int pk_sz) Store a new foreign public key in Zymkey. (Supported Devices: HSM6, Secure Compute Module).\nThis function stores a new foreign public key in the Zymkey public key ring. This public key can be used for signature verification in use cases where it is desirable to hide the public key.\nParameters ctx — (input) Zymkey context.\npk_type — (input) The type of the public key.\npk — (input) Pointer to the public key to store.\npk_sz — (input) The public key size.\nReturns allocated slot number in foreign key store, less than 0 for failure.\nint zkDisablePubKeyExport ( zkCTX ctx, int pubkey_slot, bool slot_is_foreign) Prevent a public key from being exported to the host. (Supported Devices: HSM6, Secure Compute Module).\nThis function prevents the public key at the specified slot from being exported to the host using the API zkExportPubKey.\nParameters ctx — (input) Zymkey context.\npubkey_slot — (input) The key slot to disable pubkey export on.\nslot_is_foreign — (input) The slot parameter refers to a slot in the foreign keyring.\nReturns 0 for success, less than 0 for failure.\nint zkGenKeyPair ( zkCTX ctx, ZK_EC_KEY_TYPE type) Generate a new persistent key pair. (Supported Devices: HSM6, Secure Compute Module).\nThis function generates a new key pair of the specified type and store it persistently. This key pair cannot be used as part of the zymkey’s digital wallet operations.\nParameters ctx — (input) Zymkey context.\ntype — (input) The type of key to generate (ZK_EC_KEY_TYPE).\nReturns allocated slot number if successful, less than 0 for failure.\nint zkGenEphemeralKeyPair ( zkCTX ctx, ZK_EC_KEY_TYPE type) Generate an ephemeral key pair. (Supported Devices: HSM6, Secure Compute Module).\nThis function generates an ephemeral key pair of the specified type. Ephemeral key pairs are useful when performing ECDH for time-of-flight encryption. Only one ephemeral key slot is available and is not persistent between reboots.\nParameters ctx — (input) Zymkey context.\ntype — (input) The type of key to generate (ZK_EC_KEY_TYPE).\nReturns 0 if successful, less than 0 for failure.\nint zkRemoveKey ( zkCTX ctx, int slot, bool slot_is_foreign) Remove a key pair or a foreign public key. (Supported Devices: HSM6, Secure Compute Module).\nThis function deletes a key pair or a foreign public key from persistent storage.\nParameters ctx — (input) Zymkey context.\nslot — (input) The slot.\nslot_is_foreign — (input) The slot parameter refers to a slot in the foreign keyring.\nReturns 0 if successful, less than 0 for failure.\nint zkInvalidateEphemeralKey ( zkCTX ctx) Invalidate the ephemeral key. (Supported Devices: HSM6, Secure Compute Module).\nThis function invalidates the ephemeral key.\nParameters ctx — (input) Zymkey context.\nReturns 0 for success, less than 0 for failure.\nDigital Wallet (BIP32/39/44) int zkGenWalletMasterSeedWithBIP39 ( zkCTX ctx, ZK_EC_KEY_TYPE type, const char * variant, const char * wallet_name, const uint8_t * master_generator_key, int master_generator_key_size, const char * passphrase, char ** mnemonic) Generate master seed to start a new blockchain wallet. (Supported Devices: HSM6, Secure Compute Module).\nThis function generates a new blockchain master seed for creating a new wallet.\nParameters ctx — (input) Zymkey context.\ntype — (input) The type of key to generate (ZK_EC_KEY_TYPE).\nvariant — (input) The variant of the key_type to generate. Currently only “cardano” is supported for ed25519.\nwallet_name — (input) An ASCII string which contains the name of the wallet.\nmaster_generator_key — (input) The master generator key used to help generate the master seed. Can be empty string.\nmaster_generator_key_size — (input) The size of the master generator key. If 0, no master generator key is used in the formulation of the master seed.\npassphrase — (input) The passphrase to generate a different BIP39_mnemonic. Can be empty string.\nmnemonic — (output) A pointer to the mnemonic sentence. If NULL, the master seed is generated per BIP32. Otherwise, the master seed is generated per recovery strategy and the mnemonic sentence is returned in this parameter. The string is null terminated and encoded in UTF-8 NFKD from the English dictionary.\nReturns allocated slot number if successful, less than 0 for failure.\nint zkGenWalletMasterSeedWithSLIP39 ( zkCTX ctx, ZK_EC_KEY_TYPE type, const char * variant, const char * wallet_name, const uint8_t * master_generator_key, int master_generator_key_size, int group_count, int group_threshold, int group_iteration_exponent, const char * master_passphrase) Generate master seed to start a new blockchain wallet. (Supported Devices: HSM6, Secure Compute Module).\nThis function opens a session to generate a new blockchain master seed with the ability to recover from SLIP39 shards.\nParameters ctx — (input) Zymkey context.\ntype — (input) The type of key to generate (ZK_EC_KEY_TYPE).\nvariant — (input) The variant of the key_type to generate. Currently only “cardano” is supported for ed25519.\nwallet_name — (input) An ASCII string which contains the name of the wallet.\nmaster_generator_key — (input) The master generator key used to help generate the master seed. Can be empty string.\nmaster_generator_key_size — (input) The size of the master generator key. If 0, no master generator key is used in the formulation of the master seed.\ngroup_count — (input) The total count of groups(shards) to split into.\ngroup_threshold — (input) The count of groups(shards) needed to restore the master seed.\ngroup_iteration_exponent — (input) The iteration of exponent of SLIP39.\nmaster_passphrase — (input) The master passphrase used for slip 39 recovery process.\nReturns 0 if successful on opening a SLIP39 session, less than 0 for failure.\nint zkSetSLIP39GroupInfo ( zkCTX ctx, int group_index, int member_count, int member_threshold) Set the active SLIP39 group and the amount of members needed. (Supported Devices: HSM6, Secure Compute Module).\nThis function configures the active group to generate the number of shards requested for the active group.\nParameters ctx — (input) Zymkey context.\ngroup_index — (input) The index of the group to generate shards from. Index starts at 0.\nmember_count — (input) The total amount of member shards in this group to generate.\nmember_threshold — (input) The number of member shards needed to recreate this group in recovery.\nReturns 0 if successful on configuring the active group, less than 0 for failure.\nint zkAddSLIP39MemberPassword ( zkCTX ctx, const char * passhrase, char ** mnemonic_sentence) Generate a new SLIP39 member shard. (Supported Devices: HSM6, Secure Compute Module).\nThis function generates a new SLIP39 member shard. The shard can optionally have a password attached to it.\nParameters ctx — (input) Zymkey context.\npasshrase — (input) Password for the shard. Can be empty string.\nmnemonic_sentence — (output) The mnemonic sentence of the shard.\nReturns 0 if successful on opening a SLIP39 session, less than 0 for failure.\nint zkCancelSLIP39Session ( zkCTX ctx) Cancels the current active SLIP39 session (Supported Devices: HSM6, Secure Compute Module).\nThis function cancels open active SLIP39 sessions. For both generation and restore SLIP39 sessions.\nParameters ctx — (input) Zymkey context.\nReturns 0 if successful on aborting a SLIP39 session, less than 0 for failure.\nint zkGenOversightWallet ( zkCTX ctx, ZK_EC_KEY_TYPE type, const char * variant, const uint8_t * pub_key, const uint8_t * chain_code, const char * node_addr, const char * wallet_name) Generate master seed to start a new blockchain wallet. (Supported Devices: HSM6, Secure Compute Module).\nThis function generates a new blockchain master seed for creating a new wallet.\nParameters ctx — (input) Zymkey context.\ntype — (input) The type of key to generate (ZK_EC_KEY_TYPE).\npub_key — (input) The public key to create the oversight wallet from. Should come from a hardened node in a node tree.\nchain_code — (input) The chain code of the public key being used to create the oversight wallet.\nnode_addr — (input) The node address index of the public key being used.\nwallet_name — (input) The name of the oversight wallet being created.\nReturns allocated slot number if successful, less than 0 for failure.\nint zkGenWalletChildKey ( zkCTX ctx, int parent_key_slot, uint32_t index, bool is_hardened, bool return_chain_code, uint8_t ** chain_code) Generate child key from a parent key in a blockchain wallet . (Supported Devices: HSM6, Secure Compute Module).\nThis function generates a new child key descendent from a specified parent key in a wallet.\nParameters ctx — (input) Zymkey context.\nparent_key_slot — (input) The parent key slot to base the child key derivation on.\nindex — (input) The index of the child seed. This determines the node address as well as the outcome of the key generation.\nis_hardened — (input) If true, a hardened key is generated.\nreturn_chain_code — (input) If true, returns the chain code of the public key that was just generated. Has to be a hardened node as well.\nchain_code — (output) the chain code of the public key.\nReturns allocated slot number if successful, less than 0 for failure.\nint zkRestoreWalletMasterSeedFromBIP39Mnemonic ( zkCTX ctx, ZK_EC_KEY_TYPE type, const char * variant, const char * wallet_name, const uint8_t * master_generator_key, int master_generator_key_size, const char * BIP39_passphrase, char * BIP39_mnemonic) Restore a master seed from a BIP39 mnemonic and a master generator key. (Supported Devices: HSM6, Secure Compute Module).\nThis function restores a wallet master seed from a supplied BIP39 mnemonic string and a master generator key.\nParameters ctx — (input) Zymkey context.\ntype — (input) The type of key to generate (ZK_KEY_TYPE).\nvariant — (input) The variant of the key_type to generate. Currently only “cardano” is supported for ed25519.\nwallet_name — (input) An ASCII string which contains the name of the wallet.\nmaster_generator_key — (input) The master generator key used to help generate the master seed.\nmaster_generator_key_size — (input) The size of the master generator key. If 0, no master generator key is used in the formulation of the master seed.\nBIP39_passphrase — (input) The passphrase used to generate the BIP39_mnemonic.\nBIP39_mnemonic — (input) The BIP39_mnemonic string, null terminated and UTF-8 NFKD encoded from the BIP39 English dictionary.\nReturns allocated slot number if successful, less than 0 for failure.\nint zkRestoreWalletMasterSeedFromSLIP39 ( zkCTX ctx, ZK_EC_KEY_TYPE type, const char * variant, const char * wallet_name, const uint8_t * master_generator_key, int master_generator_key_size, const char * SLIP39_passphrase) Open a SLIP39 restore master seed session (Supported Devices: HSM6, Secure Compute Module).\nThis function starts a restore SLIP39 session, in order to start feeding shards into.\nParameters ctx — (input) Zymkey context.\ntype — (input) The type of key to generate (ZK_KEY_TYPE).\nvariant — (input) The variant of the key_type to generate. Currently only “cardano” is supported for ed25519.\nwallet_name — (input) An ASCII string which contains the name of the wallet.\nmaster_generator_key — (input) The master generator key used to help generate the master seed.\nmaster_generator_key_size — (input) The size of the master generator key. If 0, no master generator key is used in the formulation of the master seed.\nSLIP39_passphrase — (input) The master passphrase.\nReturns allocated slot number if successful, less than 0 for failure.\nint zkAddRestoreSLIP39Mnemonic ( zkCTX ctx, const char * passphrase, const char * mnemonic_sentence) Feed a SLIP39 shard to restore a master seed (Supported Devices: HSM6, Secure Compute Module).\nThis function will feed a shard to the module until the conditions are met and a master seed is generated.\nParameters ctx — (input) Zymkey context.\npassphrase — (input) The passphrase that was attached to the shard.\nmnemonic_sentence — (input) The twenty-four word sentence mnemonic shard.\nReturns allocated slot number when all shards required are fed in, less than 0 for no change.\nint zkGetWalletNodeAddrFromKeySlot ( zkCTX ctx, int slot, char ** node_addr, char ** wallet_name, int * master_seed_slot) Derive the node address from a key slot number. (Supported Devices: HSM6, Secure Compute Module).\nThis function derives a node address from an input key slot number.\nParameters ctx — (input) Zymkey context.\nslot — (input) A key slot number that is part of a digital wallet.\nnode_addr — (output) A pointer to a pointer which will contain the node address in ASCII.\nwallet_name — (output) A pointer to a pointer which will contain the wallet name in ASCII. If NULL, this parameter will not be retrieved.\nmaster_seed_slot — (output) A pointer to an integer which will contain the master seed key slot. If NULL, this parameter will not be retrieved.\nReturns 0 if successful, less than 0 for failure.\nint zkGetWalletKeySlotFromNodeAddr ( zkCTX ctx, const char * node_addr, const char * wallet_name, int master_seed_slot, int * slot) Derive the slot address from a node address. (Supported Devices: HSM6, Secure Compute Module).\nThis function returns the slot number associated with a given node address.\nParameters ctx — (input) Zymkey context.\nnode_addr — (input) A pointer which contains the node address in ASCII.\nwallet_name — (input) A pointer which contains the wallet name in ASCII, used to identify the wallet identity. If desired, this parameter can be NULL and the master_seed_slot parameter can be specified instead.\nmaster_seed_slot — (input) The master seed slot. Can be used to specify the wallet identity instead of the wallet name.\nslot — (output) A pointer to an integer which contains the associated key slot.\nReturns 0 if successful, less than 0 for failure.\nPerimeter Detect int zkSetPerimeterEventAction ( zkCTX ctx, int channel, uint32_t action_flags) Set perimeter breach action.\nThis function specifies the action to take when a perimeter breach event occurs. The possible actions are any combination of:\nNotify host. Zymkey self-destruct. Parameters channel — (input) The channel (0 or 1) that the action flags will be applied to.\naction_flags — (input) The actions to apply to the perimeter event channel:\nNotify (ZK_PERIMETER_EVENT_ACTION_NOTIFY). Self-destruct (ZK_PERIMETER_EVENT_ACTION_SELF_DESTRUCT). Returns 0 for success, less than 0 for failure.\nint zkSetDigitalPerimeterDetectLPPeriod ( zkCTX ctx, int lp_period) Set the low power period (Supported Devices: HSM6, Secure Compute Module).\nThis function sets low power period on the digital perimeter detect.\nParameters ctx — (input) Zymkey context.\nlp_period — (input) low power period in microseconds.\nReturns 0 if successful, less than 0 for failure.\nint zkSetDigitalPerimeterDetectLPMaxBits ( zkCTX ctx, int max_num_bits) Set the low power max number of bits (Supported Devices: HSM6, Secure Compute Module).\nThis function sets low power max number of bits on the digital perimeter detect.\nParameters ctx — (input) Zymkey context.\nmax_num_bits — (input) max number of bits.\nReturns 0 if successful, less than 0 for failure.\nint zkSetDigitalPerimeterDetectDelays ( zkCTX ctx, int min_delay_ns, int max_delay_ns) Set the delays (Supported Devices: HSM6, Secure Compute Module).\nThis function sets delays on the digital perimeter detect.\nParameters ctx — (input) Zymkey context.\nmin_delay_ns — (input) minimum delay in nanoseconds.\nmax_delay_ns — (input) maximum delay in nanoseconds.\nReturns 0 if successful, less than 0 for failure.\nint zkWaitForPerimeterEvent ( zkCTX ctx, uint32_t timeout_ms) Wait for a perimeter breach event to be detected.\nThis function is called in order to wait for a perimeter breach event to occur. This function blocks the calling thread unless called with a timeout of zero. Note that, in order to receive perimeter events, the zymkey must have been configured to notify the host on either or both of the perimeter detect channels via a call to “zkSetPerimeterEventAction”.\nParameters timeout_ms — (input) The maximum amount of time in milliseconds to wait for a perimeter event to arrive.\nReturns 0 for success, less than 0 for failure, -ETIMEDOUT when no perimeter events detected within the specified timeout.\nint zkGetPerimeterDetectInfo ( zkCTX ctx, uint32_t ** timestamps_sec, int * num_timestamps) Get current perimeter detect info.\nThis function gets the timestamp of the first perimeter detect event for the given channel.\nParameters timestamps_sec — (output) The timestamps for when any breach occurred. The index in this array corresponds to the channel number used by zkSetPerimeterEventAction. A 0 value means no breach has occurred on this channel. This array is allocated by this routine and so it must be freed by the caller.\nnum_timestamps — (output) The number of timestamps in the returned array.\nReturns 0 for success, less than 0 for failure.\nint zkClearPerimeterDetectEvents ( zkCTX ctx) Clear perimeter detect events.\nThis function clears all perimeter detect event info and rearms all perimeter detect channels.\nReturns 0 for success, less than 0 for failure.\nLED Control int zkLEDOff ( zkCTX ctx) Turns the LED off.\nParameters ctx — (input) Zymkey context.\nReturns 0 for success, less than 0 for failure.\nint zkLEDOn ( zkCTX ctx) Turns the LED on.\nParameters ctx — (input) Zymkey context.\nReturns 0 for success, less than 0 for failure.\nint zkLEDFlash ( zkCTX ctx, uint32_t on_ms, uint32_t off_ms, uint32_t num_flashes) Flashes the LED.\nParameters ctx — (input) Zymkey context.\non_ms — (input) The amount of time, in milliseconds, that the LED will stay on during a flash cycle.\noff_ms — (input) The amount of time, in milliseconds, that the LED will stay off during a flash cycle.\nnum_flashes — (input) The number of on/off flash cycles to complete. If this parameter is 0, then the LED will flash indefinitely.\nReturns 0 for success, less than 0 for failure.\nAdministrative Ops int zkSetI2CAddr ( zkCTX ctx, int addr) Sets the i2c address of the Zymkey (i2c versions only).\nThis method should be called if the i2c address of the Zymkey is shared with another i2c device on the same i2c bus. The default i2c address for Zymkey units is 0x30. Currently, the address may be set in the ranges of 0x30 - 0x37 and 0x60 - 0x67. After successful completion of this command, the Zymkey will reset itself.\nParameters addr — (input) The i2c address that the Zymkey will set itself to.\nReturns 0 for success, less than 0 for failure.\nTime int zkGetTime ( zkCTX ctx, uint32_t * epoch_time_sec, bool precise_time) Get current GMT time.\nThis function is called to get the time directly from a Zymkey’s Real Time Clock (RTC).\nParameters epoch_time_sec — (output) The time in seconds from the epoch (Jan. 1, 1970).\nprecise_time — (input) If true, this API returns the time after the next second falls. This means that the caller could be blocked up to one second. If false, the API returns immediately with the current time reading.\nReturns 0 for success, less than 0 for failure.\nAccelerometer int zkSetTapSensitivity ( zkCTX ctx, int axis, float pct) Sets the sensitivity of tap operations.\nThis method permits setting the sensitivity of the tap detection feature. Each axis may be individually configured or all at once.\nParameters axis — (input) The axis to configure. This parameter should contain one of the values in the enum typedef ACCEL_AXIS_TYPE.\npct — (input) The sensitivity expressed as percentage.\nReturns 0 for success, less than 0 for failure.\nint zkWaitForTap ( zkCTX ctx, uint32_t timeout_ms) Wait for a tap event to be detected.\nThis function is called in order to wait for a tap event to occur. This function blocks the calling thread unless called with a timeout of zero.\nParameters timeout_ms — (input) The maximum amount of time in milliseconds to wait for a tap event to arrive.\nReturns 0 for success, less than 0 for failure, -ETIMEDOUT when no tap events detected within the specified timeout.\nint zkGetAccelerometerData ( zkCTX ctx, zkAccelAxisDataType * x, zkAccelAxisDataType * y, zkAccelAxisDataType * z) Get current accelerometer data and tap info.\nThis function gets the most recent accelerometer data in units of g forces plus the tap direction per axis.\nParameters x — (output) x axis accelerometer information y (output) y axis accelerometer information z (output) z axis accelerometer information.\nReturns 0 for success, less than 0 for failure.\nBinding Management int zkLockBinding ( zkCTX ctx) Set soft binding lock.\nThis function locks the binding for a specific HSM. This API is only valid for HSM series products.\nReturns 0 for success, less than 0 for failure.\nint zkGetCurrentBindingInfo ( zkCTX ctx, bool * binding_is_locked, bool * is_bound) Get current binding info.\nThis function gets the current binding lock state as well as the current binding state. This API is only valid for devices in the HSM family.\nParameters binding_is_locked — (output) Binary value which expresses the current binding lock state. is_bound (output) Binary value which expresses the current bind state.\nReturns 0 for success, less than 0 for failure.\nModule Info int zkGetModelNumberString ( zkCTX ctx, char ** model_str) Get Zymkey model number.\nThis function retrieves the model number of the zymkey referred to in a specified context.\nParameters ctx — (input) Zymkey context which was created with zkOpen.\nmodel_str — (output) A double pointer to the model string. This function allocates this string. It is the caller’s responsibility to free it.\nReturns 0 for success, less than 0 for failure.\nint zkGetFirmwareVersionString ( zkCTX ctx, char ** fw_ver_str) Get Zymkey firmware version.\nThis function retrieves the firmware version number of the zymkey referred to in a specified context.\nParameters ctx — (input) Zymkey context which was created with zkOpen.\nversion_str — (output) A double pointer to the firmware version string. This function allocates this string. It is the caller’s responsibility to free it.\nReturns 0 for success, less than 0 for failure.\nint zkGetSerialNumberString ( zkCTX ctx, char ** serial_num_str) Get Zymkey serial number.\nThis function retrieves the serial number of the zymkey referred to in a specified context.\nParameters ctx — (input) Zymkey context which was created with zkOpen.\nserial_num_str — (output) A double pointer to the serial number string. This function allocates this string. It is the caller’s responsibility to free it.\nReturns 0 for success, less than 0 for failure.\nint zkGetCPUTemp ( zkCTX ctx, float * cpu_temp) Get current HSM CPU temperature. (Supported Devices: HSM6, Secure Compute Module).\nThis function gets the current HSM CPU temp.\nParameters cpu_temp — (output) The temperature in celsius of the CPU.\nReturns 0 for success, less than 0 for failure.\nint zkGetAUXTemp ( zkCTX ctx, int index, float * aux_temp) Get current AUX temperature. (Only for secure compute modules).\nThis function gets an aux temp. THIS FUNCTION IS FOR INTERNAL ZYMBIT USE ONLY.\nParameters ctx — (input) Zymkey context.\nindex — (input) Index for which aux temp to be polled.\naux_temp — (output) The temperature in celsius.\nReturns 0 for success, less than 0 for failure.\nint zkGetRTCDrift ( zkCTX ctx, float * rtc_drift) Get current RTC drift. (Supported Devices: HSM6, Secure Compute Module).\nThis function is called to get the current RTC drift.\nParameters rtc_drift — (output) The RTC drift.\nReturns 0 for success, less than 0 for failure.\nint zkGetBatteryVoltage ( zkCTX ctx, float * batt_voltage) Get the battery voltage (Supported Devices: HSM6, Secure Compute Module).\nThis function gets the current battery voltage.\nParameters ctx — (input) Zymkey context.\nbattV — (output) The current battery voltage value.\nReturns 0 if successful, less than 0 for failure.\nBattery Voltage Monitor int zkSetBatteryVoltageAction ( zkCTX ctx, int action) Set battery voltage threshold action. (Supported Devices: HSM6, Secure Compute Module).\nThis function specifies the action to take when the battery voltage falls below the threshold set by zkSetBatteryVoltageThreshold. If this function is never called, do nothing is default. There are three actions:\nDo nothing. Go to sleep until battery is replaced. Self-destruct. Parameters action — (input) The action to apply, specify one of the ZK_THRESHOLD_ACTION_TYPE:\nDo nothing (ZK_ACTION_NONE). Sleep (ZK_ACTION_SLEEP). Self-destruct (ZK_ACTION_SELF_DESTRUCT). Returns 0 for success, less than 0 for failure.\nint zkSetBatteryVoltageThreshold ( zkCTX ctx, float threshold) Sets the battery voltage threshold. (Supported Devices: HSM6, Secure Compute Module).\nThis function sets the threshold at which if the battery voltage falls bellow, the action set by zkSetBatteryVoltageAction will be carried out. The recommended threshold is 2.3V. If this function isn’t called 2.3V is assumed by default. Threshold must be below 2.5V.\nParameters threshold — (input) The threshold in Volts.\nReturns 0 for success, less than 0 for failure.\nCPU Temperature Monitor int zkSetCPUTempAction ( zkCTX ctx, int action) Set HSM CPU temperature threshold action. (Supported Devices: HSM6, Secure Compute Module).\nThis function specifies the action to take when the HSM CPU temperature falls below the threshold set by zkSetCPULowTempThreshold, or rises above the threshold set by zkSetCPUHighTempThreshold. There are two actions to apply:\nDo nothing. Self-destruct. Parameters action — (input) The action to apply, used it’s named constant from ZK_THRESHOLD_ACTION_TYPE:\nDo nothing (ZK_ACTION_NONE). Self-destruct (ZK_ACTION_SELF_DESTRUCT). Returns 0 for success, less than 0 for failure.\nint zkSetCPULowTempThreshold ( zkCTX ctx, float threshold) Sets the HSM CPU low temperature threshold. (Supported Devices: HSM6, Secure Compute Module).\nThis function sets the threshold at which if the on-board HSM CPU’s tempreature falls below, the action set by zkSetCPUTempAction will be carried out. WARNING: You can lock yourself out in dev mode if you set a threshold above the CPU’s ambient temperature. The recommended setting is no more than 20C. If no threshold is set, -10 degrees celsius is set as default.\nParameters threshold — (input) The threshold in celsius.\nReturns 0 for success, less than 0 for failure.\nint zkSetCPUHighTempThreshold ( zkCTX ctx, float threshold) Sets the HSM CPU high temperature threshold. (Supported Devices: HSM6, Secure Compute Module).\nThis function sets the threshold at which if the on-board HSM CPU’s tempreature rises above, the action set by zkSetCPUTempAction will be carried out. WARNING: You can lock yourself out in dev mode if you set a threshold below the CPU’s ambient temperature. The recommended setting is no less than 40C. If no threshold is set, 65 degrees celsius is set as default.\nParameters threshold — (input) The threshold in celsius.\nReturns 0 for success, less than 0 for failure.\nint zkSetSupervisedBootPolicy ( zkCTX ctx, int policy_id) Sets the Supervised boot policy. (Supported Devices: Secure Compute Module).\nThis function specifies the action to take when Supervised boot event triggers based on a file change.\nParameters policy_id — (input) The actions to apply to the Supervised boot process:\n0 Do Nothing (ZK_SUPBOOT_FAIL_NO_ACTION). 1 Self-Destruct (ZK_SUPBOOT_FAIL_DESTROY). 2 Hold Chip in Reset (ZK_SUPBOOT_FAIL_HOLD_RESET). Returns 0 for success, less than 0 for failure.\nint zkAddOrUpdateSupervisedBootFile ( zkCTX ctx, const char * file_path, int slot) Update file manifest for Supervised boot to check. (Supported Devices: Secure Compute Module).\nThis function adds or updates files to be checked by Supervised boot.\nParameters file_path — (input) The file to be signed and checked by Supervised boot.\nslot — (input) The slot to sign the file with.\nReturns 0 for success, less than 0 for failure.\nint zkRemoveSupervisedBootFile ( zkCTX ctx, const char * file_path) Remove a file from file manifest for Supervised boot to check. (Supported Devices: Secure Compute Module).\nThis function removes a file to be checked by Supervised boot.\nParameters file_path — (input) The file to be removed from the Supervised boot manifest.\nReturns 0 for success, less than 0 for failure.\nint zkGetSupervisedBootFileManifest ( zkCTX ctx, char ** manifest) Get file manifest for Supervised boot to check. (Supported Devices: Secure Compute Module).\nThis function gets the list of files to be checked by Supervised boot.\nParameters manifest — (output) The file manifest that is checked by Supervised boot.\nReturns 0 for success, less than 0 for failure.\n","categories":"","description":"C interface to Zymkey Application Utilities Library.","excerpt":"C interface to Zymkey Application Utilities Library.","ref":"/api/c_api/","tags":"","title":"C API Documentation"},{"body":" Introduction C++ interface to Zymkey Application Utilities Library.\nThis file contains the C API to the the Zymkey Application Utilities library. This API facilitates writing user space applications which use Zymkey to perform cryptographic operations, such as:\nSigning of payloads using ECDSA. Verification of payloads that were signed using Zymkey. Exporting the public key that matches Zymkey’s private key. “Locking” and “unlocking” data objects. Generating random data Additionally, there are functions for changing the i2c address (i2c units only), setting tap sensitivity and controlling the LED. Typedefs typedef std::vector\u003cuint8_t\u003ebyteArray Typedef for a simple unsigned bytes container.\ntypedef std::vector\u003cint\u003eintArray Typedef for a simple integer container.\nStructs struct accelData #include \u003czkAppUtilsClass.h\u003e Structure typedef used for retrieval of accelerometer data.\ndouble x double y double z int tapDirX int tapDirY int tapDirZ Classes class recoveryStrategyBaseType zkAppUtilsClass.h Class used for retrieval of recovery mnemonic for Bip32 wallet.\nSubclassed by Public Functions recoveryStrategyBaseType ( const std::string \u0026 key_variant = \"\") ~recoveryStrategyBaseType () inline ZK_RECOVERY_STRATEGYgetRecoveryStrategy ()const inline voidsetVariant ( const std::string \u0026 key_variant) inline std::stringgetVariant ()const inline virtual std::stringgetPassPhrase ()const class recoveryStrategyBIP39 zkAppUtilsClass.h Class used for BIP39 recovery strategy. User can set b64 encoded passphrase and key variant (only “cardano” is supported for ed25519 currently) for bip32 seed generation. It can also hold the mnemonic sentence from master seed generation.\nPublic Functions recoveryStrategyBIP39 ( const std::string \u0026 passphrase = \"\", const std::string \u0026 key_variant = \"\") ~recoveryStrategyBIP39 () inline voidsetPassPhrase ( const std::string \u0026 passphrase) inline virtual std::stringgetPassPhrase ()const Private Members std::string passPhrase class recoveryStrategySLIP39 Public Functions recoveryStrategySLIP39 ( int group_count, int group_threshold, int iteration_exponent, const std::string \u0026 passphrase = \"\", const std::string \u0026 key_variant = \"\") ~recoveryStrategySLIP39 () inline voidsetPassPhrase ( const std::string \u0026 passphrase) inline virtual std::stringgetPassPhrase ()const inline voidsetGroupCount ( int group_count) inline intgetGroupCount ()const inline voidsetGroupThreshold ( int group_threshold) inline intgetGroupThreshold ()const inline voidsetIterationExponent ( int iteration_exponent) inline intgetIterationExponent ()const Private Members int groupCount int groupThreshold int iterationExponent std::string passPhrase class zkClass zkAppUtilsClass.h The main class.\nZymkey Context zkClass () Constructor: a Zymkey context is opened.\nExceptions zkAppUtilsException upon error virtual ~zkClass () Destructor: the Zymkey context is closed.\nRandom Number Generation void createRandDataFile ( std::string \u0026 dst_filename, int rdata_sz) Write random data to a file.\nParameters dst_filename — A string containing the absolute path to the file where random data is written.\nrdata_sz — The number of random bytes to generate.\nExceptions zkAppUtilsException upon error :: *getRandBytes ( int rdata_sz) Generate a block of random data.\nParameters rdata_sz — The number of random bytes to generate.\nExceptions zkAppUtilsException upon error Returns A pointer to container with the random bytes.\nLock Data void lockData ( const std::string \u0026 src_pt_filename, const std::string \u0026 dst_ct_filename, bool use_shared_key = false) Locks data from a plaintext source file and stores locked data object to a destination file.\nParameters src_pt_filename — Absolute path to source plaintext file.\ndst_ct_filename — Absolute path to destination file which will contain locked data object.\nuse_shared_key — Determines whether one-way or shared key is used for locking. Default = false.\nExceptions zkAppUtilsException upon error void lockData ( const zkAppUtils::byteArray \u0026 src_pt_data, const std::string \u0026 dst_ct_filename, bool use_shared_key = false) Locks data from a plaintext source byte container and stores locked data object to a destination file.\nParameters src_pt_data — Unsigned byte container which holds source plaintext data.\ndst_ct_filename — Absolute path to destination file which will contain locked data object.\nuse_shared_key — Determines whether one-way or shared key is used for locking. Default = false.\nExceptions zkAppUtilsException upon error :: *lockData ( const std::string \u0026 src_pt_filename, bool use_shared_key = false) Locks data from a plaintext source file and stores locked data object in a container of unsigned bytes.\nParameters src_pt_filename — Absolute path to source plaintext file.\nuse_shared_key — Determines whether one-way or shared key is used for locking. Default = false.\nExceptions zkAppUtilsException upon error Returns Byte container with locked data.\n:: *lockData ( const zkAppUtils::byteArray \u0026 src_pt_data, bool use_shared_key = false) Locks data from a plaintext source byte container and stores locked data object in a container of unsigned bytes.\nParameters src_pt_data — Unsigned byte container which holds source plaintext data.\nuse_shared_key — Determines whether one-way or shared key is used for locking. Default = false.\nExceptions zkAppUtilsException upon error Returns Byte container with locked data.\nUnlock Data void unlockData ( const std::string \u0026 src_ct_filename, const std::string \u0026 dst_pt_filename, bool use_shared_key = false) Unocks a locked data object from source file and stores unlocked data object to a destination file.\nParameters src_ct_filename — Absolute path to source file which contains locked data object.\ndst_pt_filename — Absolute path to destination file which will contain unlocked plaintext data.\nuse_shared_key — Determines whether one-way or shared key is used for locking. Default = false.\nExceptions zkAppUtilsException upon error void unlockData ( const zkAppUtils::byteArray \u0026 src_ct_data, const std::string \u0026 dst_pt_filename, bool use_shared_key = false) Unlocks a locked data object contained in an unsigned byte container and stores plaintext data to a destination file.\nParameters src_ct_data — Unsigned byte container which holds locked data object.\ndst_pt_filename — Absolute path to destination file which will contain unlocked plaintext data.\nuse_shared_key — Determines whether one-way or shared key is used for locking. Default = false.\nExceptions zkAppUtilsException upon error :: *unlockData ( const std::string \u0026 src_ct_filename, bool use_shared_key = false) Unlocks a locked data object from a plaintext source file and stores plaintext data in a container of unsigned bytes.\nParameters src_ct_filename — Absolute path to source file which contains locked data object.\nuse_shared_key — Determines whether one-way or shared key is used for locking. Default = false.\nExceptions zkAppUtilsException upon error Returns Byte container with plaintext data.\n:: *unlockData ( const zkAppUtils::byteArray \u0026 src_ct_bytes, bool use_shared_key = false) Unlocks a locked data object contained in an unsigned byte container and stores plaintext data in a container of unsigned bytes.\nParameters src_ct_data — Unsigned byte container which holds locked data object.\nuse_shared_key — Determines whether one-way or shared key is used for locking. Default = false.\nExceptions zkAppUtilsException upon error Returns Byte container with plaintext data.\nECDSA :: *genECDSASigFromDigest ( zkAppUtils::byteArray \u0026 digest, int slot = 0) Generate a signature from a data digest using the Zymkey’s private key.\nParameters digest — Currently, this should be a SHA256 digest.\nslot — The key slot to use for verification.\nExceptions zkAppUtilsException upon error Returns Byte container with binary signature.\n:: *genECDSASigFromDigest ( zkAppUtils::byteArray \u0026 digest, uint8_t \u0026 recovery_id, int slot = 0) Generate a signature from a data digest using the Zymkey’s private key.\nParameters digest — Currently, this should be a SHA256 digest.\nslot — The key slot to use for verification.\nrecovery_id — [Output]Returns recovery id value needed for ethereum key recovery.\nExceptions zkAppUtilsException upon error Returns Byte container with binary signature.\nbool verifyECDSASigFromDigest ( zkAppUtils::byteArray \u0026 digest, zkAppUtils::byteArray \u0026 sig, int pub_key_slot = 0, bool pub_key_is_foreign = false) Verify a signature from a data digest using the Zymkey’s public key. The public key is not given as an input. Rather, the Zymkey uses its own copy of the private key. This insures that the public key that matches the private key is used.\nParameters digest — Currently, this should be a SHA256 digest.\nsig — The signature to verify.\npub_key_slot — The key slot to use for verification.\npub_key_is_foreign — If false, the normal key store is referenced. Otherwise, the foreign public key store is referenced.\npub_key_is_foreign — If false, the normal key store is referenced. Otherwise, the foreign public key store is referenced.\nReturns true = signature verification passed, false = signature verification failed.\nECDH and KDF :: *doRawECDH ( int slot, zkAppUtils::byteArray \u0026 peer_pubkey) Perform a raw ECDH operation. (Supported Devices: HSM6, Secure Compute Module).\nPerform an ECDH operation with no Key Derivation Function (KDF). The raw pre-master secret is returned in the response. The peer public key is presented in the call.\nParameters slot — The key slot to use for the local key. If this parameter is -1, the ephemeral key is used.\npeer_pubkey — The peer public key.\nReturns Byte container with pre master secret.\n:: *doRawECDHWithIntPeerPubkey ( int slot, int peer_pubkey_slot, bool peer_pubkey_slot_is_foreign) Perform a raw ECDH operation. (Supported Devices: HSM6, Secure Compute Module).\nPerform an ECDH operation with no Key Derivation Function (KDF). The raw pre-master secret is returned in the response. The peer public key is referenced from the zymkey internal key store.\nParameters slot — The key slot to use for the local key. If this parameter is -1, the ephemeral key is used.\npeer_pubkey_slot — The peer public key slot where the peer public key is to be found.\npeer_pubkey_slot_is_foreign — If true, the peer public key slot is found in the foreign public keyring.\nReturns Byte container with pre master secret.\n:: *doECDHAndKDF ( ZK_ECDH_KDF_TYPE kdf_type, int slot, zkAppUtils::byteArray \u0026 peer_pubkey, zkAppUtils::byteArray \u0026 salt, zkAppUtils::byteArray \u0026 info, int num_iterations, int derived_key_sz) Perform an ECDH operation plus Key Derivation Function. (Supported Devices: HSM6, Secure Compute Module).\nPerform an ECDH operation with Key Derivation Function (KDF). The derived key is returned in the response. The peer public key is presented in the call.\nParameters slot — The key slot to use for the local key. If this parameter is -1, the ephemeral key is used.\npeer_pubkey — The peer public key.\nsalt — The salt to use for the selected KDF.\ninfo — The info field to use for RFC 5869. Ignored for PBKDF2.\nnum_iterations — Number of iterations to carry out (PBKDF only).\nderived_key_sz — The desired number of bytes to return for the KDF. For RFC 5869, this value must be less than 8160 bytes (SHA256) or 16320 (SHA512).\nReturns Byte container with pre master secret.\n:: *doECDHAndKDFWithIntPeerPubkey ( ZK_ECDH_KDF_TYPE kdf_type, int slot, int peer_pubkey_slot, bool peer_pubkey_slot_is_foreign, zkAppUtils::byteArray \u0026 salt, zkAppUtils::byteArray \u0026 info, int num_iterations, int derived_key_sz) Perform an ECDH operation plus Key Derivation Function. (Supported Devices: HSM6, Secure Compute Module).\nPerform an ECDH operation with Key Derivation Function (KDF). The derived key is returned in the response. The peer public key is referenced from the zymkey internal key store.\nParameters slot — The key slot to use for the local key. If this parameter is -1, the ephemeral key is used.\npeer_pubkey_slot — The peer public key slot where the peer public key is to be found.\npeer_pubkey_slot_is_foreign — If true, the peer public key slot is found in the foreign public keyring.\nsalt — The salt to use for the selected KDF.\ninfo — The info field to use for RFC 5869. Ignored for PBKDF2.\nnum_iterations — Number of iterations to carry out (PBKDF only).\nderived_key_sz — The desired number of bytes to return for the KDF. For RFC 5869, this value must be less than 8160 bytes (SHA256) or 16320 (SHA512).\nReturns Byte container with pre master secret.\nKey Management void saveECDSAPubKey2File ( std::string dst_filename, int slot = 0) [DEPRECATED] Use exportPubKey2File. Save the public key that matches the Zymkey’s private key into a PEM formatted file. Mainly used for Certificate Signing Request (CSR) generation.\nParameters dst_filename — Absolute location where the PEM formatted file is to be stored.\nslot — Reserved for future use.\nExceptions zkAppUtilsException upon error void exportPubKey2File ( std::string dst_filename, int pubkey_slot = 0, bool slot_is_foreign = false) Store the public key to a host file in PEM format.\nThis function is useful for generating Certificate Signing Requests (CSR).\nParameters dst_filename — Filename where PEM formatted public key is to be stored.\npubkey_slot — The key slot to retrieve. Zymkey and HSM4 have slots 0, 1, and 2.\nslot_is_foreign — If true, designates the pubkey slot to come from the foreign keystore. (Supported Devices: HSM6, Secure Compute Module).\nExceptions zkAppUtilsException upon error :: *getECDSAPubKey ( int slot = 0) [DEPRECATED] Use exportPubKey. Get a container of bytes which contains the ECDSA public key.\nParameters slot — Reserved for future use.\nExceptions zkAppUtilsException upon error Returns Byte container with binary public key.\n:: *exportPubKey ( int pubkey_slot = 0, bool slot_is_foreign = 0) Gets the public key and stores in a byte array created by this function.\nParameters pubkey_slot — The key slot to retrieve. Zymkey and HSM4 have slots 0, 1, and 2.\nslot_is_foreign — If true, designates the pubkey slot to come from the foreign keystore. (Supported Devices: HSM6, Secure Compute Module).\nExceptions zkAppUtilsException upon error * getAllocSlotsList ( bool foreign_key_pool) Get the list of allocated keys. (Supported Devices: HSM6, Secure Compute Module).\nThis function returns a list of all allocated key slots.\nParameters foreign_key_pool — (input) if true, retrieve allocation list of the foreign keys.\nReturns Array of the allocated keys.\nint storeForeignPubKey ( ZK_EC_KEY_TYPE pk_type, zkAppUtils::byteArray \u0026 pk) Store a new foreign public key in Zymkey. (Supported Devices: HSM6, Secure Compute Module).\nThis function stores a new foreign public key in the Zymkey public key ring. This public key can be used for signature verification in use cases where it is desirable to hide the public key.\nParameters pk_type — The type of the public key. {ZK_NISTP256, ZK_SECP256R1 = ZK_NISTP256, ZK_SECP256K1}.\npk — Public key to store.\nExceptions zkAppUtilsException upon error Returns Allocated slot number in foreign key store, less than 0 for failure.\nvoid disablePubKeyExport ( int pubkey_slot, bool slot_is_foreign = false) Prevent a public key from being exported to the host. (Supported Devices: HSM6, Secure Compute Module).\nThis function prevents the public key at the specified slot from being exported to the host using the API zkExportPubKey.\nParameters pubkey_slot — The key slot to disable pubkey export on.\nslot_is_foreign — The slot parameter refers to a slot in the foreign keyring.\nExceptions zkAppUtilsException upon error int genKeyPair ( ZK_EC_KEY_TYPE type) Generate a new persistent key pair. (Supported Devices: HSM6, Secure Compute Module).\nThis function generates a new key pair of the specified type and store it persistently. This key pair cannot be used as part of the zymkey’s digital wallet operations.\nParameters type — The type of key to generate (ZK_EC_KEY_TYPE). {ZK_NISTP256, ZK_SECP256R1 = ZK_NISTP256, ZK_SECP256K1}.\nExceptions zkAppUtilsException upon error Returns Allocated slot number if successful, less than 0 for failure.\nvoid genEphemeralKeyPair ( ZK_EC_KEY_TYPE type) Generate an ephemeral key pair. (Supported Devices: HSM6, Secure Compute Module).\nThis function generates an ephemeral key pair of the specified type. Ephemeral key pairs are useful when performing ECDH for time-of-flight encryption. Only one ephemeral key slot is available and is not persistent between reboots.\nParameters type — The type of key to generate (ZK_EC_KEY_TYPE). {ZK_NISTP256, ZK_SECP256R1 = ZK_NISTP256, ZK_SECP256K1}.\nExceptions zkAppUtilsException upon error void removeKey ( int slot, bool slot_is_foreign = false) Remove a key pair or a foreign public key. (Supported Devices: HSM6, Secure Compute Module).\nThis function deletes a key pair or a foreign public key from persistent storage.\nParameters slot — The slot.\nslot_is_foreign — The slot parameter refers to a slot in the foreign keyring.\nExceptions zkAppUtilsException upon error void invalidateEphemeralKey () Invalidate the ephemeral key. (Supported Devices: HSM6, Secure Compute Module).\nThis function invalidates the ephemeral key.\nExceptions zkAppUtilsException upon error Digital Wallet (BIP32/39/44) int genWalletMasterSeed ( ZK_EC_KEY_TYPE type, std::string \u0026 wallet_name, const zkAppUtils::recoveryStrategyBaseType \u0026 recovery_strategy zkAppUtils::recoveryStrategyBaseType = , const zkAppUtils::byteArray \u0026 master_generator_key zkAppUtils::byteArray = ) Generate a BIP32 master seed to start a new blockchain wallet. (Supported Devices: HSM6, Secure Compute Module).\nThis function generates a new blockchain master seed for creating a new wallet per BIP32.\nParameters type — The type of key to generate (ZK_EC_KEY_TYPE). {ZK_NISTP256, ZK_SECP256R1 = ZK_NISTP256, ZK_SECP256K1, ZK_ED25519, ZK_X25519}.\nwallet_name — An ASCII string which contains the name of the wallet.\nmnemonics(output) — Allocated mnemonics if it was asked for, based on recovery strategy used.\nmaster_generator_key — The master generator key used to help generate the master seed (bip32). Defaults to empty string.\nrecovery_strategy — The recovery strategy object for returning BIP39 or SLIP39 (starts a SLIP39 session instead of a one shot). Also contains key variants and passphrases. Defaults to no recovery strategy.\nReturns The slot the master seed was allocated to.\nint genWalletMasterSeed ( ZK_EC_KEY_TYPE type, std::string \u0026 wallet_name, const zkAppUtils::recoveryStrategyBIP39 \u0026 recovery_strategy, std::string * mnemonic_str, const zkAppUtils::byteArray \u0026 master_generator_key zkAppUtils::byteArray = ) int genWalletMasterSeed ( ZK_EC_KEY_TYPE type, std::string \u0026 wallet_name, const zkAppUtils::recoveryStrategySLIP39 \u0026 recovery_strategy, const zkAppUtils::byteArray \u0026 master_generator_key zkAppUtils::byteArray = ) int setGenSLIP39GroupInfo ( int group_index, int member_count, int member_threshold) Set the active SLIP39 group and the amount of members needed. (Supported Devices: HSM6, Secure Compute Module).\nThis function configures the active group to generate the number of shards requested for the active group.\nParameters group_index — The index of the group to generate shards from. Index starts at 0.\nmember_count — The total amount of member shards in this group to generate.\nmember_threshold — The number of member shards needed to recreate this group in recovery.\nReturns 0 if successful on configuring the active group, less than 0 for failure.\nint addGenSLIP39Member ( std::string passphrase, std::string * mnemonic_str) Generate a new SLIP39 member shard. (Supported Devices: HSM6, Secure Compute Module).\nThis function generates a new SLIP39 member shard. The shard can optionally have a password attached to it.\nParameters passphrase — Password for the shard. Can be empty string.\nmnemonic_str — (output) The mnemonic sentence of the shard.\nReturns 0 if successful on configuring the active group, less than 0 for failure.\nint cancelSLIP39Session () Cancels the current active SLIP39 session (Supported Devices: HSM6, Secure Compute Module).\nThis function cancels open active SLIP39 sessions. For both generation and restore SLIP39 sessions.\nReturns 0 if successful on configuring the active group, less than 0 for failure.\nint genOverSightWallet ( ZK_EC_KEY_TYPE type, zkAppUtils::byteArray \u0026 public_key, zkAppUtils::byteArray \u0026 chain_code, std::string \u0026 node_address, std::string \u0026 wallet_name, std::string \u0026 variant) Generate a oversight wallet from the last hardened node of a wallet node address (Supported Devices: HSM6, Secure Compute Module).\nThis function generates a new oversight wallet and are used to generate public keys in a deterministic way.\nParameters type — The type of key to generate (ZK_EC_KEY_TYPE). {ZK_NISTP256, ZK_SECP256R1 = ZK_NISTP256, ZK_SECP256K1, ZK_ED25519, ZK_X25519}.\npublic_key — The public_key of the last hardened node of the address.\nchain_code — The chain_code of the last hardened node of the address.\nnode_address — The node_address being derived from.\nwallet_name — An ASCII string which contains the name of the wallet.\nvariant — The key type variant to generate. Currently only “cardano” for ed25519 is supported.\nReturns The slot the oversight wallet was allocated to.\nint genWalletChildKey ( int parent_key_slot, uint32_t index, bool is_hardened, bool return_chain_code, zkAppUtils::byteArray * chain_code) Generate child key from a parent key in a wallet (Supported Devices: HSM6, Secure Compute Module).\nThis function generates a new child key descendent from a specified parent key in a wallet.\nParameters parent_key_slot — The parent key slot to base the child key derivation on.\nindex — The index of the child seed. This determines the node address as well as the outcome of the key generation.\nis_hardened — If true, a hardened key is generated.\nreturn_chain_code — If true, exports the chain code. Must be exported from a hardened node.\n(output) — Allocated chain_code if it was asked for.\nExceptions zkAppUtilsException upon error Returns Allocated slot number if successful, less than 0 for failure.\nint restoreWalletMasterSeedFromMnemonic ( ZK_EC_KEY_TYPE type, std::string \u0026 wallet_name, zkAppUtils::byteArray \u0026 master_generator_key, zkAppUtils::recoveryStrategyBIP39 \u0026 recovery_strategy, std::string \u0026 mnemonic_str) Restore a master seed from a BIP39 mnemonic and a master generator key. (Supported Devices: HSM6, Secure Compute Module).\nThis function restores a wallet master seed from a supplied BIP39 mnemonic string and a master generator key.\nParameters type — The type of key to generate (ZK_KEY_TYPE). {ZK_NISTP256, ZK_SECP256R1 = ZK_NISTP256, ZK_SECP256K1}.\nwallet_name — An ASCII string which contains the name of the wallet.\nmaster_generator_key — The master generator key used to help generate the master seed.\nrecovery_strategy — The recovery strategy used. Contains the passphrases and key variant to recover from.\nmnemonic_str — The mnemonic sentence to recover the master seed with. (Not used for SLIP39).\nExceptions zkAppUtilsException upon error Returns Allocated slot number if successful, less than 0 for failure.\nint restoreWalletMasterSeedFromMnemonic ( ZK_EC_KEY_TYPE type, std::string \u0026 wallet_name, zkAppUtils::byteArray \u0026 master_generator_key, zkAppUtils::recoveryStrategySLIP39 \u0026 recovery_strategy) int addRestoreSLIP39Mnemonic ( std::string passphrase, std::string mnemonic_sentence) Feed a SLIP39 shard to restore a master seed (Supported Devices: HSM6, Secure Compute Module).\nThis function will feed a shard to the module until the conditions are met and a master seed is generated.\nParameters passphrase — The passphrase that was attached to the shard.\nmnemonic_sentence — (output) The twenty-four word sentence mnemonic shard.\nReturns allocated slot number when all shards required are fed in, less than 0 for no change.\nint getWalletNodeAddrFromKeySlot ( int slot, std::string * out_node_addr, std::string * out_wallet_name = NULL) Derive the node address from a key slot number. (Supported Devices: HSM6, Secure Compute Module).\nThis function derives a node address from an input key slot number.\nParameters slot — (input) A key slot number that is part of a digital wallet.\nout_node_addr — (output) A pointer to a string which will contain the node address in ASCII.\nwallet_name — (output) A pointer to a string which will contain the wallet name in ASCII. If NULL, this parameter will not be retrieved.\nExceptions zkAppUtilsException upon error Returns The master seed key slot.\nint getWalletKeySlotFromNodeAddr ( std::string \u0026 node_addr, std::string \u0026 wallet_name, int master_seed_slot) Derive the slot address from a node address. (Supported Devices: HSM6, Secure Compute Module).\nThis function returns the slot number associated with a given node address.\nParameters node_addr — (input) A pointer which contains the node address in ASCII.\nwallet_name — (input) A pointer which contains the wallet name in ASCII, used to identify the wallet identity. If desired, this parameter can be NULL and the master_seed_slot parameter can be specified instead.\nmaster_seed_slot — (input) The master seed slot. Can be used to specify the wallet identity instead of the wallet name.\nExceptions zkAppUtilsException upon error Returns The associated key slot.\nLED Control void ledOff () Turn LED off.\nExceptions zkAppUtilsException upon error void ledOn () Turn LED on.\nExceptions zkAppUtilsException upon error void ledFlash ( uint32_t on_ms, uint32_t off_ms = 0, uint32_t num_flashes = 0) Flash LED a certain number of times.\nParameters on_ms — Number of milliseconds that the LED will be on during a flash cycle.\noff_ms — Number of milliseconds that the LED will be off during a flash cycle.\nnum_flashes — Number of flash cycles to execute. 0 = infinite.\nExceptions zkAppUtilsException upon error Administrative void setI2CAddr ( int addr) Sets the i2c address (i2c versions only). Used in case of i2c bus device address conflict.\nParameters addr — The i2c address to set. Upon successful change, the Zymkey will reset itself. However, if the address is the same as the current setting, the Zymkey will not reset. Valid address ranges are 0x30 - 0x37 and 0x60 - 0x67.\nExceptions zkAppUtilsException upon error Time uint32_t getTime ( bool precise_time = false) Get current GMT time.\nThis method is called to get the time directly from a Zymkey’s Real Time Clock (RTC).\nParameters precise_time — (input) If true, this API returns the time after the next second falls. This means that the caller could be blocked up to one second. If false, the API returns immediately with the current time reading.\nExceptions zkAppUtilsException upon error Returns The time in seconds from the epoch (Jan. 1, 1970).\nAccelerometer void setTapSensitivity ( float pct, ZK_ACCEL_AXIS_TYPE axis = ZK_ACCEL_AXIS_ALL) Sets the sensitivity of the tap detection as a percentage for an individual axis or all axes.\nParameters pct — Sensitivity expressed in percentage. 0% = off, 100% = maximum.\naxis — X, Y, Z or all (default).\nExceptions zkAppUtilsException upon error void waitForTap ( uint32_t timeout_ms) Wait for a tap event to be detected.\nThis function is called in order to wait for a tap event to occur. This function blocks the calling thread unless called with a timeout of zero.\nParameters timeout_ms — (input) The maximum amount of time in milliseconds to wait for a tap event to arrive.\nExceptions zkAppUtilsTimeoutException upon timeout or zkAppUtilsException upon other errors void getAccelerometerData ( zkAppUtils::accelData \u0026 accel_data) Get current accelerometer data and tap info.\nThis function gets the most recent accelerometer data in units of g forces plus the tap direction per axis. Array index 0 = x 1 = y 2 = z.\nParameters accel_data — (output) The current accelerometer data and tap information.\nExceptions zkAppUtilsException upon error Binding Management void lockBinding () Set soft binding lock.\nThis function locks the binding for a specific HSM. This API is only valid for HSM series products.\nExceptions zkAppUtilsException upon error void getCurrentBindingInfo ( bool \u0026 binding_is_locked, bool \u0026 is_bound) Get current binding info.\nThis function gets the current binding lock state as well as the current binding state. This API is only valid for devices in the HSM family.\nParameters binding_is_locked — (output) Binary value which expresses the current binding lock state. is_bound (output) Binary value which expresses the current bind state.\nExceptions zkAppUtilsException upon error Perimeter Detect void setPerimeterEventAction ( int channel, uint32_t action_flags) Set perimeter breach action.\nThis function specifies the action to take when a perimeter breach event occurs. The possible actions are any combination of:\nNotify host. Zymkey self-destruct. Parameters channel — (input) The channel (0 or 1) that the action flags will be applied to.\naction_flags — (input) The actions to apply to the perimeter event channel:\nNotify (ZK_PERIMETER_EVENT_ACTION_NOTIFY). Self-destruct (ZK_PERIMETER_EVENT_ACTION_SELF_DESTRUCT). Exceptions zkAppUtilsException upon error void setDigitalPerimeterDetectLPPeriod ( int lp_period) Set the low power period (Supported Devices: HSM6, Secure Compute Module).\nThis function sets low power period on the digital perimeter detect.\nParameters lp_period — (input) low power period in microseconds.\nExceptions zkAppUtilsException upon error Returns void.\nvoid setDigitalPerimeterDetectLPMaxBits ( int max_num_bits) Set the low power max number of bits (Supported Devices: HSM6, Secure Compute Module).\nThis function sets low power max number of bits on the digital perimeter detect.\nParameters max_num_bits — (input) max number of bits.\nExceptions zkAppUtilsException upon error Returns void.\nvoid setDigitalPerimeterDetectDelays ( int min_delay_ns, int max_delay_ns) Set the delays (Supported Devices: HSM6, Secure Compute Module).\nThis function sets delays on the digital perimeter detect.\nParameters min_delay_ns — (input) minimum delay in nanoseconds.\nmax_delay_ns — (input) maximum delay in nanoseconds.\nExceptions zkAppUtilsException upon error Returns void.\nvoid waitForPerimeterEvent ( uint32_t timeout_ms) Wait for a perimeter breach event to be detected.\nThis function is called in order to wait for a perimeter breach event to occur. This function blocks the calling thread unless called with a timeout of zero. Note that, in order to receive perimeter events, the zymkey must have been configured to notify the host on either or both of the perimeter detect channels via a call to “zkSetPerimeterEventAction”.\nParameters timeout_ms — (input) The maximum amount of time in milliseconds to wait for a perimeter event to arrive.\nExceptions zkAppUtilsException upon error void getPerimeterDetectInfo ( uint32_t ** timestamp_sec, int \u0026 num_timestamps) Get current perimeter detect info.\nThis function gets the timestamp of the first perimeter detect event for the given channel.\nParameters timestamps_sec — (output) The timestamps for when any events occurred. The index in this array corresponds to the channel number used by zkSetPerimeterEventAction. A 0 value means no breach has occurred on this channel. This array is allocated by this routine and so it must be freed by the caller.\nnum_timestamps — (output) The number of timestamps in the returned array.\nExceptions zkAppUtilsException upon error void clearPerimeterDetectEvents () Clear perimeter detect info.\nThis function clears all perimeter detect info and rearms all perimeter detect channels.\nExceptions zkAppUtilsException upon error std::string * getModelNumberString () Get Zymkey model number.\nThis function retrieves the model number of the zymkey referred to in a specified context.\nExceptions zkAppUtilsException upon error Returns A pointer to a string containing the Zymkey model number.\nstd::string * getFirmwareVersionString () Get Zymkey firmware version.\nThis function retrieves the firmware version of the zymkey referred to in a specified context.\nExceptions zkAppUtilsException upon error Returns A pointer to a string containing the Zymkey firmware version.\nstd::string * getSerialNumberString () Get Zymkey serial number.\nThis function retrieves the serial number of the zymkey referred to in a specified context.\nExceptions zkAppUtilsException upon error Returns A pointer to a string containing the Zymkey serial number.\nModule Info float getCPUTemp () Get the CPU Temp. (Supported Devices: HSM6, Secure Compute Module).\nThis function gets the current HSM CPU temp.\nExceptions zkAppUtilsException upon error Returns The CPU temp as a float.\nfloat getAUXTemp ( int index = 0) Get the AUX Temp. (Secure Compute Modules Only).\nThis function gets the current temp of an aux processor. (defaults to 0). THIS FUNCTION IS FOR INTERNAL ZYMBIT USE ONLY.\nExceptions zkAppUtilsException upon error Returns The CPU temp as a float.\nfloat getRTCDrift () Get the RTC drift. (Supported Devices: HSM6, Secure Compute Module).\nThis function gets the current RTC drift.\nExceptions zkAppUtilsException upon error Returns The RTC drift as a float.\nfloat getBatteryVoltage () Get the battery voltage(Supported Devices: HSM6, Secure Compute Module).\nThis function gets the current battery voltage.\nExceptions zkAppUtilsException upon error Returns the battery voltage as a float.\nBattery Voltage Monitor void setBatteryVoltageAction ( ZK_THRESHOLD_ACTION_TYPE action) Set battery voltage threshold action. (Supported Devices: HSM6, Secure Compute Module).\nThis function specifies the action to take when the battery voltage falls below the threshold set by zkSetBatteryVoltageThreshold. If this function is never called, do nothing is default. There are three actions:\nDo nothing. Go to sleep until battery is replaced. Self-destruct. Parameters action — (input) The action to apply, specify one of the ZK_THRESHOLD_ACTION_TYPE:\nDo nothing (ZK_ACTION_NONE). Sleep (ZK_ACTION_SLEEP). Self-destruct (ZK_ACTION_SELF_DESTRUCT). Exceptions zkAppUtilsException upon error void setBatteryVoltageThreshold ( float threshold) Sets the battery voltage threshold. (Supported Devices: HSM6, Secure Compute Module).\nThis function sets the threshold at which if the battery voltage falls bellow, the action set by zkSetBatteryVoltageAction will be carried out. The recommended threshold is 2.3V is assumed by default. Threshold must be below 2.5V.\nParameters threshold — (input) The threshold in Volts.\nExceptions zkAppUtilsException upon error CPU Temperature Monitor void setCPUTempAction ( ZK_THRESHOLD_ACTION_TYPE action) Set HSM CPU temperature threshold action. (Supported Devices: HSM6, Secure Compute Module).\nThis function specifies the action to take when the HSM CPU temperature falls below the threshold set by zkSetCPULowTempThreshold, or rises above the threshold set by zkSetCPUHighTempThreshold. There are two actions to apply:\nDo nothing. Self-destruct. Parameters action — (input) The action to apply, used it’s named constant from ZK_THRESHOLD_ACTION_TYPE:\nDo nothing (ZK_ACTION_NONE). Self-destruct (ZK_ACTION_SELF_DESTRUCT). Exceptions zkAppUtilsException upon error void setCPULowTempThreshold ( float threshold) Sets the HSM CPU low temperature threshold. (Supported Devices: HSM6, Secure Compute Module).\nThis function sets the threshold at which if the on-board HSM CPU’s tempreature falls below, the action set by zkSetCPUTempAction will be carried out. WARNING: You can lock yourself out in dev mode if you set a threshold above the CPU’s ambient temperature. The recommended setting is no more than 20C. If no threshold is set, -10 degrees Celsius is set as default.\nParameters threshold — (input) The threshold in celsius.\nExceptions zkAppUtilsException upon error void setCPUHighTempThreshold ( float threshold) Sets the HSM CPU high temperature threshold. (Supported Devices: HSM6, Secure Compute Module).\nThis function sets the threshold at which if the on-board HSM CPU’s tempreature rises above, the action set by zkSetCPUTempAction will be carried out. WARNING: You can lock yourself out in dev mode if you set a threshold below the CPU’s ambient temperature. The recommended setting is no less than 40C. If no threshold is set, 65 degrees celsius is set as default.\nParameters threshold — (input) The threshold in celsius.\nReturns 0 for success, less than 0 for failure.\nvoid setSupervisedBootPolicy ( int policy_id) Sets the Supervised boot policy. (Supported Devices: Secure Compute Module).\nThis function specifies the action to take when Supervised boot event triggers based on a file change.\nParameters policy_id — (input) The actions to apply to the Supervised boot process:\n0 Do Nothing (ZK_SUPBOOT_FAIL_NO_ACTION). 1 Self-Destruct (ZK_SUPBOOT_FAIL_DESTROY). 2 Hold Chip in Reset (ZK_SUPBOOT_FAIL_HOLD_RESET). Returns 0 for success, less than 0 for failure.\nvoid addOrUpdateSupervisedBootFile ( std::string file_path, int slot = 15) Update file manifest for Supervised boot to check. (Supported Devices: Secure Compute Module).\nThis function adds or updates files to be checked by Supervised boot.\nParameters file_path — (input) The file to be signed and checked by Supervised boot.\nslot — (input) The slot to sign the file with. Defaults to 15, if no slot 15, defaults to 0.\nReturns 0 for success, less than 0 for failure.\nvoid removeSupervisedBootFile ( std::string file_path) Remove a file from file manifest for Supervised boot to check. (Supported Devices: Secure Compute Module).\nThis function removes a file to be checked by Supervised boot.\nParameters file_path — (input) The file to be removed from the Supervised boot manifest.\nReturns 0 for success, less than 0 for failure.\nstd::string * getSupervisedBootFileManifest () Get file manifest for Supervised boot to check. (Supported Devices: Secure Compute Module).\nThis function gets the list of files to be checked by Supervised boot.\nParameters manifest — (output) The file manifest that is checked by Supervised boot.\nReturns a string for the list of files in the manifest.\nPrivate Members zkCTX zkContext ","categories":"","description":"C++ interface to Zymkey Application Utilities Library.","excerpt":"C++ interface to Zymkey Application Utilities Library.","ref":"/api/cpp_api/","tags":"","title":"C++ API Documentation"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/","tags":"","title":"Categories"},{"body":"OVERVIEW ZYMKEY and HSM security modules feature two independent perimeter circuits that can be configured to detect physical tamper intrusion events.\nElectrical Requirements Each perimeter loop should be connected with a 30 AWG wire or thicker and nominal length of 2 feet. For longer lengths contact Zymbit. The wire should be electrically insulated for all applications. A shielded cable may be necessary for electrically noisy or industrial applications.\nPhysical Circuit Connections How these circuits are configured physically will vary depending upon the specific application, enclosure and security needs. Standard wires, custom flex PCBs and rigid PCBs may all be used to complete a perimeter loop circuit.\nHere we share some practical examples of how to configure perimeter detect circuits for different applications and equipment.\nTo learn about software configuration and use of perimeter detect functions Learn more\u003e\nCONFIGURATION EXAMPLES Direct Connect to HSM4 Hat HSM4 HAT provides four pin header and FPC connectors to interface to perimeter circuits 1 and 2. This is convenient for rapid prototyping and small scale production situations. For high volume applications, different connector types are available - contact zymbit for more details.\nPerimeter HDR (Header) Pinout Perimeter FPC (Flexible Printed Circuit) Pinout HSM Direct Connector - Hirose Header DF40HC(3.5)-30DS-0.4V(51) Direct Cable Connect to Zymkey 4i Perimeter circuits on Zymbit 4i are accessed from a standard microUSB connector.\nUse a standard microUSB extension cable to close circuits P1 and P2 as follows.\nAdapter Connect to Zymkey 4i Several adapters are available from Zymbit that simplify connection from the microUSB to header and FPC. These are convenient for development. Buy Adapters \u003e\nFlexible Security Shield Wrapping RPi4 HSM4 Security Module, fitted to PiHat1. Flex circuit connects to FPC connector on HAT\nRigid Security Shield installed on ProtoKit4 A printed circuit shield is fitted into the lid of the ProtoKit 4 and pogo pins connect the top mesh to the the bottom board. When the lid is closed, the circuit is closed.\nThe shield connects the following four perimeter signals available on the protoboard:\nPERIM_1B PERIM_2B PERIM_2A PERIM_1A FlexCable Wrap with PiZero Hat SDCard Blocking Perimeter Adapter with PiZero Hat Tamper Switches \u0026 FlexCable with Secure Compute Device Zymbit secure compute motherboard for RPi\nInternal Tamper Switches\nSecure Compute Device in 2U Rack with External Tamper Switches ","categories":"","description":"","excerpt":"OVERVIEW ZYMKEY and HSM security modules feature two independent …","ref":"/tutorials/perimeter-detect/examples/","tags":"","title":"Perimeter Detect Circuit Examples"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tutorials/digital-wallet/","tags":"","title":"Zymbit Embedded Hardware Wallet"},{"body":"\nPrerequisites Raspberry Pi:\nRaspberry PI OS: Bullseye (32 or 64 bit) Raspberry PI OS: Buster (32 or 64 bit) Ubuntu 22.04 LTS (32 or 64 bit) Ubuntu 20.04 LTS (32 or 64 bit) Ubuntu 18.04 LTS (32 or 64 bit) BACKGROUND To skip the background information and start encrypting your RFS, click here.\nWHY ENCRYPT? There are many reasons to encrypt the Root File System (RFS), from keeping WiFi credentials immutable to keeping proprietary software and sensitive data from being cloned.\nFor most Raspberry Pi configurations, only two partitions exist:\n/boot on /dev/mmcblk0p1 / on /dev/mmcblk0p2 INTRODUCING LUKS LUKS (Linux Unified Key Setup) is the popular key management setup for dm-crypt, the de-facto standard for block device encryption with Linux.\nLUKS provides a robust and flexible mechanism for multiple users (and services) to interface to and access Linux’s ‘dm-crypt’ infrastructure.\ndm-crypt is a transparent disk encryption subsystem in Linux kernel versions 2.6 and later and is part of the device mapper infrastructure, and uses cryptographic routines from the kernel’s Crypto API. Both are widely used and understood in the IT community.\nWeaknesses of single Master key dm-crypt has a single Master Key that is used to encrypt / decrypt data in/out of the block. To ensure long term security and deal with changing authorized users/services, it would be necessary to change the Master Key frequently, and potentially share it with multiple users/services on a regular basis. Every new iteration of Master Key would require the underlying data block to be re-encrypted everytime. In real systems, touched by different users/services, this is impractical.\nHierarchical key management A more practical solution is to have a hierarchical key management setup in which users/services are given User Keys that are used to release the MasterKey. User Keys can be easily changed and revoked, without having to re-encrypt the underlying data block. The management of such a hirearchical key managers is the role of LUKS.\nIn this post we show how to use Zymbit Security Module to lock a User Key, that is subsequently used to unlock the Master Key and provide access to the Root File System. If you’d like to learn more about LUKS see the References at the bottom of this post.\nSECURE STORAGE OF LUKS USER KEYS The security efficacy of your LUKS encrypted RFS is highly dependent upon how the User Keys are generated and where they are stored.\nThe SD Card is NOT a secure storage location The growing single board computer family is awesome, and we love it! It is inexpensive, has an incredible amount of computing power for an embedded device and has a very robust software development ecosystem.\nHowever, these devices have an Achilles heel: the SD card is the primary software deployment media, and it can be very easily removed and manipulated.\nThe natural inclination would be to encrypt the file system using LUKS on dm-crypt, but for unattended use across many deployed units the obvious question is: where is the LUKS key stored? Of course, it’s the file system. Even if you try to obfuscate it through various programmatic means, the key is still very vulnerable to attack.\nSecuring LUKS User Key with Zymbit Security Module. The Zymbit Security Module provides a general “locking” service whereby a block of plaintext data is encrypted and signed.\nWhen used with LUKS, the User Key is sent to the Zymbit Security Module to be locked (encrypted and signed) when the file system is created. When the system boots and needs to decrypt the root file system, the locked LUKS key is “unlocked” (signature verified and contents decrypted) and presented to dm-crypt. If the key was unlocked successfully, the boot process continues normally. Here is the boot sequence with a LUKS/dm-crypt filesystem where the key is protected by Zymbit Security Module:\nThe kernel initializes initramfs initramfs presents the locked LUKS key to Zymbit Security Module Zymbit Security Module validates the signature and decrypts the key* The decrypted key is presented to LUKS and the root file system is then decrypted *requires that Zymbit Security Module operational status is “secure”\nZYMKEY4 fitted to Raspberry Pi\nZymbit Security Module Authenticates Host System Before Unlocking LUKS Key\nOne of the key features of Zymbit Security Module is to generate a unique Identity (ID) for the host system, based upon a fingerprint that measures specific system components. This fingerprinting process is used to “bind” together a specific Zymbit Security Module (root of trust, key store, crypto services), a specific host computer and a specific SD card. Once bound, these components form a permanent and immutable ID of the host system.\nEach time the host device boots, and at random intervals thereafter, the Zymbit Security Module rechecks the ID fingerprint. If any of the system components have changed the fingerprint changes and the system is deemed to have been compromised, authentication fails and all security services are shut down.\nUsing this ID / Authentication feature, the Zymbit Security Module can be used to protect LUKS User Keys in unattended applications, where it might be easy to remove and copy SD card content. (The Zymbit Security Module also has other physical security features which are also used to lock/enable security services)\nWHERE TO STORE YOUR LUKS ENCRYPTED RFS LUKS is very versatile and can be applied to both SD Card and external storage media. Lets review the pros and cons of each option:\nWarning When encrypting your rootfs, we highly recommend turning off unattended-upgrades prior to the encryption process. In some cases primarily with Ubuntu 20.04, during an update/upgrade after encryption, the update-initramfs process may fail and leave the system unable to boot.\nTo mitigate this issue, remove the service unattended-upgrades:\nsystemctl stop unattended-upgrades\nsystemctl disable unattended-upgrade\nOption 1 - Convert existing SD Card to LUKS Converting the existing root file system on the SD card still requires an external device (e.g. USB flash drive) that is used as a temporary boot root file system: this provide an easier and lower risk means to convert and copy the original contents. The external devices needs to be a little larger than the existing root file system in order to store the old file system.\nPros:\nLess physical space requirements. Much less power required. Cons:\nConversion is more complex and time consuming than migrating to an external drive. Data space constraints. Write cycle constraints. Access speed constraints. Process Steps Run By Script:\nMake a tarball of the original root file system and store it on the external device Copy the original root file system files to the external device to form a temporary file system Boot to the temporary file system. Once booted, the temporary file system will: Create a LUKS key Lock the LUKS key with Zymbit Security Module Create a LUKS volume on the original root partition. Create an ext4 partition on the LUKS volume on the original root partition Untar the root file system tarball into the converted partition Option 2 - Migrate existing SD card to external LUKS storage device. The existing root file system can be migrated to an external LUKS encrypted USB flash, hard drive or SSD.\nPros:\nExternal devices can hold much more data. Migration is easier and quicker than SD card conversion method. Some external devices have much faster data access than SD cards. Some external devices (e.g. HDD) can tolerate many more write cycles than an SD card. Cons:\nFor HDD and SSD and non-compact USB flash devices, there are additional power requirements. Except for compact USB flash devices, physical space requirements also increase. This may be especially important for the Raspberry Pi Zero family. Process Steps Run By Script:\nCreate the LUKS key Lock the LUKS key Create a LUKS volume on an external USB device Create an ext4 partition on the LUKS volume Move the existing root file system to the LUKS volume on the external device Boot to the new root file system and erase the previous root volume HOW TO ENCRYPT BUILDING YOUR LUKS ENCRYPTED RFS Prerequisites Make sure you have the Zymbit Security Module software suite already running and operational as well as bound. Instructions here.\nOption 1 - Convert existing SD Card to LUKS To convert your root file system to LUKS/dm-crypt, you will need to connect an external USB disk (as temporary storage). As mentioned previously, this is necessary because it is not possible to encrypt the partition in place, so the external disk is needed as temporary storage and a temporary root file system while the conversion takes place. The external disk needs to be at least twice as big as the root partition. Next, run the following script:\ncurl -G https://s3.amazonaws.com/zk-sw-repo/mk_encr_sd_rfs.sh | sudo bash\nFor RPi users: This script is parameterized, so if you have special requirements (e.g. root file system lives on /dev/mmcblk0p4), you can invoke it in the following fashion:\ncurl -G https://s3.amazonaws.com/zk-sw-repo/mk_encr_sd_rfs.sh | sudo bash -s -- -x \u003cpath to external storage device (e.g. /dev/sdX\u003e -m \u003csource partition number\u003e\nIn the above invocation with no parameters, the defaults are:\nOriginal root file system located on /dev/mmcblk0p2 Temporary root file system/storage for original root tarball located on /dev/sda Temporary root file system takes up entirety of new device The very first run of this script on a new temporary external USB disk could take a long time. Also, two reboots are required before the script is complete.\nOne thing to note is that, if the external storage device has an ext4 formatted partition with the original root file system partition (e.g. /dev/mmcblk0p2) on it, this script will use what is already on the external storage device to convert the SD card. This cuts down time for converting lots of device root file systems and allows the script to be used in a mass production deployment.\nOn a Pi4 with an attached USB SSD as the external device on a bare Bullseye “full” version, the first run of this script requires 30 minutes or so to complete the first phase. The second phase takes around 10 minutes.\nBased on the above, using the formatted external device to convert subsequent units should only take around 10 minutes.\nOption 2 - Migrate existing SD card to external LUKS storage device. To migrate your root file system to an external USB device, you can run the following script:\ncurl -G https://s3.amazonaws.com/zk-sw-repo/mk_encr_ext_rfs.sh | sudo bash\nThis script is parameterized, so if you have special requirements, you can invoke in the following fashion:\ncurl -G https://s3.amazonaws.com/zk-sw-repo/mk_encr_ext_rfs.sh | sudo bash -s -- -x \u003cpath to external storage device (e.g. /dev/sdX\u003e -p \u003cdestination partition number -s \u003cmax size of new root partition\u003e -m \u003csource partition number\u003e\nIn the above invocation with no parameters, the defaults for RPi are:\nOriginal root file system located on /dev/mmcblk0p2 New root file system located on /dev/sda1 New root file system takes up entirety of new device Please note that the new root file system should be at least a little larger in size than the original root partition\nRunning this script takes around 30-40 minutes. The Zymbit Security Module’s LED flashes rapidly until the process has completed.\nINTEGRATING LUKS INTO VOLUME MANUFACTURING WORKFLOW The examples above are designed to help you get up and running with single and low volume applications.\nIf you require support in developing a high volume manufacturing encryption workflow then please contact us to discuss our OEM engineering services.\nREFERENCES LUKS features - the de-facto standard in Linux Kernel.\nWiki overview to dm-crypt\nArchLinux - adding LUKS keys to dm-crypt device encryption\nGitLab - LUKS and Cryptsetup - FAQ\nGitLab - LUKS and Cryptsetup - open-source disk encryption\nTroubleshooting Troubleshooting\nCommunity\n","categories":"","description":"","excerpt":"\nPrerequisites Raspberry Pi:\nRaspberry PI OS: Bullseye (32 or 64 bit) …","ref":"/tutorials/encrypt-rfs/","tags":"","title":"Encrypting Root File System with Zymbit Security Modules"},{"body":"Why do this? If you are just getting started with HSM you may want to start by encrypting some data to disk. This would be useful if you are collecting data to be read/analyzed at later time; and you do not want to store your data ‘in the clear’.\nEncrypting data on disk prevents a bad actor from imaging your SD card and gaining access to sensitive data that is being stored in the field. If bad actor were to successfully image the card, data would remain encrypted and locked with your HSM’s private key. If the HSM was also removed, then the bad actor would still not be able to access the data because each specific HSM is bound to a specific host hardware. Moving a specific HSM to another host hardware would fail the binding process and HSM would not perform any crypto functions, including decryption of data blobs.\nEncrypting Data Blobs The process we describe here can also be used more generally to encrypt binary large objects, or ‘data blobs’\nWhat you will need If you have not already setup and bound your HSM please visit the Getting Started page.\nWe will use temperature data from a DS18B20 OneWire probe. We will encrypt the data to disk using the HSM python package, and then decrypt in a different session. For the purpose of this tutorial I will not be going over the circuit setup and one-wire configuration. That is adequately covered here. If you have questions however, we are happy to help!\nThe process is very simple:\nCollect Measurements Encrypt data with HSM Safely store data locally Decrypt at a later time with HSM. Locking Data Below is a sample script you can use to encrypt sensor data. Most of the code is for data acquisition, not encryption. For the most part, we are only interested in the lines toward the bottom using zymkey.client .\nimport base64 import time import zymkey import datetime import logging import argparse import subprocess as sub class TempRead(object): def __init__(self): self.base_dir = '/sys/bus/w1/devices/' def probe_scan(self): devices_raw = sub.check_output(['ls', self.base_dir]) devices = [] for i in range(0, len(devices_raw)-3): if devices_raw[i:i+3] == '28-': devices.append(devices_raw[i:i+15]) return devices def read_temp_raw(self, probe): f = open(self.base_dir+probe+'/w1_slave', 'r') lines = f.readlines() f.close() return lines def read_temp(self, probe): lines = self.read_temp_raw(probe) while lines[0].strip()[-3:] != 'YES': time.sleep(0.2) lines = self.read_temp_raw(probe) equals_pos = lines[1].find('t=') if equals_pos != -1: temp_string = lines[1][equals_pos+2:] c = round(float(temp_string) / 1000, 1) f = round(float(c * 9 / 5 + 32), 1) return c, f if __name__ == '__main__': parser = argparse.ArgumentParser() parser.add_argument('--loglevel', '-l', default='debug') parser.add_argument('--file_out', '-fo', type=str, default='/tmp/encrypted.bin') parser.add_argument('--zymkey', action='store_true', default=False) parser.add_argument('--sleep', type=float, default=20) parser.set_defaults() args = parser.parse_args() logging.basicConfig( format=\"%(levelname)s:%(name)s:%(lineno)s:%(message)s\", level=getattr(logging, args.loglevel.upper()) ) # streams to sys.stderr by default temp = TempRead() probes = temp.probe_scan() encrypted_file = open(args.file_out, mode='wb') while True: for probe in probes: temp_c, temp_f = temp.read_temp(probe) payload = \"action=data, \" \\ \"key=temperature, \" \\ \"tags.unit=c, \" \\ \"tags.sensor_id={},\" \\ \"timestamp={}, \" \\ \"value= {}\".format(str(\"ds18b20:\"+probe.replace(\"-\", \"\")), datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S'), temp_c) logging.debug('Unencrypted Payload: {}'.format(payload)) if args.zymkey: logging.info('Encrypting data...') locked_data = zymkey.client.lock(bytearray(payload)) encrypted_file.write(base64.b64encode(locked_data)+'\\n') logging.debug('Encrypted DATA: {}'.format(locked_data)) time.sleep(args.sleep) The takeaways here are the zymbit.client.lock method and the flow of data types. Specifically, we want to lock a measurement of type float , the zymkey app utils library expects a bytearray , and the data needs to be base64.encode d so the blob can be written to a file on disk. This may sound like a lot but it can all be contained in two simple lines of code:\nlocked_data = zymkey.client.lock(bytearray(payload)) encrypted_file.write(base64.b64encode(locked_data)+'\\n') See! HSM is super easy to use!\nTo see this in action copy this to your pi, save it as sensor_lock.py for consistency, and run the command:\npython sensor_lock.py --zymkey --sleep=5\nYou should see encrypted data flowing and the new file /tmp/encrypted.bin , where your data is saved on disk.\nUnlocking Data With the data we locked to disk above, lets unlock the data now so it is human and machine readable. A simple script such as the one pasted below will read the encrypted file, decode with base64, unlock with HSM and write to a decrypted.txt file so data is legible.\nimport base64 import logging import zymkey import argparse parser = argparse.ArgumentParser() parser.add_argument('--loglevel', '-l', default='debug') parser.add_argument('--file_in', '-fi', type=str, default='/tmp/encrypted.bin') parser.add_argument('--file_out', '-fo', type=str, default='/tmp/decrypted.txt') parser.set_defaults() args = parser.parse_args() logging.basicConfig( format=\"%(levelname)s:%(name)s:%(lineno)s:%(message)s\", level=getattr(logging, args.loglevel.upper()) ) # streams to sys.stderr by default with open(args.file_in) as f: logging.debug(\"Reading encrypted data from {}\".format(args.file_in)) content = f.readlines() decrypted_file = open(args.file_out, mode='w+') for i in content: payload = zymkey.client.unlock(bytearray(base64.b64decode(i))) logging.info(str(payload)) logging.debug(\"Writing decrypted sensor data {} to {}\".format(payload, args.file_out)) decrypted_file.write(str(payload) + '\\n') decrypted_file.close() Copy this to your Raspberry Pi, save as sensor_unlock.py and run as is with:\npython sensor_unlock.py\nYour data will be unlocked and saved to disk at /tmp/decrypted.txt . It should look something like this:\naction=data, key=temperature, tags.unit=c, tags.sensor_id=ds18b20:28000006151b77,timestamp=2016-12-13 22:55:02, value= 19.5 action=data, key=temperature, tags.unit=c, tags.sensor_id=ds18b20:280000061543fd,timestamp=2016-12-13 22:55:03, value= 19.6 action=data, key=temperature, tags.unit=c, tags.sensor_id=ds18b20:28000006156310,timestamp=2016-12-13 22:55:04, value= 19.3 action=data, key=temperature, tags.unit=c, tags.sensor_id=ds18b20:28000006e10735, Troubleshooting Troubleshooting\nCommunity\n","categories":"","description":"","excerpt":"Why do this? If you are just getting started with HSM you may want to …","ref":"/tutorials/sensor-data/","tags":"","title":"Encrypting \u0026 Decrypting Sensor Data on Disk"},{"body":"The AWS Credentials provider can give a remote device AWS credentials if it has a valid certificate. The device certificate is stored inside AWS IoT’s service and can be revoked, deactivated or deleted at any time. AWS IoT can also record and index individual IoT Things within a fleet. Each IoT thing will have its own unique certificate verified by AWS, and can be given unique attributes to identify each device along with policies which control the approved actions of each device.\nUsing AWS IoT also allows device data to be used by other AWS cloud services. Once the device is given credentials, other AWS services can be configured to receive data from the device.\nThe IoT device’s AWS credentials are only valid for a period of time. If the credentials expire, when the AWS CLI tries to connect to AWS servers, it will run an installed script to get new credentials.\nDevice Setup There are four devices in the provisioning process:\nThe Provisioning Device with AWS CLI installed (usually your PC) The Certificate Authority The AWS Credentials Provider The IoT Device(s) getting their credentials (with Zymbit security module(s) installed) If wanted, the CA and provisioning device can be on the same device.\nSetup the Provisioning Device The provisioning device can be any device with AWS CLI installed, but we recommend it not be an IoT device you deploy because the provisioning device will have more AWS permissions.\nInstall AWS CLI. Instructions here: https://aws.amazon.com/cli/ Specify user for AWS CLI Go to AWS IAM console, click users, add user, input a user name, and check programatic access. Click Next:Permissions, “Attach existing policies directly”, click AdministratorAccess Click Next:Tags, Next:Review, Create user. Stay on this page. On the provisioning device, run aws configure and fill in the appropriate values from the AWS page. For Default output format put json. Run git clone https://github.com/zymbit-applications/aws-credentials-provider.git Run sudo mkdir /opt/zymbit Setup the Certificate Authority The Certificate Authority can be a private CA you own or you can use AWS’s CA service. If you want to create a CA on your own device, follow these instructions.\nCreate a private CA On the device you want to hold your private CA and sign certificate requests, do the following.\nRun git clone https://github.com/zymbit-applications/aws-credentials-provider.git Run cd aws-credentials-provider Run the mk_ca script: bash mk_ca.sh There are now three files in the directory (~/aws-credentials-provider/CA_files).\nzk_ca.key The private key for the CA, used for signing CSR’s zk_ca.pem The certificate for the CA in PEM format zk_ca.crt The certificate for the CA If you have your own private CA, then you need to register it with AWS.\nRegister certificate authority with AWS Steps 1 and 6 are done on the provisioning device. Steps 2-5 must be done on the private CA.\nCopy the registration code for generating CA cert. aws iot get-registration-code Create a private key for AWS CA to verify against. openssl genrsa -out verificationCert.key 2048 Create a CSR for your CA to sign openssl req -new -key verificationCert.key -out verificationCert.csr Put registration code in the Common Name field Country Name (2 letter code) [AU]: State or Province Name (full name) [Some-State]: Locality Name (eg, city) []: Organization Name (eg, company) [Internet Widgits Pty Ltd]: Organizational Unit Name (eg, section) []: Common Name (e.g. server FQDN or YOUR name) []: 9c9df696a8a09688d040b4b719129e4d6dbd6a898eeb0c654af0a5753b41 Email Address []: Please enter the following 'extra' attributes to be sent with your certificate request A challenge password []: An optional company name []: Create a private key verification certificate for your CA. If you didn’t follow our CA creation section, then the -CA and -CAkey file paths are likely different. openssl x509 -req -in verificationCert.csr -CA CA_files/zk_ca.pem \\ -CAkey CA_files/zk_ca.key -CAcreateserial -out verificationCert.crt \\ -days 500 -sha256 Register CA certificate, set it as active and allow device certificates to auto register. aws iot register-ca-certificate --ca-certificate file://CA_files/zk_ca.crt \\ --verification-certificate file://verificationCert.crt \\ --set-as-active \\ --allow-auto-registration Setup AWS Credentials Provider All of these steps happen on the provisioning device\nCreate an IAM role for credentials provider aws iam create-role --role-name credential_helper --assume-role-policy-document file://aws-credentials-provider/role-trust-policy.json Create a role alias linked to role aws iot create-role-alias --role-alias deviceRoleAlias --role-arn \u003croleARN\u003e The roleARN is in the output of step 1, but you can run aws iam get-role --role-name credential_helper to find it again. If this fails, the user you currently are may not have GetRole and PassRole permissions. The tab below gives instructions to add these permissions. Add Permissions Go to AWS IAM console Select Users Select the user you currently are on your provisioning device Click the permissions tab Click Add permissions Click “Attach existing policies directly” Click Create Policy Click the JSON tab Copy the user-pass-permissions.json file into the editor Replace ACCOUNT_ID with your provisioning device user You can find this by running aws sts get-caller-identity on your provisioning device. Replace ROLE_NAME with name given in the step above (e.g. credential_helper) Click Next:Tags Click Next:Review Name the policy Click create. Create an IoT policy which allows role alias to be assumed with a certificate In ~/aws-credentials-provider/iot-role-policy.json substitute: REGION with the desired region ACCOUNT_ID with the “Account” number found by running aws sts get-caller-identity ALIAS with the name of the role alias created in step 2 Then run aws iot create-policy --policy-name credentialHelper --policy-document file://aws-credentials-provider/iot-role-policy.json Setup the IoT device getting credentials Run git clone https://github.com/zymbit-applications/aws-credentials-provider.git Run sudo mkdir /opt/zymbit Run sudo cp ~/aws-credentials-provider/credentials.sh /opt/zymbit/ \u0026\u0026 sudo chmod +x /opt/zymbit/credentials.sh Edit ~/aws-credentials-provider/config to specify the appropriate region. Run mkdir ~/.aws \u0026\u0026 cp ~/aws-credentials-provider/config ~/.aws/config Provisioning an IoT Device Notice The following procedure was done with Raspberry PI OS Buster 32bit. The current version of cURL included in bullseye (7.74.0) seems to have an issue using the openssl engine import feature. On the IoT device Run openssl req -key nonzymkey.key -new -out zymkey.csr -engine zymkey_ssl -keyform e Fill in the request with the specified values The IoT Policy name, we used credentialHelper. The desired AWS Region. Credential Provider URL. To find this, on the provisioning device run aws iot describe-endpoint --endpoint-type iot:CredentialProvider Copy the cxxxxxxxxxxxxx part. Role Alias name, we used deviceRoleAlias. The Thing name, whatever you want to name this IoT device. Country Name (2 letter code) [AU]: State or Province Name (full name) [Some-State]: \u003cIOT-POLICY\u003e Locality Name (eg, city) []: \u003cREGION\u003e Organization Name (eg, company) [Internet Widgits Pty Ltd]: \u003cCREDENTIAL-URL\u003e Organizational Unit Name (eg, section) []: \u003cROLE-ALIAS\u003e Common Name (e.g. server FQDN or YOUR name) []: \u003cTHING-NAME\u003e Email Address []: Please enter the following 'extra' attributes to be sent with your certificate request A challenge password []: An optional company name []: Copy zymkey.csr from the IoT device to CA device. If using our CA tutorial, put csr in the aws-credentials-provider directory (~/aws-credentials-provider) On the CA device, sign the CSR. If using our CA tutorial, in ~/aws-credentials-provider, run bash sign_csr.sh zymkey.csr device.crt. The first argument is the path to your CSR and the second argument the name you wish to give the signed device Certificate file. Copy the device cert (device.crt) and root ca key from the CA device to the provisioning device. If following our CA tutorial, the root ca key is CA_files/zk_ca.pem. On the provisioning device, run: sudo cp device.crt /opt/zymbit/ \u0026\u0026 sudo cp root.ca.pem /opt/zymbit/ cd ~/aws-credentials-provider; bash provision-device.sh The script will ask you a few questions, make sure everything is correct. The script behind the scenes will: Register device cert in AWS with root CA cert Create a IoT Thing in AWS Attach thing to device cert Attach IoT policy to device cert Once the script is done, transfer device.crt and root.ca.pem from the provisioning device to the IoT device. On the IoT device, run: sudo mv device.crt /opt/zymbit/ \u0026\u0026 sudo mv root.ca.pem /opt/zymbit/ /opt/zymbit/credentials.sh to test the TLS connection. If the resulting output contains values for AccessKey, SecretAccessKey, etc, then your device has AWS credentials! To use Zymbit credentials with AWS CLI, set the profile flag to zymkey like so; aws --profile zymkey iot describe-endpoint ","categories":"","description":"","excerpt":"The AWS Credentials provider can give a remote device AWS credentials …","ref":"/tutorials/aws-iot/integrate/","tags":"","title":"How to Integrate Zymbit with AWS Credentials Provider"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tutorials/aws-iot/","tags":"","title":"AWS IoT Integrations \u0026 Client Certificates"},{"body":"How to automatically generate a client certificate, register your own CA, and authenticate a device to establish a TLS connection to AWS IoT Overview AWS IoT requires an IoT device to register and activate a certificate with AWS before communicating. For large scale deployments, AWS provides an automated process called Just-In-Time-Registration. This allows a user to register a Certificate Authority with AWS so that upon a device’s first TLS connection to AWS servers, if the device certificate was signed by this Certificate Authority, the certificate will be quickly activated by a lambda-function and be ready to use.\nPrerequisites: Follow the Getting Started guide first. Programmatic Setup If you would like to use scripts to register your CA and Lambda function, there are a couple more things to set up. We recommend following the manual approach if your only doing this once or twice.\nDetails Follow these instructions to set up the boto3 module for Python:\nThe boto3 module authenticates with AWS based on a IAM Access ID and Secret Key. The boto3 tutorial will ask you to setup an IAM user, here are some instructions on how to do so:\nFrom the AWS console, choose the IAM service. Go to Users and select Add User Choose a username and check the Programmatic access box For simplicity, choose Attach existing policies directly and select AdministratorAccess If you wish to better manage your IAM credentials, feel free to customize your Access Policy. Click Review and then Create User Save the Access ID and Secret Key and follow the boto3 guide. Register Certificate Authority with AWS The following section will show how to generate your own CA using OpenSSL and register it with your AWS account.\nDetails Create CA Copy the lines below into a script called mk_ca.sh.\n#!/bin/bash set -e mkdir CA_files cd CA_files openssl ecparam -genkey -name prime256v1 -out zk_ca.key OPENSSL_CONF=/etc/ssl/openssl.cnf openssl req \\ -x509 -new -SHA256 -nodes -key zk_ca.key \\ -days 3650 -out zk_ca.crt \\ -subj \"/C=US/ST=California/L=Santa Barbara/O=Zymkey/CN=zymkey-verify.zymbit.com.dev\" cp zk_ca.crt zk_ca.pem You can then run the script in the command line by being in the same directory with the following command:\nbash mk_ca.sh The script will create a directory called CA_files and a couple of files: zk_ca.key: Private key for the created CA, will be supplied to OpenSSL for signing CSRs. zk_ca.pem: PEM formatted certificate for the CA zk_ca.crt: Same file as zk_ca.pem\nRegister CA with AWS Manually:\nFrom the AWS IoT console select Secure then CA and then click Register\nClick register CA\nFollow the directions on the following screen to create a verification certificate.\nWhen signing the verification certificate with your CA in Step 4 run the following command:\nopenssl x509 -req -in verificationCert.csr -CA CA_files/zk_ca.pem -CAkey CA_files/zk_ca.key -CAcreateserial -out verificationCert.crt -days 500 -sha256 Note that if you a different CA and not the demo one we generated, to change the -CA and -CAkey paths appropriately.\nClick Select CA certificate and point to the correct .pem file. If you use the OpenSSL generated SSL point to CA_files/zk_ca.pem\nClick Select verification certificate and point to verificationCert.crt which was created in Step 4.\nSelect Active CA certificate and Enable auto-registration of device certificates\nProgramatically: The following python script will automatically create a verification cert with a registration code and automatically active your Certificate Authority. While it may look a bit intimidating, all you have to worry about is the very last line, where you can change to point to your CA files.\nimport OpenSSL import boto3 import os def gen_AWS_verification_csr(registrationCode): key = OpenSSL.crypto.PKey() key.generate_key(OpenSSL.crypto.TYPE_RSA, 2048) req = OpenSSL.crypto.X509Req() req.get_subject().CN = registrationCode req.set_pubkey(key) req.sign(key, \"sha256\")\treturn OpenSSL.crypto.dump_certificate_request(OpenSSL.crypto.FILETYPE_PEM, req) def sign_CSR_with_CA(verification_csr, CA_cert_path, CA_key_path): ca_cert = OpenSSL.crypto.load_certificate(OpenSSL.crypto.FILETYPE_PEM, open(CA_cert_path).read()) ca_key = OpenSSL.crypto.load_privatekey(OpenSSL.crypto.FILETYPE_PEM, open(CA_key_path).read()) req = OpenSSL.crypto.load_certificate_request(OpenSSL.crypto.FILETYPE_PEM, verification_csr) cert = OpenSSL.crypto.X509() cert.set_subject(req.get_subject()) cert.set_serial_number(1) cert.gmtime_adj_notBefore(0) cert.gmtime_adj_notAfter(24 * 60 * 60) cert.set_issuer(ca_cert.get_subject()) cert.set_pubkey(req.get_pubkey()) cert.sign(ca_key, \"sha256\") return OpenSSL.crypto.dump_certificate(OpenSSL.crypto.FILETYPE_PEM, cert) def register_CA_AWS(CA_cert_path, CA_key_path): client = boto3.client('iot') response = client.get_registration_code() registration_key = response['registrationCode'] verification_pem = gen_AWS_verification_csr(registrationCode=registration_key) verification_cert = sign_CSR_with_CA(verification_csr=verification_pem, CA_cert_path=CA_cert_path, CA_key_path=CA_key_path) response = client.register_ca_certificate( caCertificate=open(CA_cert_path).read(), verificationCertificate=verification_cert, setAsActive=True, allowAutoRegistration=True ) return response register_CA_AWS(CA_cert_path='CA_files/zk_ca.crt', CA_key_path='CA_files/zk_ca.key')\tCopy the above lines into a file called activate_aws_ca.py and run with the following command:\npython activate_aws_ca.py Generate Zymkey Certificate The first thing we will do is generate a device certificate using Zymkey’s private key. We will watch as this certificate gets activated on your AWS IoT console automatically on first connect. Make sure that you do not already have a Zymkey certificate registered on your AWS IoT console.\nGenerate a Certificate Signing Request with Zymkey’s private key using the following command:\nopenssl req -key nonzymkey.key -new -out zymkey.csr -engine zymkey_ssl -keyform e -subj \"/C=US/ST=California/L=Santa Barbara/O=Zymbit/OU=Zymkey/CN=rpi.edge.zymbit.com\" Note that the -subj line can be omitted or modified with your own information. If it is omitted, you will be prompted to enter your information on the command line.\nSigning the CSR to get a valid Zymkey certificate:\nNext we’ll sign this CSR with your Certificate Authority. Save the following script in a file called sign_csr.sh. Make sure to change the -CA and -CAkey paths to point to the private key and certificate file for your certificate authority:\n#!/bin/bash set -e SCRIPT_NAME=$(basename $0) [ -z $2 ] \u0026\u0026 echo \"${SCRIPT_NAME} \u003ccsr filename\u003e \u003ccrt filename\u003e\" 1\u003e\u00262 \u0026\u0026 exit 1 csr=$1 crt=$2 openssl x509 -req -SHA256 -days 3650 \\ -CA CA_files/zk_ca.crt -CAkey CA_files/zk_ca.key -CAcreateserial \\ -in ${csr} -out ${crt} Now run the script with the following command, where the first argument is the path to your CSR and the second argument the name you wish to give the signed Zymkey Certificate file.\nbash sign_csr.sh zymkey.csr zymkey.crt Creating the Lambda function Now we need to create and register the lambda function that will activate new certificates on your AWS account. This can be done either manually or programatically in Python. We’ll start with the Manual method as it is simpler and more straightforward.\nDetails Manually:\nFrom your AWS console, sign in here, choose the Lambda service. From the Lambda console, click on the orange Create Function button. Click the Author from Scratch button. Choose an appropriate function name and description. We will be using Node.js 12.x for the runtime environment. Click Create function. Copy the default JITR code from AWS located here into index.js under Function code (If pasting doesn’t work in their IDE, try Shift+Insert). Make sure that you change the region defined in the code to the appropriate value. Now scroll to the top and click the Permissions tab. Under Execution role, click Edit. There should be an existing role listed under Existing role. Click the blue title View the role on the IAM console. This should take you to the IAM console. Click Attach policies Click Create policy, then the JSON tab. Input the following policy { \"Version\":\"2012-10-17\", \"Statement\":[ { \"Effect\":\"Allow\", \"Action\":[ \"logs:CreateLogGroup\", \"logs:CreateLogStream\", \"logs:PutLogEvents\" ], \"Resource\":\"arn:aws:logs:*:*:*\" }, { \"Effect\":\"Allow\", \"Action\":[ \"iot:UpdateCertificate\", \"iot:CreatePolicy\", \"iot:AttachPrincipalPolicy\" ], \"Resource\":\"*\" } ] } Click Review policy. Give the policy an appropriate name (maybe JITR) and click Create policy. On the left hand bar, click Roles. Click on your lambda role name. It should start with the function name you defined in step 4, followed by role, then some random characters. Click Attach policies. Click the box next to the policy we just created in step 14. Click Attach policy. Click the X to the right of the old policy titled AWSLambdaBasicExecutionRole, and click Detach. Programatically: The creation of an AWS lambda function through python scripts is a little more intricate than the manual proccess and will need to be divided into numerous parts. The creation of the lambda function will be divided into these steps:\nCreating a new IAM role for the lambda function. Creating a new Policy for this IAM role. Attaching the Policy to the IAM role. Create the lambda function, attaching the IAM role to this function. \u003cdetails=“Details”\u003e\nCreating IAM Role for the Lambda function The first thing we need to do is create an IAM Role. This role gives the Lambda function permission to execute and perform its registration of new certificates.\nCreating this IAM role furthermore requires you to specify 2 things:\nIAM Trust Document: This is a document that details what AWS resources are allowed to assume this IAM role. Below is an example IAM trust document we will use that allows lambda services to assume this JITR role. Save the document in a file called trust_document.txt.\n{ \"Version\": \"2012-10-17\", \"Statement\": [ { \"Effect\": \"Allow\", \"Principal\": { \"Service\": \"lambda.amazonaws.com\" }, \"Action\": \"sts:AssumeRole\" } ] } Role Policy: This is a document describing what actions an IAM role may take. This policy is created and then attached to whatever role you wish. The following policy will allow the JITR role to create AWS logs as well as register/activate new certificates and attach policies to them. Save the document in a file called policy_document.txt.\n{ \"Version\":\"2012-10-17\", \"Statement\":[ { \"Effect\":\"Allow\", \"Action\":[ \"logs:CreateLogGroup\", \"logs:CreateLogStream\", \"logs:PutLogEvents\" ], \"Resource\":\"arn:aws:logs:*:*:*\" }, { \"Effect\":\"Allow\", \"Action\":[ \"iot:UpdateCertificate\", \"iot:CreatePolicy\", \"iot:AttachPrincipalPolicy\" ], \"Resource\":\"*\" } ] } Finally, this is the python code that will take care of the creation of the IAM role. The first thing it does is create an IAM role with the specified Trust settings. Then it creates an IAM policy with the aforementioned policy settings. Finally it will attach the policy to the role. This role will be used by the JITR lambda. By default it’ll read the two documents trust_document.txt and policy_document.txt from the same directory that the code is executed in. So save the python script in a file called create_jitr_lambda.py in the same directory as these files, or modify the path to these files in the code. They can be either relative or absolute\nimport boto3 iam_client = boto3.client('IAM') with open('trust_document.txt') as trust_role: trust_document = trust_role.read() with open('policy_document.txt') as policy: policy_document = policy.read() # Creating the IAM role with the specified Trust create_role_response = iam_client.create_role( RoleName='jitr_role', AssumeRolePolicyDocument=trust_document, Description='AWS Role given to the JITR lambda' ) # Creating the IAM policy with the specified P create_policy_resopnse = iam_client.create_policy( PolicyName=policy_name, PolicyDocument=policy_document, Description'Policy that allows JITR lambda to execute actions.' )\t# Attaching the IAM policy to the IAM role\tattach_response = iam_client.attach_role_policy( RoleName=role_name, PolicyArn=create_policy_response['Policy']['Arn'] ) After saving the code in a file called create_jitr_lambda.py, you can execute by running the following command:\npython create_jitr_lambda.py Creating Lambda function The lambda function will then be created with the following script. The code for the lambda function will be in a zipped file named jitr_lambda.zip. Download the lambda code here and make sure to modify the region-name in the code to your approrpiate region.\nNext, zip up the code in a file called jitr_lambda.zip and keep it in the same directory as the following python script.\n#Download the zip file with the lambda code and save it in the same directory as this script. with open('jitr_lambda.zip', mode='rb') as file: filecontent = file.read() lambda_client = boto3.client('lambda') create_lambda_response = lambda_client.create_function( FunctionName='jitr-lambda', Runtime='nodejs4.3', #By appending this script unto create_jitr_lambda.py you do not need to find the role_ARN, as it will already be stored in this object. Role=attach_response['Arn'] Handler='index.handler\t', Code={ 'ZipFile': filecontent }, Description='Lambda function for Just-in-time-Registration', )\tNote that this script requires the Role ARN for the IAM role you just created. If you append this script to the file create_jitr_lambda.py, it will already be included in the response from attaching the policy to the jitr_role, and you won’t have to do anything.\n#Do not copy and run these lines, this is just showing where the role_ARN was taken from attach_response = iam_client.attach_role_policy( RoleName=role_name, PolicyArn=create_policy_response['Policy']['Arn'] ) role_ARN = attach_response['Arn'] Otherwise, if you don’t wish to append the following script to the create_jitr_lambda.py, here is how you can find the appropriate role_arn:\nFrom your AWS Console choose the IAM service. On the left hand bar, click on Roles Select the role titled jitr_role. Copy the section following Role ARN In the following python script, replace: Role=attach_resopnse[‘Arn’] with Role=the_correct_role_arn Save the script in an appropriate location, and run it.\nCreating the AWS IoT Rule Finally we will be setting up an AWS IoT Rule to forward all requests with an unregistered certificate to the lambda function that will activate the certificate.\nFirst we need our caCertificateID\nUnder Secure click CAs. Click on the CA Certificate you created earlier. Under the CA Certificate ARN, copy the last section of characters possesing your CA Certificate ID. arn:aws:iot:us-east-2:302973482904:cacert/\u003ccaCertificateID\u003e Now to create the rule\nFrom your AWS Console, click on the AWS IoT service. On the left hand side, select Act and then click Rules. Click Create then give an appropriate Name and Description. Using SQL version 2016-03-23 use the following Rule query statement: SELECT * FROM '$aws/events/certificates/registered/\u003ccaCertificateID\u003e' Click Add action. Click Send a message to a Lambda function and Configure Action. Select your lambda function and click Add action. Finally click Create rule. Testing JITR with TLS Connection You can now test your JITR setup by doing a TLS connection with your AWS IoT endpoint and presenting your Zymkey device certificate.\nDetails The first thing to do is to look for your AWS endpoint.\nFrom the AWS IoT console screen, click on the gear that says Settings on the left hand bar.\nCopy the link in the Custom Endpoint box.\nNow on the left hand bar, click on the Test option.\nUnder Subscribe and Subscription Topic, type in hello/world.\nTest your TLS connection with the following CURL command pointing to your CA file and your Zymkey certificate:\nUse CURL to test your TLS connection, pointing to your CA file:\ncurl --tlsv1.2 --cacert zk_ca.pem --cert zymkey.crt --key nonzymkey.key --engine zymkey_ssl --key-type ENG -v -X POST -d \"{ \\\"hello\\\": \\\"world\\\"}\" \"https://endpoint.iot.region.amazonaws.com:8443/topics/hello/world\" The TLS connection should go through, and you should see something like this in your command line:\nOn first connection TLS connection, the TLS handshake should finish, but you should receive empty response from server:\nOn second TLS connection, you will see that the certifiacte is registered and you will get a correct response:\nYou can also check under your certifiactes in your AWS IoT console to see that the new certifciacte is indeed registered. Getting a non-empty response indicates that the certificate is indeed registerd on you AWS account. However, even though the certificate is activated, it does not have a valid policy granting it permission to publish data to your AWS IoT account, which results in the forbidden response. Fortunately you can always modify the jitr lambda function to attach an appropriate policy to the certificate upon registration/activation if you wish to do so.\n","categories":"","description":"","excerpt":"How to automatically generate a client certificate, register your own …","ref":"/tutorials/aws-iot/jitr/","tags":"","title":"AWS IoT - Just in Time Registration of Client Certificates using Lambda functions"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tutorials/perimeter-detect/","tags":"","title":"Perimeter Detect"},{"body":"SECURE PROTOKIT FOR Pi COMPUTERS Waterproof, Dustproof, Radio Transparent, Tamper Evident.\nUpgraded Features ProtoKit5 replaces the ProtoKit4. We had a lot of great feedback from customers of our earlier ProtoKit 4. Here are some of the improvements we made:\nLarger IP67 enclosure: W x H x D | 130 x 175 x 45 mm | 5.12 x 3.24 x 1.77 inches Two cable glands All components soldered to board, ready to go. Fully integrated tamper detect perimeter circuits - switch, pads, user defined. Easier to wire, more robust connectors - screwless, spring cage \u0026 tension clamp. Dedicated +5V connector Schematics How to wire What’s Inside Your Kit This kit comes assembled and ready to start building your prototype in to. The following components are included:\n❶ IP67 enclosure, dustproof, waterproof enclosure with lid\n❷ Integrated protoboard.\n❸ Adapter for perimeter circuits\n❹ GPIO connector extension\n❺ Standoffs for Pi, M2.5 - x 3\n❻ Screws for Pi, M2,5 Torx T8 - x 3\n❼ Screws for protoboard fix - x5\n❽ Cable glands, 3/4 - x2\n❾ IP67 lid with neoprene gasket\n❿ Screws for lid - x6\n⓫ Tamper switch actuators - x2\nBUY NOW \u003e A TOUR OF THE PROTOBOARD The protoboard fits cleaning into the enclosure and can easily be removed for wiring and assembly with your components.\nSlot for Pi Computer\nProtokit will fit the following Pi footprint computers:\nRaspberry Pi 2, 3, 3B+, Zero Asus Tinkerboard Odroid C2 (Heatsink may interfer if zymbit security module fitted) IMPORTANT ! - The Pi computer is fitted connector down, with the CPU facing the protoboard.\nStandoffs to Mount Pi Computer Three M2.5, 5mm pcb standoffs are soldered to the board. Additional screw-in standoffs are supplied to achieve an overal standoff - between Pi and protoboard - of 18mm. Slot for Zymbit Security Module - Zymkey 4i Perimeter Adapter Interface Perimeter Configuration Jumper Tamper Switches - Circuit 1 Perimeter Pads - Circuit 2 Input / Output Connectors +5V Power Input Connector Power Bus - 3v3 Bus Bars - 2 X 15 Grid Arrays - 5 X 15 The grids are not powered and are designed to make it convient to solder wires and components into your design. The reference markers make it easy to document your design and later transfer to work instructions or a PCB design net list. Each pad can be uniquely referenced as G15.D.9 for example. Schematic of Protoboard Download Schematic \u003e\nASSEMBLING YOUR PROTOKIT 5S Fitting a Zymbit Security Module \u0026 Perimeter Adapter If you are fitting a Zymbit security module, here’s where it goes. Fit the perimeter adapter at the same time.\nSequence for Fitting Zymkey4 and Perimeter Adapter\nConfiguring Perimeter Detect Circuits Zymbit security modules contain two perimeter circuits that can be used to detect tampering of a secure envelope. Each tamper circuit is closed in normal operation. When a circuit is opened, a Tamper Event is registered by the Zymbit Security Module.\nLearn how to configure and operate perimeter events in software \u003e\nTypically the two circuits are configured to provide independent layers of physical security:\nPERIM 1 - protects an inner electronic enclosure, like this ProtoKit5 enclosure. PERIM 2 - protects an outer cabinet enclosure, trip wire or other. On ProtoKit 5 there are several ways to configure PERIM 1 and PERIM 2. By default both circuits are closed with two jumpers. 1A\u003c\u003e1B , 2A\u003c\u003e2B.\nUsing Tamper Switches The protoboard includes two tamper switches, PERIM_SWA and PERIM_SWB, that are connected in series to the PERIM 1 tamper circuit. To configure and activate these switches follow these steps:\nRemove the Jumper 1A\u003c\u003e1B Pressing down both switches SWA, SWB will close the PERIM 1 circuit. The lid of you ProtoKit 5 includes two “actuators” that align with the switches and activate (close) them when the lid is fitted and screwed securely in place. If needed you can adjust the length by screwing the actuator in or our of the panel. Tamper Switch Actuators Fitted to Lid Tamper Switch Actuators Pressing Switches Using Perimeter Pads The protoboard includes four tamper pads that are connected to the PERIM 2 tamper circuit as follows:\nConnected on protoboard PCB (orange color) PERIM_PAD_2A \u003c\u003e PERIM_2A_ZYMKEY4 PERIM_PAD_2B \u003c\u003e PERIM_2B_ZYMKEY4 PERIM_PAD_2C \u003c\u003e PERIM_PAD_2D\nConnected by user circuit (green color) PERIM_PAD_2A \u003c\u003e PERIM_PAD_2C PERIM_PAD_2B \u003c\u003e PERIM_PAD_2D\nExamples for Using Perimeter Pads The Perimeter Pads are designed to be used in applications where the lid contains a user defined circuit such as a display or keypad, or this custom shield (which was designed for ProtoKit4). Springed Pogo pins can be used to connect the lid to the perimeter pads. This provides an additional layer of physical security to the tamper-switches.\nAdd Your Pi Computer Fit the GPIO extender header. Fit your Pi computer being careful to correctly align pins. Secure in place with three M2.5 screws using a T8 TORX driver. Place into Enclosure Fitting Cable Glands Your kit comes with two nylon cable glands pre-fitted into ½\" 14 NPT threaded holes. They accept cables with diameter 0.51\" to 0.71\".\nNeed something different? There a many different types of cable glands: size, cable clamp, strain relief, number of cables, material, etc. If you need something different to what is supplied with you kit, then check out this supplier who has a great selection. ElecDirect \u003e\nAdd Enclosure Lid Be sure to add the black seal that was provided with your kit.\nIP67 Enclosure Ratings The enclosure is rated for the following ingress protection.\nIP6x Solid particle protection\nDust Tight - complete protection against contact (dust tight). A vacuum must be applied. Test duration of up to 8 hours based on air flow. IPx7 Liquid ingress protection\nImmersion, up to 1 m depth. Ingress of water in harmful quantity shall not be possible when the enclosure is immersed in water under defined conditions of pressure and time (up to 1 m of submersion). For further details on IP ratings refer to wiki/IP_Code.\nMOUNTING OPTIONS Panel Mounting This enclosure can be mounted directly to a wall or flat surface using two self tapping screws.\nPole Mounting This enclosure can be easily mounted to a pole using a pole mounting brackets available from the Zymbit store.\n","categories":"","description":"","excerpt":"SECURE PROTOKIT FOR Pi COMPUTERS Waterproof, Dustproof, Radio …","ref":"/tutorials/protokit/","tags":"","title":"ProtoKit5"},{"body":" Introduction Python interface module to Zymkey Application Utilities Library.\nThis file contains a Python class which interfaces to the the Zymkey Application Utilities library. This class facilitates writing user space applications which use Zymkey to perform cryptographic operations, such as:\nSigning of payloads using ECDSA. Verification of payloads that were signed using Zymkey. Exporting the public key that matches Zymkey’s private key. “Locking” and “unlocking” data objects. Generating random data. Additionally, there are methods for changing the i2c address (i2c units only), setting tap sensitivity, and controlling the LED.\nClasses class zymkey.Zymkey The Zymkey class definition.\nThis class provides access to the Zymkey within Python.\nEPHEMERAL_KEY_SLOT = -1 __init__ () Initialize an instance of a Zymkey context.\n__del__ () led_on () Turn the LED on.\nExceptions AssertionError If ret is a bad return code from the Zymkey library function. led_off () Turn the LED off.\nExceptions AssertionError If ret is a bad return code from the Zymkey library function. led_flash ( on_ms, off_ms = 0, num_flashes = 0) Flash the LED.\nParameters on_ms (int) — The amount of time in milliseconds that the LED will be on for. off_ms (int) — The amount of time in milliseconds that the LED will be off for. If this parameter is set to 0 (default), the off time is the same as the on time. num_flashes (int) — The number of on/off cycles to execute. If this parameter is set to 0 (default), the LED flashes indefinitely. Exceptions AssertionError If ret is a bad return code from the Zymkey library function. get_random ( num_bytes) Get some random bytes.\nParameters num_bytes (int) — The number of random bytes to get. Exceptions AssertionError If ret is a bad return code from the Zymkey library function. Returns bytearray — An array of bytes returned by the random number generator. create_random_file ( file_path, num_bytes) Deposit random data in a file.\nParameters file_path (str) — The absolute path name for the destination file. num_bytes (int) — The number of random bytes to get. Exceptions AssertionError If ret is a bad return code from the Zymkey library function. lock ( src, dst = None, encryption_key = “zymkey”) Lock up source (plaintext) data.\nThis methods encrypts and signs a block of data.\nThe Zymkey that can be used for locking/unlocking operations.\nThe one-way key is meant to lock up data only on the local host computer. Data encrypted using this key cannot be exported and deciphered anywhere else. Parameters src (Union[str, bytes]) — The source (plaintext) data to lock.\nIf a str is passed to this method, the value is assumed to be the absolute path to the location of the source file. If bytes or bytesarray is passed, it is assumed to contain binary data. dst (Optional[str]) — The destination (ciphertext) of the locked data.\nIf a str is passed to this method, the value is assumed to be the absolute path to the location of the file where the destination data is meant to be written. Otherwise, if None is passed to the method (the default), the locked data is returned from the method as a bytearray. encryption_key (str) — This specifies which key will be used to lock the data. A value of “zymbit” (default) specifies that the Zymkey will use the one-way key. Exceptions AssertionError If ret is a bad return code from the Zymkey library function. Returns bytearray or None — The locked data is returned as a bytearray if no destination is specified when this method is called. Otherwise, None is returned. unlock ( src, dst = None, encryption_key = “zymkey”, raise_exception = True) Unlock source (ciphertext) data.\nThis method verifies a locked object signature and decrypts the associated ciphertext data.\nThe Zymkey has two keys that can be used for locking/unlocking operations.\nThe one-way key is meant to lock up data only on the local host computer. Data encrypted using this key cannot be exported and deciphered anywhere else. Parameters src (Union[str, bytes]) — The source (ciphertext) data to verify and decrypt.\nIf a str is passed to this method, the value is assumed to be the absolute path to the location of the source file. If bytes or bytesarray is passed, it is assumed to contain binary data. dst (Optional[str]) — The destination of the decrypted data (plaintext).\nIf a str is passed to this method, the value is assumed to be the absolute path to the location of the file where the destination data is meant to be written. Otherwise, if None is passed to the method (the default), the locked data is returned from the method as a bytearray. encryption_key (str) — This specifies which key will be used to lock the data. A value of “zymbit” (default) specifies that the Zymkey will use the one-way key. raise_exception (bool) — Specifies if an exception should be raised if the signature verification of the locked object fails. Exceptions AssertionError If ret is a bad return code from the Zymkey library function. Returns bytearray or None — The locked data is returned as a bytearray if no destination is specified when this method is called. Otherwise, None is returned. sign ( src, slot = 0, return_recid = False, encoding = “utf-8”, digest = None) Generate a signature using the Zymkey’s ECDSA private key.\nParameters src (Union[str, bytes, bytearray]) — The SHA256 digest of the data that will be used to generate the signature. slot (int) — The key slot used for signing. [HSM6]Slot can’t contain a X25519 key pair return_recid (bool) — This parameter asks for the y parity to be returned. encoding (str) — This parameter asks for the encoding for the string source. digest (_hashlib.HASH) — This parameter asks for the type of hash. Can be None. Defaults to sha256. Returns — bytearray – A bytearray of the signature. int – If return_recid = True, then return the y parity of the signature (either a 1 or 0). sign_digest ( digest, slot = 0, return_recid = False) Generate a signature using the Zymkey’s ECDSA private key.\nParameters digest (_hashlib.HASH) — A encoded str instance representing the digest to be signed. slot (int) — This parameter specifies the key slot used for signing. [HSM6]Slot can’t contain a X25519 key pair return_recid (bool) — This parameter asks for the y parity to be returned. Exceptions AssertionError If ret is a bad return code from the Zymkey library function. Returns — bytearray – The signature of the SHA-256 digest passed to this method. int – If return_recid = True, then return the y parity of the signature (either a 1 or 0). verify ( src, sig, raise_exception = True, pubkey_slot = 0, foreign = False, encoding = “utf-8”, digest = None) Verify data against a signature.\nThe public key is not specified in the parameter list to ensure that the public key that matches the Zymkey’s ECDSA private key is used.\nParameters src — The buffer to verify. sig — The signature to verify against. raise_exception (bool) — By default, when verification fails a VerificationError will be raised, unless this is set to False. pubkey_slot (int) — The key slot to use to verify the signature against. Defaults to the first key slot. foreign (bool) — If false, the normal key store is referenced. Otherwise, the foreign public key store is referenced.Note: This parameter is only applicable for Supported Devices: HSM6, Secure Compute Module. encoding (str) — This parameter asks for the encoding for the string source. digest (_hashlib.HASH) — This parameter asks for the type of hash. Can be None. Defaults to sha256. Returns bool — Returns True for a good verification or False for a bad verification when the raise_exception parameters is False. verify_digest ( digest, sig, raise_exception = True, pubkey_slot = 0, foreign = False) Verify a signature using the Zymkey’s ECDSA public key.\nThe public key is not specified in the parameter list to ensure that the public key that matches the Zymkey’s ECDSA private key is used.\nParameters digest — A hashlib instance that will be used to generate the signature. sig — The signature to verify. raise_exception (bool) — By default, when verification fails, a VerificationError will be raised, unless this is set to False. pubkey_slot (int) — The key slot to use to verify the signature against. Defaults to the first key slot. foreign (bool) — If false, the normal key store is referenced. Otherwise, the foreign public key store is referenced.Note: This parameter is only applicable for Supported Devices: HSM6, Secure Compute Module. Returns bool — Returns True for a good verification or False for a bad verification when raise_exception is False. ecdh ( local_slot, peer_pubkey, kdf_func_type = “none”, salt = [], info = [], num_iterations = 1, peer_pubkey_slot_is_foreign = True, derived_key_size = 32) Derive a key or a pre-master secret from an ECDH operation. (Supported Devices: HSM6, Secure Compute Module).\nParameters local_slot (int) — The local key slot to use. peer_pubkey (t.Union[t.List[bytes], int]) — The public key of the peer used to generate the pre-master secret against the private key located in local_slot. This parameter can be a list of bytes if the key is provided explicitly or an int if it refers to a key slot. kdf_func_type (str) — Specifies the KDF (Key Derivation Function) to use for the returned derived key. Valid values are:\n“none”: just return the pre-master secret. NOTE: The raw pre-master secret should not be used as a derived key should be put through a suitable KDF. Use “none” when it is desired to use a different KDF than what is offered by this method. “rfc5869-sha256”: RFC5869 with SHA256 “rfc5869-sha512”: RFC5869 with SHA512 “pbkdf2-sha256”: PBKDF2 with SHA256 “pbkdf2-sha512”: PBKDF2 with SHA512 salt (t.Optional[t.List[bytes]]) — A unique identifier for KDF. Ignored for kdf_func_type=’none’. info (t.Optional[t.List[bytes]]) — A unique field for rfc5869. Ignore for other KDF types. num_iterations (int) — The number of iterations that the KDF should complete. peer_pubkey_slot_is_foreign (bool) — TODO_DESCRIPTION derived_key_size (bool) — TODO_DESCRIPTION Returns bytearray — The computed signature. create_ecdsa_public_key_file ( filename, slot = 0) Create a file with the PEM-formatted ECDSA public key.\n[DEPRECATED]: Use create_public_key_file instead. This method is useful for generating a Certificate Signing Request.\nParameters filename (str) — The absolute file path where the public key will be stored in PEM format. slot (int) — The key slot for the public key. Exceptions AssertionError If ret is a bad return code from the Zymkey library function. create_public_key_file ( filename, slot = 0, foreign = False) Create a file with the PEM-formatted public key.\nThis method is useful for generating a Certificate Signing Request.\nParameters filename (str) — The absolute file path where the public key will be stored in PEM format. slot (int) — The key slot for the public key. foreign (bool) — If True, designates the pubkey slot to come from the foreign keystore (Supported Devices: HSM6, Secure Compute Module). Exceptions AssertionError If ret is a bad return code from the Zymkey library function. Returns TYPE — 0 for success, less than 0 for failure. get_ecdsa_public_key ( slot = 0) Retrieves the ECDSA public key as a binary bytearray.\n[DEPRECATED]: Use get_public_key instead. This method is used to retrieve the public key in binary form.\nParameters slot (int) — The key slot for the public key. Exceptions AssertionError If ret is a bad return code from the Zymkey library function. Returns bytearray — The public key in binary form. get_public_key ( slot = 0, foreign = False) Retrieves a public key as a binary bytearray.\nThis method is used to retrieve the public key in binary form.\nParameters slot (int) — The key slot for the public key. Zymkey and HSM4 have slots 0, 1, and 2. foreign (bool) — If True, designates the pubkey slot to come from the foreign keystore (Supported Devices: HSM6, Secure Compute Module). Exceptions AssertionError If ret is a bad return code from the Zymkey library function. Returns bytearray — The public key in binary form. get_slot_alloc_list ( foreign = False) Get a list of the allocated slots in the key store (Supported Devices: HSM6, Secure Compute Module).\nThis method gets a list of the allocated slots in the key store.\nParameters foreign (bool) — If True, designates the pubkey slot to come from the foreign keystore (Supported Devices: HSM6, Secure Compute Module). Exceptions AssertionError If ret is a bad return code from the Zymkey library function. Returns t.Tuple[list, int] — The allocation list and the maximum number of keys store_foreign_public_key ( key_type, pubkey) Stores a foreign public key on the Zymkey foreign keyring (Supported Devices: HSM6, Secure Compute Module).\nThis method stores a foreign public key onto the Zymkey foreign public keyring.\nParameters key_type — The EC curve type that should be associated with the public key. pubkey — The public key binary data. Exceptions AssertionError If ret is a bad return code from the Zymkey library function. Returns int — The slot allocated to the key, or less than one for failure. disable_public_key_export ( slot = 0, foreign = False) Disable exporting of a public key at a given slot (Supported Devices: HSM6, Secure Compute Module).\nThis method permanently disables exporting a public key from a given slot.\nParameters slot — This parameter specifies the key slot for the public key. foreign — If true, the slot refers to the foreign public keyring. Returns TYPE — 0 for success, less than 0 for failure. gen_key_pair ( key_type) Generate a new key pair (Supported Devices: HSM6, Secure Compute Module).\nThis method generates a new key pair of the specified type.\nParameters key_type — This parameter indicates the EC curve type that should be associated with the new key pair. Returns TYPE — the slot allocated to the key or less than one for failure. gen_ephemeral_key_pair ( key_type) Generate a new ephemeral key pair (Supported Devices: HSM6, Secure Compute Module).\nThis method generates a new ephemeral key pair of the specified type, overwriting the previous ephemeral key pair.\nParameters key_type — This parameter indicates the EC curve type that should be associated with the new key pair. Returns TYPE — 0 for success, less than 0 for failure. remove_key ( slot, foreign = False) Remove a key at the designated slot (Supported Devices: HSM6, Secure Compute Module).\nThis method removes a key at the designated slot in either the standard key store or the foreign public keyring.\nParameters slot — This parameter specifies the key slot for the key. foreign — If true, a public key in the foreign keyring will be deleted. Returns TYPE — 0 for success, less than 0 for failure. invalidate_ephemeral_key () Invalidate the ephemeral key (Supported Devices: HSM6, Secure Compute Module).\nThis method invalidates the ephemeral key, effectively removing it from service until a new key is generated.\nExceptions AssertionError If ret is a bad return code from the Zymkey library function. Returns TYPE — 0 for success, less than 0 for failure. gen_wallet_master_seed ( key_type, master_gen_key, wallet_name, recovery_strategy=\u003czymkey.RecoveryStrategy object\u003e) Generates a new master seed for creating a new BIP32 wallet (Supported Devices: HSM6, Secure Compute Module).\nThis method generates a new master seed for creating a new BIP32 wallet.\nParameters key_type — This parameter indicates the EC curve type that should be associated with the new key pair. master_gen_key — The master generator key (bytearray) used in the derivation of the child key. wallet_name — The name of the wallet (string) that this master seed is attached to. recovery_strategy — RecoveryStrategy() class that defines what strategy to be used {None, BIP39, SLIP39} are currently supported. RecoveryStrategy-\u003epassphrase must be b64 encoded. Returns TYPE — the slot the master seed was generated in. 0 for starting SLIP39 sessions. set_gen_SLIP39_group_info ( group_index, member_count, member_threshold) Configures the number of members and threshold for the group shares (Supported Devices: HSM6, Secure Compute Module).\nThis method sets the number of members required for a group share once a SLIP39 session was opened via gen_wallet_master_seed().\nParameters group_index — This parameter indicates the index of the group share to set the amount of member count/threshold for. member_count — The total number of members (mnemonics) in this group share. member_threshold — The number of members (mnemonics) needed to reconstruct the group share. Returns TYPE — 0 on successful configuration. non-zero for error. add_gen_SLIP39_member_pwd ( passphrase = ’’) Generates a new mnemonic_str tied to a SLIP39 member (Supported Devices: HSM6, Secure Compute Module).\nThis method generates a new member of a group share. Members can also be passphrase protected. Passphrases are not required to be unique. This function is meant to be called after configuring a group via set_gen_SLIP39_group_info().\nParameters passphrase — This parameter indicates the passphrase of the SLIP39 member and is associated with the mnemonic string generated. Can be empty string for no passphrase. Returns TYPE — A 24-word recovery phrase known as a mnemonic sentence. non-zero for error. cancel_SLIP39_session () Cancels an active SLIP39 session (Supported Devices: HSM6, Secure Compute Module).\nThis method cancels an ongoing SLIP39 session for both master seed generation and recovery.\nReturns TYPE — 0 on success. non-zero for error. gen_oversight_wallet ( key_type, pub_key, chain_code, node_addr, wallet_name, variant = ’’) Generates a supervisory bip32 wallet. (Supported Devices: HSM6, Secure Compute Module).\nThis method generates a new supervisory Bip32 wallet. Meant for read-only transactions and supervising history.\nParameters key_type — This parameter indicates the EC curve type that should be associated with the new key pair. pub_key — The public key (bytearray) of the last hardened node of the node address. chain_code — The chain code (bytearray) of the last hardened node of the node address. node_addr — The bip32 node address used. (EX: “m/1852’/1815’/0’”). wallet_name — The name of the wallet (string) that this master seed is attached to. variant — Key type variant to generate from. Currently only “cardano” is supported for “ed25519”. Returns TYPE — the slot the oversight wallet was generated in. gen_wallet_child_key ( parent_key_slot, index, hardened, return_chain_code = False) Generates a child key based on a parent key that is in a wallet (Supported Devices: HSM6, Secure Compute Module).\nThis method generates a child key based on a parent key that is in a wallet.\nParameters parent_key_slot — This parameter specifies the parent key slot. This key must already be part of a wallet. index — This parameter represents the index for the child key derivation which becomes part of the node address. hardened — If true, the key is a hardened key. return_chain_code — If true, returns the chain code for the key as well. (Must be from a hardened key). Returns TYPE — the allocated slot on success, or a tuple containing the chain code as well. restore_wallet_master_seed ( key_type, master_gen_key, wallet_name, recovery_strategy, mnemonics = None) Restore a wallet’s master seed based on the recovery strategy object (Supported Devices: HSM6, Secure Compute Module).\nThis method restores a wallet’s master seed based on a mnemonic string and a master generator key. This method can be used in the process of wallet duplication.\nParameters key_type — This parameter indicates the EC curve type that should be associated with the new key pair. master_gen_key — The master generator key used in the derivation of the child key. wallet_name — Name of the new wallet to be generated. recovery_strategy — RecoveryStategy class object that provides the type of recovery and key variant required for restoration. mnemonics — Mnemonic sentences required for restoration, number of mnemonics dependant on recovery strategy used. This field is not used for SLIP39. Returns TYPE — the allocated slot on success add_restore_SLIP39_mnemonic ( mnemonic_sentence, passphrase = ’’) Feed a mnemonic string and the passphrase associated with it (Supported Devices: HSM6, Secure Compute Module).\nThis method feeds in mnemonic sentences (shards) into the module. Meant to be called after starting a restore_wallet_master_seed() SLIP39 session. Will return -1 until the master seed is reconstructed properly.\nParameters mnemonic_sentence — 24-word recovery phrase associated with the SLIP39 member. passphrase — This parameter indicates the passphrase of the SLIP39 member and is associated with the mnemonic string generated. Can be empty string for no passphrase. Returns TYPE — A -1 for no change in status. Otherwise returns the slot of the master seed successfully reconstructed from the last shard passed in. get_wallet_node_addr ( slot) Get a wallet node address from a key slot (Supported Devices: HSM6, Secure Compute Module).\nThis method gets a wallet entry’s node address from its key slot assignment. The wallet name and master seed slot are also returned.\nParameters slot — The key slot assignment. Returns TYPE — the node address, wallet name and master seed key slot. get_wallet_key_slot ( node_addr, wallet_name = None, master_seed_slot = None) Look up a wallet key slot number from a node address (Supported Devices: HSM6, Secure Compute Module).\nThis method gets a wallet key slot number from its node address and wallet name or master seed key slot. Either the wallet name or the master seed slot must be present.\nParameters node_addr — The desired node address to look up wallet_name — The name of the wallet that the node address belongs to. Either this parameter or master_seed_slot must be specified or this function will fail. master_seed_slot — The master seed slot that the node address belongs to. Either this parameter or wallet_name must be specified or this function will fail. Returns TYPE — the key slot. set_i2c_address ( address) Set the i2c address of the Zymkey.\nNote: This is only applicable to versions of the Zymkey with i2c. This method should be called if the i2c address of the Zymkey is shared with another i2c device on the same i2c bus. The default i2c address for Zymkey units is 0x30. Currently, the address may be set in the ranges of 0x30 - 0x37 and 0x60 - 0x67.\nAfter successful completion of this command, the Zymkey will reboot itself.\nParameters address (int) — The i2c address that the Zymkey will set itself to. Exceptions AssertionError If ret is a bad return code from the Zymkey library function. Returns TYPE — 0 for success, less than 0 for failure. set_tap_sensitivity ( axis = “all”, pct = 50.0) Set the sensitivity of tap operations.\nThis method permits setting the sensitivity of the tap detection feature. Each axis may be individually configured or all at once.\nParameters axis — The axis to configure. Valid values include: ’all’: Configure all axes with the specified sensitivity value. ’x’ or “X”: Configure only the x-axis. ’y’ or “Y”: Configure only the y-axis. ’z’ or “Z”: Configure only the z-axis. pct — The sensitivity expressed as percentage. 0% = Shut down: Tap detection should not occur along the axis. 100% = Maximum sensitivity. Returns TYPE — 0 for success, less than 0 for failure. wait_for_tap ( timeout_ms = -1) Wait for tap event.\nThis function is called in order to wait for a tap event to occur. This function blocks the calling thread unless called with a timeout of zero.\nParameters timeout_ms — The maximum amount of time in milliseconds to wait for a tap event to arrive. class ZymkeyAccelAxisData ( g_force, tap_dir) __init__ ( g_force, tap_dir) Initialize self. See help(type(self)) for accurate signature.\nget_accelerometer_data () Get current accelerometer data and tap info.\nThis function gets the most recent accelerometer data in units of g forces plus the tap direction per axis.\nReturns An array of accelerometer readings in units of g-force. array index 0 = x axis – 1 = y axis 2 = z axis A value of -1 indicates that the tap event was detected in a negative direction for the axis, +1 for a positive direction and 0 for stationary. get_time ( precise = False) Get current GMT time.\nThis function is called to get the time directly from a Zymkey’s Real Time Clock (RTC).\nParameters precise — If true, this API returns the time after the next second falls. This means that the caller could be blocked up to one second. If False, the API returns immediately with the current time reading. Returns Time in epoch seconds — lock_binding () Set soft binding lock.\nThis function locks the binding for a specific HSM. This API is only valid for HSM series products.\nExceptions AssertionError If ret is a bad return code from the Zymkey library function. get_current_binding_info () Get current binding info.\nThis function gets the current binding lock state as well as the current binding state. This API is only valid for devices in the HSM family.\nReturns binding_is_locked – Binary value which expresses the current binding lock state. is_bound – Binary value which expresses the current bind state. set_perimeter_event_actions ( channel, action_notify = True, action_self_destruct = False) Set perimeter breach action.\nThis function specifies the action to take when a perimeter breach event occurs. The possible actions are any combination of:\nNotify host. Zymkey self-destruct. Parameters channel — The channel (0 or 1) that the action flags will be applied to action_notify — Set a perimeter breach to notify. (default = True) action_self_destruct — Set a perimeter breach to self destruct. (default = False) Returns TYPE — 0 for success, less than 0 for failure. set_digital_perimeter_lp_period ( lp_period) Set the digital perimeter detect low power period (Supported Devices: HSM6, Secure Compute Module).\nThis function sets the digital perimeter detect low power period (microseconds).\nParameters lp_period — The perimeter detect low power period in microseconds. Returns TYPE — 0 for success, less than 0 for failure. set_digital_perimeter_lp_max_bits ( max_num_bits) Set the low power max number of bits (Supported Devices: HSM6, Secure Compute Module).\nThis function sets the digital perimeter detect low power max number of bits.\nParameters max_num_bits — The perimeter detect low power max number of bits Returns TYPE — 0 for success, less than 0 for failure. set_digital_perimeter_delays ( min_delay_ns, max_delay_ns) Set the digital perimeter detect delays (Supported Devices: HSM6, Secure Compute Module).\nThis function sets the digital perimeter detect delay values.\nParameters min_delay_ns — The minimum delay in nanoseconds. max_delay_ns — The maximum delay in nanoseconds. Returns TYPE — 0 for success, less than 0 for failure. wait_for_perimeter_event ( timeout_ms = -1) Wait for a perimeter breach event to be detected.\nThis function is called in order to wait for a perimeter breach event to occur. This function blocks the calling thread unless called with a timeout of zero.\nParameters timeout_ms — (input) The maximum amount of time in milliseconds to wait for a perimeter breach event to arrive. Returns TYPE — 0 for success, less than 0 for failure. get_perimeter_detect_info () Get current perimeter detect info.\nThis function gets the timestamp of the first perimeter detect event for the given channel. The index corresponds to the channel specified in set_perimeter_event_actions.\nReturns TYPE — The array of timestamps for each channel for the first detected event in epoch seconds clear_perimeter_detect_info () Clear perimeter detect info.\nThis function clears all perimeter detect info and rearms all perimeter detect channels.\nReturns TYPE — 0 for success, less than 0 for failure. get_cpu_temp () Get current CPU temperature (Supported Devices: HSM6, Secure Compute Module).\nThis function gets the current HSM CPU temperature.\nReturns TYPE — The CPU temperature in celsius as a float get_aux_temp ( index = 0) Get current aux temperature (Secure Compute Modules only).\nTHIS FUNCTION IS FOR INTERNAL ZYMBIT USE ONLY.\nThis function gets the current aux temperature. (defaults to 0).\nParameters index — (input) The index id of the processor. Returns TYPE — The temperature in celsius as a float get_rtc_drift () Get RTC drift (Supported Devices: HSM6, Secure Compute Module).\nThis function gets the current RTC drift.\nReturns TYPE — The RTC drift as a float get_batt_volt () Get current battery voltage (Supported Devices: HSM6, Secure Compute Module).\nThis function gets the current battery voltage.\nReturns TYPE — The battery voltage as a float get_model_number () Get Zymkey model number.\nThis function gets the Zymkey model number.\nReturns TYPE — The model number as a string. get_firmware_version () Get Zymkey firmware version.\nThis function gets the Zymkey firmware version.\nReturns TYPE — The firmware version as a string. get_serial_number () Get Zymkey serial number.\nThis function gets the Zymkey serial number.\nReturns TYPE — The serial number as a string. set_battery_voltage_action ( sleep = False, self_destruct = False) Set battery voltage action. (Supported Devices: HSM6, Secure Compute Module).\nThis function specifies the action to take when the battery voltage falls below the threshold set by set_battery_voltage_threshold. If this function is never called, do nothing is default. There are three actions:\nDo nothing. Go to sleep until battery is replaced. Self-destruct. With sleep and self_destruct set to False, it removes a previously set sleep or self_destruct action.\nParameters sleep — Set the sleep action. self_destruct — Set the self_destruct action. Returns TYPE — 0 for success, less than 0 for failure. set_battery_voltage_threshold ( threshold) Sets the battery voltage threshold. (Supported Devices: HSM6, Secure Compute Module).\nThis function sets the threshold at which if the battery voltage falls bellow, the action set by set_battery_voltage_action will be carried out. The recommended threshold is 2.3V is assumed by default. Threshold must be below 2.5V.\nParameters threshold — The threshold in Volts. Returns TYPE — 0 for success, less than 0 for failure. set_cpu_temp_action ( self_destruct = False) Set HSM CPU temperature threshold action. (Supported Devices: HSM6, Secure Compute Module).\nThis function specifies the action to take when the HSM CPU temperature falls below the threshold set by set_cpu_low_temp_threshold, or rises above the threshold set by set_cpu_high_temp_threshold. There are two actions to apply:\nDo nothing. Self-destruct. To remove a previously set self-destruct action, call this function with self_destruct=False.\nParameters self_destruct — Set the self_destruct action. Returns TYPE — 0 for success, less than 0 for failure. set_cpu_low_temp_threshold ( threshold) Sets the HSM CPU low temperature threshold. (Supported Devices: HSM6, Secure Compute Module).\nThis function sets the threshold at which if the on-board HSM CPU’s tempreature falls below, the action set by set_cpu_temp_action will be carried out. WARNING: You can lock yourself out in dev mode if you set a threshold above the CPU’s ambient temperature. The recommended setting is no more than 20C. If this function is never called, -10 degrees celsius is assumed.\nParameters threshold — The threshold in celsius. Returns TYPE — 0 for success, less than 0 for failure. set_cpu_high_temp_threshold ( threshold) Sets the HSM CPU high temperature threshold. (Supported Devices: HSM6, Secure Compute Module).\nThis function sets the threshold at which if the on-board HSM CPU’s tempreature rises above, the action set by set_cpu_temp_action will be carried out. WARNING: You can lock yourself out in dev mode if you set a threshold below the CPU’s ambient temperature. The recommended setting is no less than 40C. If this function is never called, 65 degrees celsius is assumed.\nParameters threshold — The threshold in celsius. Returns TYPE — 0 for success, less than 0 for failure. set_supervised_boot_policy ( policy_id = 0) Sets the Supervised boot policy. (Supported Devices: Secure Compute Module).\nThis function sets the action policy to take when Supervised boot detects a file change during the boot process.\nParameters policy_id (int) — The actions to apply to the Supervised boot process: - 0 Do Nothing - 1 Self-Destruct - 2 Hold Chip in Reset Returns TYPE — 0 for success, less than 0 for failure. add_or_update_supervised_boot_file ( filepath = ’’, slot = 15) Update file manifest for Supervised boot to check. (Supported Devices: Secure Compute Module).\nThis function adds or updates a file in the file manifest to be checked by Supervised during the boot process.\nParameters slot (int) — The slot to sign the file with. filepath (str) — The file to be signed and checked by Supervised boot. Returns TYPE — 0 for success, less than 0 for failure. remove_supervised_boot_file ( filepath = ’’) Remove a file from file manifest for Supervised boot to check. (Supported Devices: Secure Compute Module).\nThis function removes a file in the file manifest to be checked by Supervised boot during the boot process.\nParameters filepath (str) — The file to be removed from the manifest. Returns TYPE — 0 for success, less than 0 for failure. get_supervised_boot_file_manifest () Get the file manifest for Supervised boot to check. (Supported Devices: Secure Compute Module).\nThis function gets a list of the files that are checked by Supervised boot during the boot process.\nReturns TYPE – 0 for success, less than 0 for failure. TYPE – File manifest to be checked by Supervised boot. class zymkey.RecoveryStrategy ( variant = ’’) The RecoveryStrategy class definition.\nThis class specifies the recovery strategy used for wallet generation within Python. Base class strategy is to do no recovery.\n__init__ ( variant = ’’) Initialize an instance of RecoveryStrategy.\nParameters variant — Variant of the key type. Currently only “cardano” for ed25519 is supported. class zymkey.RecoveryStrategyBIP39 ( variant = ’’, passphrase = ’’) The RecoveryStrategyBIP39 class definition.\nThis class specifies the BIP39 recovery strategy used for wallet generation within Python. Derived from RecoveryStrategy class.\n__init__ ( variant = ’’, passphrase = ’’) Initialize an instance of RecoveryStrategyBIP39.\nParameters variant — Variant of the key type. Currently only “cardano” for ed25519 is supported. passphrase — Passphrase used for BIP39 generation. Can be empty string. Must be b64 encoded. class zymkey.RecoveryStrategySLIP39 ( group_count, group_threshold, iteration_exponent, variant = ’’, passphrase = ’’) The RecoveryStrategySLIP39 class definition.\nThis class specifies the SLIP39 recovery strategy used for wallet generation within Python. Derived from RecoveryStrategy class.\n__init__ ( group_count, group_threshold, iteration_exponent, variant = ’’, passphrase = ’’) Initialize an instance of RecoveryStrategySLIP39.\nParameters group_count — Total number of group shares to generate [Max: 14 Groups]. group_threshold — Number of groups needed to restore a master seed with [threshold \u003c= group_count]. iteration_exponent — The higher the exponent the more PBKDF2 hashing is done. [Exponent: 0-5] variant — Variant of the key type. Currently only “cardano” for ed25519 is supported. passphrase — Passphrase used for BIP39 generation. Can be empty string. Must be b64 encoded. ","categories":"","description":"Python interface module to Zymkey Application Utilities Library.","excerpt":"Python interface module to Zymkey Application Utilities Library.","ref":"/api/python_api/","tags":"","title":"Python API Documentation"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/","tags":"","title":"Tags"}]